Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM g_main_quad ID add_program SEMICOLON vars funcs main end_program
Rule 2     add_program -> <empty>
Rule 3     end_program -> <empty>
Rule 4     main -> MAIN OPEN_PAREN CLOSE_PAREN fill_main_quad block
Rule 5     g_main_quad -> <empty>
Rule 6     fill_main_quad -> <empty>
Rule 7     funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs
Rule 8     funcs -> empty
Rule 9     end_funcs -> <empty>
Rule 10    count_local_vars -> <empty>
Rule 11    add_module -> <empty>
Rule 12    funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs
Rule 13    add_parameter_amount -> <empty>
Rule 14    funcs_params -> var_type variable_params funcs_params_comp
Rule 15    funcs_params -> empty
Rule 16    funcs_params_comp -> COMMA var_type variable_params funcs_params_comp
Rule 17    funcs_params_comp -> empty
Rule 18    variable_params -> ID
Rule 19    variable_params -> ID dim
Rule 20    block -> OPEN_BRACES statements CLOSE_BRACES
Rule 21    func_type -> var_type
Rule 22    func_type -> VOID
Rule 23    var_type -> INT
Rule 24    var_type -> FLOAT
Rule 25    var_type -> CHAR
Rule 26    vars -> VARS var_comp
Rule 27    vars -> empty
Rule 28    var_comp -> var_type ids_dec var_comp_2 var_comp_final
Rule 29    var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive
Rule 30    var_comp_2 -> COMMA ids_dec var_comp_3
Rule 31    var_comp_2 -> empty
Rule 32    var_comp_3 -> var_comp_2
Rule 33    var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final
Rule 34    var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive
Rule 35    var_comp_final -> SEMICOLON
Rule 36    var_comp_final -> var_module_trans
Rule 37    var_module_trans -> SEMICOLON var_type MODULE funcs_comp
Rule 38    ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
Rule 39    ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS
Rule 40    ids_dec -> ID
Rule 41    ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
Rule 42    ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS
Rule 43    ids -> ID
Rule 44    statements -> assignment SEMICOLON statements
Rule 45    statements -> read SEMICOLON statements
Rule 46    statements -> write SEMICOLON statements
Rule 47    statements -> condition statements
Rule 48    statements -> return SEMICOLON statements
Rule 49    statements -> func_call SEMICOLON statements
Rule 50    statements -> empty
Rule 51    assignment -> ids ASSIGN expressions
Rule 52    read -> READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN
Rule 53    read_comp -> COMMA ids g_quad_read read_comp
Rule 54    read_comp -> empty
Rule 55    g_quad_read -> <empty>
Rule 56    write -> WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
Rule 57    write -> WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN
Rule 58    write_comp -> COMMA CT_STRING g_quad_write_str write_comp
Rule 59    write_comp -> COMMA expressions g_quad_write write_comp
Rule 60    write_comp -> empty
Rule 61    g_quad_write_str -> <empty>
Rule 62    g_quad_write -> <empty>
Rule 63    end_if -> <empty>
Rule 64    condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
Rule 65    condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
Rule 66    condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
Rule 67    condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
Rule 68    g_if_quad -> <empty>
Rule 69    g_else_quad -> <empty>
Rule 70    while_jump -> <empty>
Rule 71    g_while_quad -> <empty>
Rule 72    end_while -> <empty>
Rule 73    validate_for -> <empty>
Rule 74    for_counter_control -> <empty>
Rule 75    for_counter_end -> <empty>
Rule 76    end_for -> <empty>
Rule 77    return -> RETURN OPEN_PAREN expressions CLOSE_PAREN return_end
Rule 78    return_end -> <empty>
Rule 79    func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global
Rule 80    g_gosub_quad -> <empty>
Rule 81    change_to_global -> <empty>
Rule 82    verify_function_exists -> <empty>
Rule 83    era_activation -> <empty>
Rule 84    func_call_comp -> expressions g_parameter_quad func_call_comp
Rule 85    func_call_comp -> COMMA expressions g_parameter_quad func_call_comp
Rule 86    func_call_comp -> empty
Rule 87    g_parameter_quad -> <empty>
Rule 88    parameter_check_comma -> <empty>
Rule 89    expressions -> expressions_comp
Rule 90    expressions_comp -> expression_comp_2
Rule 91    expressions_comp -> expression_comp_2 OR expressions_comp
Rule 92    expression_comp_2 -> expression_comp_3
Rule 93    expression_comp_2 -> expression_comp_3 AND expression_comp_2
Rule 94    expression_comp_3 -> exp expressions_op exp g_quad_logic
Rule 95    expression_comp_3 -> exp
Rule 96    g_quad_logic -> <empty>
Rule 97    expressions_op -> LESS_THAN add_op
Rule 98    expressions_op -> LESS_THAN_EQUAL add_op
Rule 99    expressions_op -> MORE_THAN add_op
Rule 100   expressions_op -> MORE_THAN_EQUAL add_op
Rule 101   expressions_op -> EQUALS add_op
Rule 102   expressions_op -> NOT_EQUALS add_op
Rule 103   exp -> term g_quad_exp_as_alone
Rule 104   exp -> term g_quad_exp_as exp_comp
Rule 105   g_quad_exp_as -> <empty>
Rule 106   g_quad_exp_as_alone -> <empty>
Rule 107   exp_comp -> PLUS add_op exp
Rule 108   exp_comp -> MINUS add_op exp
Rule 109   term -> factor g_quad_exp_md_alone
Rule 110   term -> factor g_quad_exp_md term_comp
Rule 111   g_quad_exp_md -> <empty>
Rule 112   g_quad_exp_md_alone -> <empty>
Rule 113   term_comp -> MULTIPLIES add_op term
Rule 114   term_comp -> DIVIDE add_op term
Rule 115   add_op -> <empty>
Rule 116   factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
Rule 117   factor -> variable
Rule 118   factor -> func_call
Rule 119   factor -> CT_INT add_ct_int
Rule 120   factor -> CT_FLOAT add_ct_float
Rule 121   factor -> CT_CHAR add_ct_char
Rule 122   add_fake -> <empty>
Rule 123   rem_fake -> <empty>
Rule 124   add_ct_int -> <empty>
Rule 125   add_ct_float -> <empty>
Rule 126   add_ct_char -> <empty>
Rule 127   variable -> ID add_id
Rule 128   variable -> ID dim
Rule 129   add_id -> <empty>
Rule 130   dim -> OPEN_BRACKETS exp CLOSE_BRACKETS
Rule 131   empty -> <empty>

Terminals, with rules where they appear

AND                  : 93
ASSIGN               : 51 67
CHAR                 : 25
CLOSE_BRACES         : 20
CLOSE_BRACKETS       : 38 38 39 41 41 42 130
CLOSE_PAREN          : 4 7 12 52 56 57 64 65 66 77 79 116
COMMA                : 16 30 53 58 59 85
CT_CHAR              : 121
CT_FLOAT             : 120
CT_INT               : 38 38 39 119
CT_STRING            : 56 58
DIVIDE               : 114
DO                   : 66 67
ELSE                 : 65
EQUALS               : 101
FLOAT                : 24
FOR                  : 67
ID                   : 1 7 12 18 19 38 39 40 41 42 43 79 127 128
IF                   : 64 65
INT                  : 23
LESS_THAN            : 97
LESS_THAN_EQUAL      : 98
MAIN                 : 4
MINUS                : 108
MODULE               : 7 37
MORE_THAN            : 99
MORE_THAN_EQUAL      : 100
MULTIPLIES           : 113
NOT_EQUALS           : 102
OPEN_BRACES          : 20
OPEN_BRACKETS        : 38 38 39 41 41 42 130
OPEN_PAREN           : 4 7 12 52 56 57 64 65 66 77 79 116
OR                   : 91
PLUS                 : 107
PROGRAM              : 1
READ                 : 52
RETURN               : 77
SEMICOLON            : 1 29 34 35 37 44 45 46 48 49
THEN                 : 64 65
TO                   : 67
VARS                 : 26
VOID                 : 22
WHILE                : 66
WRITE                : 56 57
error                : 

Nonterminals, with rules where they appear

add_ct_char          : 121
add_ct_float         : 120
add_ct_int           : 119
add_fake             : 116
add_id               : 127
add_module           : 7 12
add_op               : 97 98 99 100 101 102 107 108 113 114
add_parameter_amount : 7 12
add_program          : 1
assignment           : 44
block                : 4 7 12 64 65 65 66 67
change_to_global     : 79
condition            : 47
count_local_vars     : 7 12
dim                  : 19 128
empty                : 8 15 17 27 31 50 54 60 86
end_for              : 67
end_funcs            : 7 12
end_if               : 64 65
end_program          : 1
end_while            : 66
era_activation       : 79
exp                  : 41 41 42 94 94 95 107 108 130
exp_comp             : 104
expression_comp_2    : 90 91 93
expression_comp_3    : 92 93
expressions          : 51 57 59 64 65 66 67 67 77 84 85 116
expressions_comp     : 89 91
expressions_op       : 94
factor               : 109 110
fill_main_quad       : 4
for_counter_control  : 67
for_counter_end      : 67
func_call            : 49 118
func_call_comp       : 79 84 85
func_type            : 7
funcs                : 1 7 12
funcs_comp           : 37
funcs_params         : 7 12
funcs_params_comp    : 14 16
g_else_quad          : 65
g_gosub_quad         : 79
g_if_quad            : 64 65
g_main_quad          : 1
g_parameter_quad     : 84 85
g_quad_exp_as        : 104
g_quad_exp_as_alone  : 103
g_quad_exp_md        : 110
g_quad_exp_md_alone  : 109
g_quad_logic         : 94
g_quad_read          : 52 53
g_quad_write         : 57 59
g_quad_write_str     : 56 58
g_while_quad         : 66
ids                  : 51 52 53 67
ids_dec              : 28 29 30 33 34
main                 : 1
parameter_check_comma : 
program              : 0
read                 : 45
read_comp            : 52 53
rem_fake             : 116
return               : 48
return_end           : 77
statements           : 20 44 45 46 47 48 49
term                 : 103 104 113 114
term_comp            : 110
validate_for         : 67
var_comp             : 26
var_comp_2           : 28 29 32 33 34
var_comp_3           : 30
var_comp_final       : 28 33
var_comp_recursive   : 29 34
var_module_trans     : 36
var_type             : 14 16 21 28 29 33 34 37
variable             : 117
variable_params      : 14 16
vars                 : 1 7 12
verify_function_exists : 79
while_jump           : 66
write                : 46
write_comp           : 56 57 58 59

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM g_main_quad ID add_program SEMICOLON vars funcs main end_program

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . g_main_quad ID add_program SEMICOLON vars funcs main end_program
    (5) g_main_quad -> .

    ID              reduce using rule 5 (g_main_quad -> .)

    g_main_quad                    shift and go to state 3

state 3

    (1) program -> PROGRAM g_main_quad . ID add_program SEMICOLON vars funcs main end_program

    ID              shift and go to state 4


state 4

    (1) program -> PROGRAM g_main_quad ID . add_program SEMICOLON vars funcs main end_program
    (2) add_program -> .

    SEMICOLON       reduce using rule 2 (add_program -> .)

    add_program                    shift and go to state 5

state 5

    (1) program -> PROGRAM g_main_quad ID add_program . SEMICOLON vars funcs main end_program

    SEMICOLON       shift and go to state 6


state 6

    (1) program -> PROGRAM g_main_quad ID add_program SEMICOLON . vars funcs main end_program
    (26) vars -> . VARS var_comp
    (27) vars -> . empty
    (131) empty -> .

    VARS            shift and go to state 8
    VOID            reduce using rule 131 (empty -> .)
    INT             reduce using rule 131 (empty -> .)
    FLOAT           reduce using rule 131 (empty -> .)
    CHAR            reduce using rule 131 (empty -> .)
    MAIN            reduce using rule 131 (empty -> .)

    vars                           shift and go to state 7
    empty                          shift and go to state 9

state 7

    (1) program -> PROGRAM g_main_quad ID add_program SEMICOLON vars . funcs main end_program
    (7) funcs -> . func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs
    (8) funcs -> . empty
    (21) func_type -> . var_type
    (22) func_type -> . VOID
    (131) empty -> .
    (23) var_type -> . INT
    (24) var_type -> . FLOAT
    (25) var_type -> . CHAR

    VOID            shift and go to state 14
    MAIN            reduce using rule 131 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

    funcs                          shift and go to state 10
    func_type                      shift and go to state 11
    empty                          shift and go to state 12
    var_type                       shift and go to state 13

state 8

    (26) vars -> VARS . var_comp
    (28) var_comp -> . var_type ids_dec var_comp_2 var_comp_final
    (29) var_comp -> . var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive
    (23) var_type -> . INT
    (24) var_type -> . FLOAT
    (25) var_type -> . CHAR

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

    var_comp                       shift and go to state 18
    var_type                       shift and go to state 19

state 9

    (27) vars -> empty .

    VOID            reduce using rule 27 (vars -> empty .)
    INT             reduce using rule 27 (vars -> empty .)
    FLOAT           reduce using rule 27 (vars -> empty .)
    CHAR            reduce using rule 27 (vars -> empty .)
    MAIN            reduce using rule 27 (vars -> empty .)
    OPEN_BRACES     reduce using rule 27 (vars -> empty .)


state 10

    (1) program -> PROGRAM g_main_quad ID add_program SEMICOLON vars funcs . main end_program
    (4) main -> . MAIN OPEN_PAREN CLOSE_PAREN fill_main_quad block

    MAIN            shift and go to state 21

    main                           shift and go to state 20

state 11

    (7) funcs -> func_type . MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs

    MODULE          shift and go to state 22


state 12

    (8) funcs -> empty .

    MAIN            reduce using rule 8 (funcs -> empty .)
    VOID            reduce using rule 8 (funcs -> empty .)
    INT             reduce using rule 8 (funcs -> empty .)
    FLOAT           reduce using rule 8 (funcs -> empty .)
    CHAR            reduce using rule 8 (funcs -> empty .)
    OPEN_BRACES     reduce using rule 8 (funcs -> empty .)


state 13

    (21) func_type -> var_type .

    MODULE          reduce using rule 21 (func_type -> var_type .)


state 14

    (22) func_type -> VOID .

    MODULE          reduce using rule 22 (func_type -> VOID .)


state 15

    (23) var_type -> INT .

    MODULE          reduce using rule 23 (var_type -> INT .)
    ID              reduce using rule 23 (var_type -> INT .)


state 16

    (24) var_type -> FLOAT .

    MODULE          reduce using rule 24 (var_type -> FLOAT .)
    ID              reduce using rule 24 (var_type -> FLOAT .)


state 17

    (25) var_type -> CHAR .

    MODULE          reduce using rule 25 (var_type -> CHAR .)
    ID              reduce using rule 25 (var_type -> CHAR .)


state 18

    (26) vars -> VARS var_comp .

    VOID            reduce using rule 26 (vars -> VARS var_comp .)
    INT             reduce using rule 26 (vars -> VARS var_comp .)
    FLOAT           reduce using rule 26 (vars -> VARS var_comp .)
    CHAR            reduce using rule 26 (vars -> VARS var_comp .)
    MAIN            reduce using rule 26 (vars -> VARS var_comp .)
    OPEN_BRACES     reduce using rule 26 (vars -> VARS var_comp .)


state 19

    (28) var_comp -> var_type . ids_dec var_comp_2 var_comp_final
    (29) var_comp -> var_type . ids_dec var_comp_2 SEMICOLON var_comp_recursive
    (38) ids_dec -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (39) ids_dec -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (40) ids_dec -> . ID

    ID              shift and go to state 24

    ids_dec                        shift and go to state 23

state 20

    (1) program -> PROGRAM g_main_quad ID add_program SEMICOLON vars funcs main . end_program
    (3) end_program -> .

    $end            reduce using rule 3 (end_program -> .)

    end_program                    shift and go to state 25

state 21

    (4) main -> MAIN . OPEN_PAREN CLOSE_PAREN fill_main_quad block

    OPEN_PAREN      shift and go to state 26


state 22

    (7) funcs -> func_type MODULE . ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs

    ID              shift and go to state 27


state 23

    (28) var_comp -> var_type ids_dec . var_comp_2 var_comp_final
    (29) var_comp -> var_type ids_dec . var_comp_2 SEMICOLON var_comp_recursive
    (30) var_comp_2 -> . COMMA ids_dec var_comp_3
    (31) var_comp_2 -> . empty
    (131) empty -> .

    COMMA           shift and go to state 29
    SEMICOLON       reduce using rule 131 (empty -> .)

    var_comp_2                     shift and go to state 28
    empty                          shift and go to state 30

state 24

    (38) ids_dec -> ID . OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (39) ids_dec -> ID . OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (40) ids_dec -> ID .

    OPEN_BRACKETS   shift and go to state 31
    COMMA           reduce using rule 40 (ids_dec -> ID .)
    SEMICOLON       reduce using rule 40 (ids_dec -> ID .)


state 25

    (1) program -> PROGRAM g_main_quad ID add_program SEMICOLON vars funcs main end_program .

    $end            reduce using rule 1 (program -> PROGRAM g_main_quad ID add_program SEMICOLON vars funcs main end_program .)


state 26

    (4) main -> MAIN OPEN_PAREN . CLOSE_PAREN fill_main_quad block

    CLOSE_PAREN     shift and go to state 32


state 27

    (7) funcs -> func_type MODULE ID . add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs
    (11) add_module -> .

    OPEN_PAREN      reduce using rule 11 (add_module -> .)

    add_module                     shift and go to state 33

state 28

    (28) var_comp -> var_type ids_dec var_comp_2 . var_comp_final
    (29) var_comp -> var_type ids_dec var_comp_2 . SEMICOLON var_comp_recursive
    (35) var_comp_final -> . SEMICOLON
    (36) var_comp_final -> . var_module_trans
    (37) var_module_trans -> . SEMICOLON var_type MODULE funcs_comp

    SEMICOLON       shift and go to state 35

    var_comp_final                 shift and go to state 34
    var_module_trans               shift and go to state 36

state 29

    (30) var_comp_2 -> COMMA . ids_dec var_comp_3
    (38) ids_dec -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (39) ids_dec -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (40) ids_dec -> . ID

    ID              shift and go to state 24

    ids_dec                        shift and go to state 37

state 30

    (31) var_comp_2 -> empty .

    SEMICOLON       reduce using rule 31 (var_comp_2 -> empty .)


state 31

    (38) ids_dec -> ID OPEN_BRACKETS . CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (39) ids_dec -> ID OPEN_BRACKETS . CT_INT CLOSE_BRACKETS

    CT_INT          shift and go to state 38


state 32

    (4) main -> MAIN OPEN_PAREN CLOSE_PAREN . fill_main_quad block
    (6) fill_main_quad -> .

    OPEN_BRACES     reduce using rule 6 (fill_main_quad -> .)

    fill_main_quad                 shift and go to state 39

state 33

    (7) funcs -> func_type MODULE ID add_module . OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs

    OPEN_PAREN      shift and go to state 40


state 34

    (28) var_comp -> var_type ids_dec var_comp_2 var_comp_final .

    VOID            reduce using rule 28 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)
    INT             reduce using rule 28 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)
    FLOAT           reduce using rule 28 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)
    CHAR            reduce using rule 28 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)
    MAIN            reduce using rule 28 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)
    OPEN_BRACES     reduce using rule 28 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)


state 35

    (29) var_comp -> var_type ids_dec var_comp_2 SEMICOLON . var_comp_recursive
    (35) var_comp_final -> SEMICOLON .
    (37) var_module_trans -> SEMICOLON . var_type MODULE funcs_comp
    (33) var_comp_recursive -> . var_type ids_dec var_comp_2 var_comp_final
    (34) var_comp_recursive -> . var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive
    (23) var_type -> . INT
    (24) var_type -> . FLOAT
    (25) var_type -> . CHAR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
    VOID            reduce using rule 35 (var_comp_final -> SEMICOLON .)
    MAIN            reduce using rule 35 (var_comp_final -> SEMICOLON .)
    OPEN_BRACES     reduce using rule 35 (var_comp_final -> SEMICOLON .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

  ! INT             [ reduce using rule 35 (var_comp_final -> SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 35 (var_comp_final -> SEMICOLON .) ]
  ! CHAR            [ reduce using rule 35 (var_comp_final -> SEMICOLON .) ]

    var_type                       shift and go to state 41
    var_comp_recursive             shift and go to state 42

state 36

    (36) var_comp_final -> var_module_trans .

    VOID            reduce using rule 36 (var_comp_final -> var_module_trans .)
    INT             reduce using rule 36 (var_comp_final -> var_module_trans .)
    FLOAT           reduce using rule 36 (var_comp_final -> var_module_trans .)
    CHAR            reduce using rule 36 (var_comp_final -> var_module_trans .)
    MAIN            reduce using rule 36 (var_comp_final -> var_module_trans .)
    OPEN_BRACES     reduce using rule 36 (var_comp_final -> var_module_trans .)


state 37

    (30) var_comp_2 -> COMMA ids_dec . var_comp_3
    (32) var_comp_3 -> . var_comp_2
    (30) var_comp_2 -> . COMMA ids_dec var_comp_3
    (31) var_comp_2 -> . empty
    (131) empty -> .

    COMMA           shift and go to state 29
    SEMICOLON       reduce using rule 131 (empty -> .)

    var_comp_3                     shift and go to state 43
    var_comp_2                     shift and go to state 44
    empty                          shift and go to state 30

state 38

    (38) ids_dec -> ID OPEN_BRACKETS CT_INT . CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (39) ids_dec -> ID OPEN_BRACKETS CT_INT . CLOSE_BRACKETS

    CLOSE_BRACKETS  shift and go to state 45


state 39

    (4) main -> MAIN OPEN_PAREN CLOSE_PAREN fill_main_quad . block
    (20) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 47

    block                          shift and go to state 46

state 40

    (7) funcs -> func_type MODULE ID add_module OPEN_PAREN . funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs
    (14) funcs_params -> . var_type variable_params funcs_params_comp
    (15) funcs_params -> . empty
    (23) var_type -> . INT
    (24) var_type -> . FLOAT
    (25) var_type -> . CHAR
    (131) empty -> .

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    CLOSE_PAREN     reduce using rule 131 (empty -> .)

    funcs_params                   shift and go to state 48
    var_type                       shift and go to state 49
    empty                          shift and go to state 50

state 41

    (37) var_module_trans -> SEMICOLON var_type . MODULE funcs_comp
    (33) var_comp_recursive -> var_type . ids_dec var_comp_2 var_comp_final
    (34) var_comp_recursive -> var_type . ids_dec var_comp_2 SEMICOLON var_comp_recursive
    (38) ids_dec -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (39) ids_dec -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (40) ids_dec -> . ID

    MODULE          shift and go to state 51
    ID              shift and go to state 24

    ids_dec                        shift and go to state 52

state 42

    (29) var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .

    VOID            reduce using rule 29 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    INT             reduce using rule 29 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    FLOAT           reduce using rule 29 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    CHAR            reduce using rule 29 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    MAIN            reduce using rule 29 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    OPEN_BRACES     reduce using rule 29 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)


state 43

    (30) var_comp_2 -> COMMA ids_dec var_comp_3 .

    SEMICOLON       reduce using rule 30 (var_comp_2 -> COMMA ids_dec var_comp_3 .)


state 44

    (32) var_comp_3 -> var_comp_2 .

    SEMICOLON       reduce using rule 32 (var_comp_3 -> var_comp_2 .)


state 45

    (38) ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS . OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (39) ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS .

    OPEN_BRACKETS   shift and go to state 53
    COMMA           reduce using rule 39 (ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS .)
    SEMICOLON       reduce using rule 39 (ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS .)


state 46

    (4) main -> MAIN OPEN_PAREN CLOSE_PAREN fill_main_quad block .

    $end            reduce using rule 4 (main -> MAIN OPEN_PAREN CLOSE_PAREN fill_main_quad block .)


state 47

    (20) block -> OPEN_BRACES . statements CLOSE_BRACES
    (44) statements -> . assignment SEMICOLON statements
    (45) statements -> . read SEMICOLON statements
    (46) statements -> . write SEMICOLON statements
    (47) statements -> . condition statements
    (48) statements -> . return SEMICOLON statements
    (49) statements -> . func_call SEMICOLON statements
    (50) statements -> . empty
    (51) assignment -> . ids ASSIGN expressions
    (52) read -> . READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN
    (56) write -> . WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (57) write -> . WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN
    (64) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (65) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
    (66) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
    (67) condition -> . FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (77) return -> . RETURN OPEN_PAREN expressions CLOSE_PAREN return_end
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global
    (131) empty -> .
    (41) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (42) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (43) ids -> . ID

    READ            shift and go to state 63
    WRITE           shift and go to state 64
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    RETURN          shift and go to state 68
    ID              shift and go to state 69
    CLOSE_BRACES    reduce using rule 131 (empty -> .)

    statements                     shift and go to state 54
    assignment                     shift and go to state 55
    read                           shift and go to state 56
    write                          shift and go to state 57
    condition                      shift and go to state 58
    return                         shift and go to state 59
    func_call                      shift and go to state 60
    empty                          shift and go to state 61
    ids                            shift and go to state 62

state 48

    (7) funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params . CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs

    CLOSE_PAREN     shift and go to state 70


state 49

    (14) funcs_params -> var_type . variable_params funcs_params_comp
    (18) variable_params -> . ID
    (19) variable_params -> . ID dim

    ID              shift and go to state 72

    variable_params                shift and go to state 71

state 50

    (15) funcs_params -> empty .

    CLOSE_PAREN     reduce using rule 15 (funcs_params -> empty .)


state 51

    (37) var_module_trans -> SEMICOLON var_type MODULE . funcs_comp
    (12) funcs_comp -> . ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs

    ID              shift and go to state 74

    funcs_comp                     shift and go to state 73

state 52

    (33) var_comp_recursive -> var_type ids_dec . var_comp_2 var_comp_final
    (34) var_comp_recursive -> var_type ids_dec . var_comp_2 SEMICOLON var_comp_recursive
    (30) var_comp_2 -> . COMMA ids_dec var_comp_3
    (31) var_comp_2 -> . empty
    (131) empty -> .

    COMMA           shift and go to state 29
    SEMICOLON       reduce using rule 131 (empty -> .)

    var_comp_2                     shift and go to state 75
    empty                          shift and go to state 30

state 53

    (38) ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS . CT_INT CLOSE_BRACKETS

    CT_INT          shift and go to state 76


state 54

    (20) block -> OPEN_BRACES statements . CLOSE_BRACES

    CLOSE_BRACES    shift and go to state 77


state 55

    (44) statements -> assignment . SEMICOLON statements

    SEMICOLON       shift and go to state 78


state 56

    (45) statements -> read . SEMICOLON statements

    SEMICOLON       shift and go to state 79


state 57

    (46) statements -> write . SEMICOLON statements

    SEMICOLON       shift and go to state 80


state 58

    (47) statements -> condition . statements
    (44) statements -> . assignment SEMICOLON statements
    (45) statements -> . read SEMICOLON statements
    (46) statements -> . write SEMICOLON statements
    (47) statements -> . condition statements
    (48) statements -> . return SEMICOLON statements
    (49) statements -> . func_call SEMICOLON statements
    (50) statements -> . empty
    (51) assignment -> . ids ASSIGN expressions
    (52) read -> . READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN
    (56) write -> . WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (57) write -> . WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN
    (64) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (65) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
    (66) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
    (67) condition -> . FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (77) return -> . RETURN OPEN_PAREN expressions CLOSE_PAREN return_end
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global
    (131) empty -> .
    (41) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (42) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (43) ids -> . ID

    READ            shift and go to state 63
    WRITE           shift and go to state 64
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    RETURN          shift and go to state 68
    ID              shift and go to state 69
    CLOSE_BRACES    reduce using rule 131 (empty -> .)

    condition                      shift and go to state 58
    statements                     shift and go to state 81
    assignment                     shift and go to state 55
    read                           shift and go to state 56
    write                          shift and go to state 57
    return                         shift and go to state 59
    func_call                      shift and go to state 60
    empty                          shift and go to state 61
    ids                            shift and go to state 62

state 59

    (48) statements -> return . SEMICOLON statements

    SEMICOLON       shift and go to state 82


state 60

    (49) statements -> func_call . SEMICOLON statements

    SEMICOLON       shift and go to state 83


state 61

    (50) statements -> empty .

    CLOSE_BRACES    reduce using rule 50 (statements -> empty .)


state 62

    (51) assignment -> ids . ASSIGN expressions

    ASSIGN          shift and go to state 84


state 63

    (52) read -> READ . OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 85


state 64

    (56) write -> WRITE . OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (57) write -> WRITE . OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 86


state 65

    (64) condition -> IF . OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (65) condition -> IF . OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if

    OPEN_PAREN      shift and go to state 87


state 66

    (66) condition -> WHILE . while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
    (70) while_jump -> .

    OPEN_PAREN      reduce using rule 70 (while_jump -> .)

    while_jump                     shift and go to state 88

state 67

    (67) condition -> FOR . ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (41) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (42) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (43) ids -> . ID

    ID              shift and go to state 90

    ids                            shift and go to state 89

state 68

    (77) return -> RETURN . OPEN_PAREN expressions CLOSE_PAREN return_end

    OPEN_PAREN      shift and go to state 91


state 69

    (79) func_call -> ID . verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global
    (41) ids -> ID . OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (42) ids -> ID . OPEN_BRACKETS exp CLOSE_BRACKETS
    (43) ids -> ID .
    (82) verify_function_exists -> .

    OPEN_BRACKETS   shift and go to state 93
    ASSIGN          reduce using rule 43 (ids -> ID .)
    OPEN_PAREN      reduce using rule 82 (verify_function_exists -> .)

    verify_function_exists         shift and go to state 92

state 70

    (7) funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN . add_parameter_amount vars count_local_vars block end_funcs funcs
    (13) add_parameter_amount -> .

    VARS            reduce using rule 13 (add_parameter_amount -> .)
    OPEN_BRACES     reduce using rule 13 (add_parameter_amount -> .)

    add_parameter_amount           shift and go to state 94

state 71

    (14) funcs_params -> var_type variable_params . funcs_params_comp
    (16) funcs_params_comp -> . COMMA var_type variable_params funcs_params_comp
    (17) funcs_params_comp -> . empty
    (131) empty -> .

    COMMA           shift and go to state 96
    CLOSE_PAREN     reduce using rule 131 (empty -> .)

    funcs_params_comp              shift and go to state 95
    empty                          shift and go to state 97

state 72

    (18) variable_params -> ID .
    (19) variable_params -> ID . dim
    (130) dim -> . OPEN_BRACKETS exp CLOSE_BRACKETS

    COMMA           reduce using rule 18 (variable_params -> ID .)
    CLOSE_PAREN     reduce using rule 18 (variable_params -> ID .)
    OPEN_BRACKETS   shift and go to state 99

    dim                            shift and go to state 98

state 73

    (37) var_module_trans -> SEMICOLON var_type MODULE funcs_comp .

    VOID            reduce using rule 37 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)
    INT             reduce using rule 37 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)
    FLOAT           reduce using rule 37 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)
    CHAR            reduce using rule 37 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)
    MAIN            reduce using rule 37 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)
    OPEN_BRACES     reduce using rule 37 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)


state 74

    (12) funcs_comp -> ID . add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs
    (11) add_module -> .

    OPEN_PAREN      reduce using rule 11 (add_module -> .)

    add_module                     shift and go to state 100

state 75

    (33) var_comp_recursive -> var_type ids_dec var_comp_2 . var_comp_final
    (34) var_comp_recursive -> var_type ids_dec var_comp_2 . SEMICOLON var_comp_recursive
    (35) var_comp_final -> . SEMICOLON
    (36) var_comp_final -> . var_module_trans
    (37) var_module_trans -> . SEMICOLON var_type MODULE funcs_comp

    SEMICOLON       shift and go to state 102

    var_comp_final                 shift and go to state 101
    var_module_trans               shift and go to state 36

state 76

    (38) ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT . CLOSE_BRACKETS

    CLOSE_BRACKETS  shift and go to state 103


state 77

    (20) block -> OPEN_BRACES statements CLOSE_BRACES .

    $end            reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    VOID            reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    INT             reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    FLOAT           reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    CHAR            reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    MAIN            reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    OPEN_BRACES     reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    ELSE            reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    READ            reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    WRITE           reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    IF              reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    WHILE           reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    FOR             reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    RETURN          reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    ID              reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    CLOSE_BRACES    reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)


state 78

    (44) statements -> assignment SEMICOLON . statements
    (44) statements -> . assignment SEMICOLON statements
    (45) statements -> . read SEMICOLON statements
    (46) statements -> . write SEMICOLON statements
    (47) statements -> . condition statements
    (48) statements -> . return SEMICOLON statements
    (49) statements -> . func_call SEMICOLON statements
    (50) statements -> . empty
    (51) assignment -> . ids ASSIGN expressions
    (52) read -> . READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN
    (56) write -> . WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (57) write -> . WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN
    (64) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (65) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
    (66) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
    (67) condition -> . FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (77) return -> . RETURN OPEN_PAREN expressions CLOSE_PAREN return_end
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global
    (131) empty -> .
    (41) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (42) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (43) ids -> . ID

    READ            shift and go to state 63
    WRITE           shift and go to state 64
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    RETURN          shift and go to state 68
    ID              shift and go to state 69
    CLOSE_BRACES    reduce using rule 131 (empty -> .)

    assignment                     shift and go to state 55
    statements                     shift and go to state 104
    read                           shift and go to state 56
    write                          shift and go to state 57
    condition                      shift and go to state 58
    return                         shift and go to state 59
    func_call                      shift and go to state 60
    empty                          shift and go to state 61
    ids                            shift and go to state 62

state 79

    (45) statements -> read SEMICOLON . statements
    (44) statements -> . assignment SEMICOLON statements
    (45) statements -> . read SEMICOLON statements
    (46) statements -> . write SEMICOLON statements
    (47) statements -> . condition statements
    (48) statements -> . return SEMICOLON statements
    (49) statements -> . func_call SEMICOLON statements
    (50) statements -> . empty
    (51) assignment -> . ids ASSIGN expressions
    (52) read -> . READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN
    (56) write -> . WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (57) write -> . WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN
    (64) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (65) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
    (66) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
    (67) condition -> . FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (77) return -> . RETURN OPEN_PAREN expressions CLOSE_PAREN return_end
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global
    (131) empty -> .
    (41) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (42) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (43) ids -> . ID

    READ            shift and go to state 63
    WRITE           shift and go to state 64
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    RETURN          shift and go to state 68
    ID              shift and go to state 69
    CLOSE_BRACES    reduce using rule 131 (empty -> .)

    read                           shift and go to state 56
    statements                     shift and go to state 105
    assignment                     shift and go to state 55
    write                          shift and go to state 57
    condition                      shift and go to state 58
    return                         shift and go to state 59
    func_call                      shift and go to state 60
    empty                          shift and go to state 61
    ids                            shift and go to state 62

state 80

    (46) statements -> write SEMICOLON . statements
    (44) statements -> . assignment SEMICOLON statements
    (45) statements -> . read SEMICOLON statements
    (46) statements -> . write SEMICOLON statements
    (47) statements -> . condition statements
    (48) statements -> . return SEMICOLON statements
    (49) statements -> . func_call SEMICOLON statements
    (50) statements -> . empty
    (51) assignment -> . ids ASSIGN expressions
    (52) read -> . READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN
    (56) write -> . WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (57) write -> . WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN
    (64) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (65) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
    (66) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
    (67) condition -> . FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (77) return -> . RETURN OPEN_PAREN expressions CLOSE_PAREN return_end
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global
    (131) empty -> .
    (41) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (42) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (43) ids -> . ID

    READ            shift and go to state 63
    WRITE           shift and go to state 64
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    RETURN          shift and go to state 68
    ID              shift and go to state 69
    CLOSE_BRACES    reduce using rule 131 (empty -> .)

    write                          shift and go to state 57
    statements                     shift and go to state 106
    assignment                     shift and go to state 55
    read                           shift and go to state 56
    condition                      shift and go to state 58
    return                         shift and go to state 59
    func_call                      shift and go to state 60
    empty                          shift and go to state 61
    ids                            shift and go to state 62

state 81

    (47) statements -> condition statements .

    CLOSE_BRACES    reduce using rule 47 (statements -> condition statements .)


state 82

    (48) statements -> return SEMICOLON . statements
    (44) statements -> . assignment SEMICOLON statements
    (45) statements -> . read SEMICOLON statements
    (46) statements -> . write SEMICOLON statements
    (47) statements -> . condition statements
    (48) statements -> . return SEMICOLON statements
    (49) statements -> . func_call SEMICOLON statements
    (50) statements -> . empty
    (51) assignment -> . ids ASSIGN expressions
    (52) read -> . READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN
    (56) write -> . WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (57) write -> . WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN
    (64) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (65) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
    (66) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
    (67) condition -> . FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (77) return -> . RETURN OPEN_PAREN expressions CLOSE_PAREN return_end
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global
    (131) empty -> .
    (41) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (42) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (43) ids -> . ID

    READ            shift and go to state 63
    WRITE           shift and go to state 64
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    RETURN          shift and go to state 68
    ID              shift and go to state 69
    CLOSE_BRACES    reduce using rule 131 (empty -> .)

    return                         shift and go to state 59
    statements                     shift and go to state 107
    assignment                     shift and go to state 55
    read                           shift and go to state 56
    write                          shift and go to state 57
    condition                      shift and go to state 58
    func_call                      shift and go to state 60
    empty                          shift and go to state 61
    ids                            shift and go to state 62

state 83

    (49) statements -> func_call SEMICOLON . statements
    (44) statements -> . assignment SEMICOLON statements
    (45) statements -> . read SEMICOLON statements
    (46) statements -> . write SEMICOLON statements
    (47) statements -> . condition statements
    (48) statements -> . return SEMICOLON statements
    (49) statements -> . func_call SEMICOLON statements
    (50) statements -> . empty
    (51) assignment -> . ids ASSIGN expressions
    (52) read -> . READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN
    (56) write -> . WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (57) write -> . WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN
    (64) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (65) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
    (66) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
    (67) condition -> . FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (77) return -> . RETURN OPEN_PAREN expressions CLOSE_PAREN return_end
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global
    (131) empty -> .
    (41) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (42) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (43) ids -> . ID

    READ            shift and go to state 63
    WRITE           shift and go to state 64
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    RETURN          shift and go to state 68
    ID              shift and go to state 69
    CLOSE_BRACES    reduce using rule 131 (empty -> .)

    func_call                      shift and go to state 60
    statements                     shift and go to state 108
    assignment                     shift and go to state 55
    read                           shift and go to state 56
    write                          shift and go to state 57
    condition                      shift and go to state 58
    return                         shift and go to state 59
    empty                          shift and go to state 61
    ids                            shift and go to state 62

state 84

    (51) assignment -> ids ASSIGN . expressions
    (89) expressions -> . expressions_comp
    (90) expressions_comp -> . expression_comp_2
    (91) expressions_comp -> . expression_comp_2 OR expressions_comp
    (92) expression_comp_2 -> . expression_comp_3
    (93) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (94) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (95) expression_comp_3 -> . exp
    (103) exp -> . term g_quad_exp_as_alone
    (104) exp -> . term g_quad_exp_as exp_comp
    (109) term -> . factor g_quad_exp_md_alone
    (110) term -> . factor g_quad_exp_md term_comp
    (116) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (117) factor -> . variable
    (118) factor -> . func_call
    (119) factor -> . CT_INT add_ct_int
    (120) factor -> . CT_FLOAT add_ct_float
    (121) factor -> . CT_CHAR add_ct_char
    (127) variable -> . ID add_id
    (128) variable -> . ID dim
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global

    OPEN_PAREN      shift and go to state 116
    CT_INT          shift and go to state 119
    CT_FLOAT        shift and go to state 120
    CT_CHAR         shift and go to state 121
    ID              shift and go to state 122

    expressions                    shift and go to state 109
    expressions_comp               shift and go to state 110
    expression_comp_2              shift and go to state 111
    expression_comp_3              shift and go to state 112
    exp                            shift and go to state 113
    term                           shift and go to state 114
    factor                         shift and go to state 115
    variable                       shift and go to state 117
    func_call                      shift and go to state 118

state 85

    (52) read -> READ OPEN_PAREN . ids g_quad_read read_comp CLOSE_PAREN
    (41) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (42) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (43) ids -> . ID

    ID              shift and go to state 90

    ids                            shift and go to state 123

state 86

    (56) write -> WRITE OPEN_PAREN . CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (57) write -> WRITE OPEN_PAREN . expressions g_quad_write write_comp CLOSE_PAREN
    (89) expressions -> . expressions_comp
    (90) expressions_comp -> . expression_comp_2
    (91) expressions_comp -> . expression_comp_2 OR expressions_comp
    (92) expression_comp_2 -> . expression_comp_3
    (93) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (94) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (95) expression_comp_3 -> . exp
    (103) exp -> . term g_quad_exp_as_alone
    (104) exp -> . term g_quad_exp_as exp_comp
    (109) term -> . factor g_quad_exp_md_alone
    (110) term -> . factor g_quad_exp_md term_comp
    (116) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (117) factor -> . variable
    (118) factor -> . func_call
    (119) factor -> . CT_INT add_ct_int
    (120) factor -> . CT_FLOAT add_ct_float
    (121) factor -> . CT_CHAR add_ct_char
    (127) variable -> . ID add_id
    (128) variable -> . ID dim
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global

    CT_STRING       shift and go to state 124
    OPEN_PAREN      shift and go to state 116
    CT_INT          shift and go to state 119
    CT_FLOAT        shift and go to state 120
    CT_CHAR         shift and go to state 121
    ID              shift and go to state 122

    expressions                    shift and go to state 125
    expressions_comp               shift and go to state 110
    expression_comp_2              shift and go to state 111
    expression_comp_3              shift and go to state 112
    exp                            shift and go to state 113
    term                           shift and go to state 114
    factor                         shift and go to state 115
    variable                       shift and go to state 117
    func_call                      shift and go to state 118

state 87

    (64) condition -> IF OPEN_PAREN . expressions CLOSE_PAREN g_if_quad THEN block end_if
    (65) condition -> IF OPEN_PAREN . expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
    (89) expressions -> . expressions_comp
    (90) expressions_comp -> . expression_comp_2
    (91) expressions_comp -> . expression_comp_2 OR expressions_comp
    (92) expression_comp_2 -> . expression_comp_3
    (93) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (94) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (95) expression_comp_3 -> . exp
    (103) exp -> . term g_quad_exp_as_alone
    (104) exp -> . term g_quad_exp_as exp_comp
    (109) term -> . factor g_quad_exp_md_alone
    (110) term -> . factor g_quad_exp_md term_comp
    (116) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (117) factor -> . variable
    (118) factor -> . func_call
    (119) factor -> . CT_INT add_ct_int
    (120) factor -> . CT_FLOAT add_ct_float
    (121) factor -> . CT_CHAR add_ct_char
    (127) variable -> . ID add_id
    (128) variable -> . ID dim
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global

    OPEN_PAREN      shift and go to state 116
    CT_INT          shift and go to state 119
    CT_FLOAT        shift and go to state 120
    CT_CHAR         shift and go to state 121
    ID              shift and go to state 122

    expressions                    shift and go to state 126
    expressions_comp               shift and go to state 110
    expression_comp_2              shift and go to state 111
    expression_comp_3              shift and go to state 112
    exp                            shift and go to state 113
    term                           shift and go to state 114
    factor                         shift and go to state 115
    variable                       shift and go to state 117
    func_call                      shift and go to state 118

state 88

    (66) condition -> WHILE while_jump . OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while

    OPEN_PAREN      shift and go to state 127


state 89

    (67) condition -> FOR ids . validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (73) validate_for -> .

    ASSIGN          reduce using rule 73 (validate_for -> .)

    validate_for                   shift and go to state 128

state 90

    (41) ids -> ID . OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (42) ids -> ID . OPEN_BRACKETS exp CLOSE_BRACKETS
    (43) ids -> ID .

    OPEN_BRACKETS   shift and go to state 93
    ASSIGN          reduce using rule 43 (ids -> ID .)
    COMMA           reduce using rule 43 (ids -> ID .)
    CLOSE_PAREN     reduce using rule 43 (ids -> ID .)


state 91

    (77) return -> RETURN OPEN_PAREN . expressions CLOSE_PAREN return_end
    (89) expressions -> . expressions_comp
    (90) expressions_comp -> . expression_comp_2
    (91) expressions_comp -> . expression_comp_2 OR expressions_comp
    (92) expression_comp_2 -> . expression_comp_3
    (93) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (94) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (95) expression_comp_3 -> . exp
    (103) exp -> . term g_quad_exp_as_alone
    (104) exp -> . term g_quad_exp_as exp_comp
    (109) term -> . factor g_quad_exp_md_alone
    (110) term -> . factor g_quad_exp_md term_comp
    (116) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (117) factor -> . variable
    (118) factor -> . func_call
    (119) factor -> . CT_INT add_ct_int
    (120) factor -> . CT_FLOAT add_ct_float
    (121) factor -> . CT_CHAR add_ct_char
    (127) variable -> . ID add_id
    (128) variable -> . ID dim
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global

    OPEN_PAREN      shift and go to state 116
    CT_INT          shift and go to state 119
    CT_FLOAT        shift and go to state 120
    CT_CHAR         shift and go to state 121
    ID              shift and go to state 122

    expressions                    shift and go to state 129
    expressions_comp               shift and go to state 110
    expression_comp_2              shift and go to state 111
    expression_comp_3              shift and go to state 112
    exp                            shift and go to state 113
    term                           shift and go to state 114
    factor                         shift and go to state 115
    variable                       shift and go to state 117
    func_call                      shift and go to state 118

state 92

    (79) func_call -> ID verify_function_exists . OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global

    OPEN_PAREN      shift and go to state 130


state 93

    (41) ids -> ID OPEN_BRACKETS . exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (42) ids -> ID OPEN_BRACKETS . exp CLOSE_BRACKETS
    (103) exp -> . term g_quad_exp_as_alone
    (104) exp -> . term g_quad_exp_as exp_comp
    (109) term -> . factor g_quad_exp_md_alone
    (110) term -> . factor g_quad_exp_md term_comp
    (116) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (117) factor -> . variable
    (118) factor -> . func_call
    (119) factor -> . CT_INT add_ct_int
    (120) factor -> . CT_FLOAT add_ct_float
    (121) factor -> . CT_CHAR add_ct_char
    (127) variable -> . ID add_id
    (128) variable -> . ID dim
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global

    OPEN_PAREN      shift and go to state 116
    CT_INT          shift and go to state 119
    CT_FLOAT        shift and go to state 120
    CT_CHAR         shift and go to state 121
    ID              shift and go to state 122

    exp                            shift and go to state 131
    term                           shift and go to state 114
    factor                         shift and go to state 115
    variable                       shift and go to state 117
    func_call                      shift and go to state 118

state 94

    (7) funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount . vars count_local_vars block end_funcs funcs
    (26) vars -> . VARS var_comp
    (27) vars -> . empty
    (131) empty -> .

    VARS            shift and go to state 8
    OPEN_BRACES     reduce using rule 131 (empty -> .)

    vars                           shift and go to state 132
    empty                          shift and go to state 9

state 95

    (14) funcs_params -> var_type variable_params funcs_params_comp .

    CLOSE_PAREN     reduce using rule 14 (funcs_params -> var_type variable_params funcs_params_comp .)


state 96

    (16) funcs_params_comp -> COMMA . var_type variable_params funcs_params_comp
    (23) var_type -> . INT
    (24) var_type -> . FLOAT
    (25) var_type -> . CHAR

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

    var_type                       shift and go to state 133

state 97

    (17) funcs_params_comp -> empty .

    CLOSE_PAREN     reduce using rule 17 (funcs_params_comp -> empty .)


state 98

    (19) variable_params -> ID dim .

    COMMA           reduce using rule 19 (variable_params -> ID dim .)
    CLOSE_PAREN     reduce using rule 19 (variable_params -> ID dim .)


state 99

    (130) dim -> OPEN_BRACKETS . exp CLOSE_BRACKETS
    (103) exp -> . term g_quad_exp_as_alone
    (104) exp -> . term g_quad_exp_as exp_comp
    (109) term -> . factor g_quad_exp_md_alone
    (110) term -> . factor g_quad_exp_md term_comp
    (116) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (117) factor -> . variable
    (118) factor -> . func_call
    (119) factor -> . CT_INT add_ct_int
    (120) factor -> . CT_FLOAT add_ct_float
    (121) factor -> . CT_CHAR add_ct_char
    (127) variable -> . ID add_id
    (128) variable -> . ID dim
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global

    OPEN_PAREN      shift and go to state 116
    CT_INT          shift and go to state 119
    CT_FLOAT        shift and go to state 120
    CT_CHAR         shift and go to state 121
    ID              shift and go to state 122

    exp                            shift and go to state 134
    term                           shift and go to state 114
    factor                         shift and go to state 115
    variable                       shift and go to state 117
    func_call                      shift and go to state 118

state 100

    (12) funcs_comp -> ID add_module . OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs

    OPEN_PAREN      shift and go to state 135


state 101

    (33) var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .

    VOID            reduce using rule 33 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)
    INT             reduce using rule 33 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)
    FLOAT           reduce using rule 33 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)
    CHAR            reduce using rule 33 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)
    MAIN            reduce using rule 33 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)
    OPEN_BRACES     reduce using rule 33 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)


state 102

    (34) var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON . var_comp_recursive
    (35) var_comp_final -> SEMICOLON .
    (37) var_module_trans -> SEMICOLON . var_type MODULE funcs_comp
    (33) var_comp_recursive -> . var_type ids_dec var_comp_2 var_comp_final
    (34) var_comp_recursive -> . var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive
    (23) var_type -> . INT
    (24) var_type -> . FLOAT
    (25) var_type -> . CHAR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
    VOID            reduce using rule 35 (var_comp_final -> SEMICOLON .)
    MAIN            reduce using rule 35 (var_comp_final -> SEMICOLON .)
    OPEN_BRACES     reduce using rule 35 (var_comp_final -> SEMICOLON .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

  ! INT             [ reduce using rule 35 (var_comp_final -> SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 35 (var_comp_final -> SEMICOLON .) ]
  ! CHAR            [ reduce using rule 35 (var_comp_final -> SEMICOLON .) ]

    var_type                       shift and go to state 41
    var_comp_recursive             shift and go to state 136

state 103

    (38) ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS .

    COMMA           reduce using rule 38 (ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS .)
    SEMICOLON       reduce using rule 38 (ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS .)


state 104

    (44) statements -> assignment SEMICOLON statements .

    CLOSE_BRACES    reduce using rule 44 (statements -> assignment SEMICOLON statements .)


state 105

    (45) statements -> read SEMICOLON statements .

    CLOSE_BRACES    reduce using rule 45 (statements -> read SEMICOLON statements .)


state 106

    (46) statements -> write SEMICOLON statements .

    CLOSE_BRACES    reduce using rule 46 (statements -> write SEMICOLON statements .)


state 107

    (48) statements -> return SEMICOLON statements .

    CLOSE_BRACES    reduce using rule 48 (statements -> return SEMICOLON statements .)


state 108

    (49) statements -> func_call SEMICOLON statements .

    CLOSE_BRACES    reduce using rule 49 (statements -> func_call SEMICOLON statements .)


state 109

    (51) assignment -> ids ASSIGN expressions .

    SEMICOLON       reduce using rule 51 (assignment -> ids ASSIGN expressions .)


state 110

    (89) expressions -> expressions_comp .

    SEMICOLON       reduce using rule 89 (expressions -> expressions_comp .)
    COMMA           reduce using rule 89 (expressions -> expressions_comp .)
    CLOSE_PAREN     reduce using rule 89 (expressions -> expressions_comp .)
    TO              reduce using rule 89 (expressions -> expressions_comp .)
    OPEN_PAREN      reduce using rule 89 (expressions -> expressions_comp .)
    CT_INT          reduce using rule 89 (expressions -> expressions_comp .)
    CT_FLOAT        reduce using rule 89 (expressions -> expressions_comp .)
    CT_CHAR         reduce using rule 89 (expressions -> expressions_comp .)
    ID              reduce using rule 89 (expressions -> expressions_comp .)
    DO              reduce using rule 89 (expressions -> expressions_comp .)


state 111

    (90) expressions_comp -> expression_comp_2 .
    (91) expressions_comp -> expression_comp_2 . OR expressions_comp

    SEMICOLON       reduce using rule 90 (expressions_comp -> expression_comp_2 .)
    COMMA           reduce using rule 90 (expressions_comp -> expression_comp_2 .)
    CLOSE_PAREN     reduce using rule 90 (expressions_comp -> expression_comp_2 .)
    TO              reduce using rule 90 (expressions_comp -> expression_comp_2 .)
    OPEN_PAREN      reduce using rule 90 (expressions_comp -> expression_comp_2 .)
    CT_INT          reduce using rule 90 (expressions_comp -> expression_comp_2 .)
    CT_FLOAT        reduce using rule 90 (expressions_comp -> expression_comp_2 .)
    CT_CHAR         reduce using rule 90 (expressions_comp -> expression_comp_2 .)
    ID              reduce using rule 90 (expressions_comp -> expression_comp_2 .)
    DO              reduce using rule 90 (expressions_comp -> expression_comp_2 .)
    OR              shift and go to state 137


state 112

    (92) expression_comp_2 -> expression_comp_3 .
    (93) expression_comp_2 -> expression_comp_3 . AND expression_comp_2

    OR              reduce using rule 92 (expression_comp_2 -> expression_comp_3 .)
    SEMICOLON       reduce using rule 92 (expression_comp_2 -> expression_comp_3 .)
    COMMA           reduce using rule 92 (expression_comp_2 -> expression_comp_3 .)
    CLOSE_PAREN     reduce using rule 92 (expression_comp_2 -> expression_comp_3 .)
    TO              reduce using rule 92 (expression_comp_2 -> expression_comp_3 .)
    OPEN_PAREN      reduce using rule 92 (expression_comp_2 -> expression_comp_3 .)
    CT_INT          reduce using rule 92 (expression_comp_2 -> expression_comp_3 .)
    CT_FLOAT        reduce using rule 92 (expression_comp_2 -> expression_comp_3 .)
    CT_CHAR         reduce using rule 92 (expression_comp_2 -> expression_comp_3 .)
    ID              reduce using rule 92 (expression_comp_2 -> expression_comp_3 .)
    DO              reduce using rule 92 (expression_comp_2 -> expression_comp_3 .)
    AND             shift and go to state 138


state 113

    (94) expression_comp_3 -> exp . expressions_op exp g_quad_logic
    (95) expression_comp_3 -> exp .
    (97) expressions_op -> . LESS_THAN add_op
    (98) expressions_op -> . LESS_THAN_EQUAL add_op
    (99) expressions_op -> . MORE_THAN add_op
    (100) expressions_op -> . MORE_THAN_EQUAL add_op
    (101) expressions_op -> . EQUALS add_op
    (102) expressions_op -> . NOT_EQUALS add_op

    AND             reduce using rule 95 (expression_comp_3 -> exp .)
    OR              reduce using rule 95 (expression_comp_3 -> exp .)
    SEMICOLON       reduce using rule 95 (expression_comp_3 -> exp .)
    COMMA           reduce using rule 95 (expression_comp_3 -> exp .)
    CLOSE_PAREN     reduce using rule 95 (expression_comp_3 -> exp .)
    TO              reduce using rule 95 (expression_comp_3 -> exp .)
    OPEN_PAREN      reduce using rule 95 (expression_comp_3 -> exp .)
    CT_INT          reduce using rule 95 (expression_comp_3 -> exp .)
    CT_FLOAT        reduce using rule 95 (expression_comp_3 -> exp .)
    CT_CHAR         reduce using rule 95 (expression_comp_3 -> exp .)
    ID              reduce using rule 95 (expression_comp_3 -> exp .)
    DO              reduce using rule 95 (expression_comp_3 -> exp .)
    LESS_THAN       shift and go to state 140
    LESS_THAN_EQUAL shift and go to state 141
    MORE_THAN       shift and go to state 142
    MORE_THAN_EQUAL shift and go to state 143
    EQUALS          shift and go to state 144
    NOT_EQUALS      shift and go to state 145

    expressions_op                 shift and go to state 139

state 114

    (103) exp -> term . g_quad_exp_as_alone
    (104) exp -> term . g_quad_exp_as exp_comp
    (106) g_quad_exp_as_alone -> .
    (105) g_quad_exp_as -> .

    LESS_THAN       reduce using rule 106 (g_quad_exp_as_alone -> .)
    LESS_THAN_EQUAL reduce using rule 106 (g_quad_exp_as_alone -> .)
    MORE_THAN       reduce using rule 106 (g_quad_exp_as_alone -> .)
    MORE_THAN_EQUAL reduce using rule 106 (g_quad_exp_as_alone -> .)
    EQUALS          reduce using rule 106 (g_quad_exp_as_alone -> .)
    NOT_EQUALS      reduce using rule 106 (g_quad_exp_as_alone -> .)
    AND             reduce using rule 106 (g_quad_exp_as_alone -> .)
    OR              reduce using rule 106 (g_quad_exp_as_alone -> .)
    SEMICOLON       reduce using rule 106 (g_quad_exp_as_alone -> .)
    COMMA           reduce using rule 106 (g_quad_exp_as_alone -> .)
    CLOSE_PAREN     reduce using rule 106 (g_quad_exp_as_alone -> .)
    CLOSE_BRACKETS  reduce using rule 106 (g_quad_exp_as_alone -> .)
    TO              reduce using rule 106 (g_quad_exp_as_alone -> .)
    OPEN_PAREN      reduce using rule 106 (g_quad_exp_as_alone -> .)
    CT_INT          reduce using rule 106 (g_quad_exp_as_alone -> .)
    CT_FLOAT        reduce using rule 106 (g_quad_exp_as_alone -> .)
    CT_CHAR         reduce using rule 106 (g_quad_exp_as_alone -> .)
    ID              reduce using rule 106 (g_quad_exp_as_alone -> .)
    DO              reduce using rule 106 (g_quad_exp_as_alone -> .)
    PLUS            reduce using rule 105 (g_quad_exp_as -> .)
    MINUS           reduce using rule 105 (g_quad_exp_as -> .)

    g_quad_exp_as_alone            shift and go to state 146
    g_quad_exp_as                  shift and go to state 147

state 115

    (109) term -> factor . g_quad_exp_md_alone
    (110) term -> factor . g_quad_exp_md term_comp
    (112) g_quad_exp_md_alone -> .
    (111) g_quad_exp_md -> .

    PLUS            reduce using rule 112 (g_quad_exp_md_alone -> .)
    MINUS           reduce using rule 112 (g_quad_exp_md_alone -> .)
    LESS_THAN       reduce using rule 112 (g_quad_exp_md_alone -> .)
    LESS_THAN_EQUAL reduce using rule 112 (g_quad_exp_md_alone -> .)
    MORE_THAN       reduce using rule 112 (g_quad_exp_md_alone -> .)
    MORE_THAN_EQUAL reduce using rule 112 (g_quad_exp_md_alone -> .)
    EQUALS          reduce using rule 112 (g_quad_exp_md_alone -> .)
    NOT_EQUALS      reduce using rule 112 (g_quad_exp_md_alone -> .)
    AND             reduce using rule 112 (g_quad_exp_md_alone -> .)
    OR              reduce using rule 112 (g_quad_exp_md_alone -> .)
    SEMICOLON       reduce using rule 112 (g_quad_exp_md_alone -> .)
    COMMA           reduce using rule 112 (g_quad_exp_md_alone -> .)
    CLOSE_PAREN     reduce using rule 112 (g_quad_exp_md_alone -> .)
    CLOSE_BRACKETS  reduce using rule 112 (g_quad_exp_md_alone -> .)
    TO              reduce using rule 112 (g_quad_exp_md_alone -> .)
    OPEN_PAREN      reduce using rule 112 (g_quad_exp_md_alone -> .)
    CT_INT          reduce using rule 112 (g_quad_exp_md_alone -> .)
    CT_FLOAT        reduce using rule 112 (g_quad_exp_md_alone -> .)
    CT_CHAR         reduce using rule 112 (g_quad_exp_md_alone -> .)
    ID              reduce using rule 112 (g_quad_exp_md_alone -> .)
    DO              reduce using rule 112 (g_quad_exp_md_alone -> .)
    MULTIPLIES      reduce using rule 111 (g_quad_exp_md -> .)
    DIVIDE          reduce using rule 111 (g_quad_exp_md -> .)

    g_quad_exp_md_alone            shift and go to state 148
    g_quad_exp_md                  shift and go to state 149

state 116

    (116) factor -> OPEN_PAREN . add_fake expressions CLOSE_PAREN rem_fake
    (122) add_fake -> .

    OPEN_PAREN      reduce using rule 122 (add_fake -> .)
    CT_INT          reduce using rule 122 (add_fake -> .)
    CT_FLOAT        reduce using rule 122 (add_fake -> .)
    CT_CHAR         reduce using rule 122 (add_fake -> .)
    ID              reduce using rule 122 (add_fake -> .)

    add_fake                       shift and go to state 150

state 117

    (117) factor -> variable .

    MULTIPLIES      reduce using rule 117 (factor -> variable .)
    DIVIDE          reduce using rule 117 (factor -> variable .)
    PLUS            reduce using rule 117 (factor -> variable .)
    MINUS           reduce using rule 117 (factor -> variable .)
    LESS_THAN       reduce using rule 117 (factor -> variable .)
    LESS_THAN_EQUAL reduce using rule 117 (factor -> variable .)
    MORE_THAN       reduce using rule 117 (factor -> variable .)
    MORE_THAN_EQUAL reduce using rule 117 (factor -> variable .)
    EQUALS          reduce using rule 117 (factor -> variable .)
    NOT_EQUALS      reduce using rule 117 (factor -> variable .)
    AND             reduce using rule 117 (factor -> variable .)
    OR              reduce using rule 117 (factor -> variable .)
    SEMICOLON       reduce using rule 117 (factor -> variable .)
    COMMA           reduce using rule 117 (factor -> variable .)
    CLOSE_PAREN     reduce using rule 117 (factor -> variable .)
    CLOSE_BRACKETS  reduce using rule 117 (factor -> variable .)
    TO              reduce using rule 117 (factor -> variable .)
    OPEN_PAREN      reduce using rule 117 (factor -> variable .)
    CT_INT          reduce using rule 117 (factor -> variable .)
    CT_FLOAT        reduce using rule 117 (factor -> variable .)
    CT_CHAR         reduce using rule 117 (factor -> variable .)
    ID              reduce using rule 117 (factor -> variable .)
    DO              reduce using rule 117 (factor -> variable .)


state 118

    (118) factor -> func_call .

    MULTIPLIES      reduce using rule 118 (factor -> func_call .)
    DIVIDE          reduce using rule 118 (factor -> func_call .)
    PLUS            reduce using rule 118 (factor -> func_call .)
    MINUS           reduce using rule 118 (factor -> func_call .)
    LESS_THAN       reduce using rule 118 (factor -> func_call .)
    LESS_THAN_EQUAL reduce using rule 118 (factor -> func_call .)
    MORE_THAN       reduce using rule 118 (factor -> func_call .)
    MORE_THAN_EQUAL reduce using rule 118 (factor -> func_call .)
    EQUALS          reduce using rule 118 (factor -> func_call .)
    NOT_EQUALS      reduce using rule 118 (factor -> func_call .)
    AND             reduce using rule 118 (factor -> func_call .)
    OR              reduce using rule 118 (factor -> func_call .)
    SEMICOLON       reduce using rule 118 (factor -> func_call .)
    COMMA           reduce using rule 118 (factor -> func_call .)
    CLOSE_PAREN     reduce using rule 118 (factor -> func_call .)
    CLOSE_BRACKETS  reduce using rule 118 (factor -> func_call .)
    TO              reduce using rule 118 (factor -> func_call .)
    OPEN_PAREN      reduce using rule 118 (factor -> func_call .)
    CT_INT          reduce using rule 118 (factor -> func_call .)
    CT_FLOAT        reduce using rule 118 (factor -> func_call .)
    CT_CHAR         reduce using rule 118 (factor -> func_call .)
    ID              reduce using rule 118 (factor -> func_call .)
    DO              reduce using rule 118 (factor -> func_call .)


state 119

    (119) factor -> CT_INT . add_ct_int
    (124) add_ct_int -> .

    MULTIPLIES      reduce using rule 124 (add_ct_int -> .)
    DIVIDE          reduce using rule 124 (add_ct_int -> .)
    PLUS            reduce using rule 124 (add_ct_int -> .)
    MINUS           reduce using rule 124 (add_ct_int -> .)
    LESS_THAN       reduce using rule 124 (add_ct_int -> .)
    LESS_THAN_EQUAL reduce using rule 124 (add_ct_int -> .)
    MORE_THAN       reduce using rule 124 (add_ct_int -> .)
    MORE_THAN_EQUAL reduce using rule 124 (add_ct_int -> .)
    EQUALS          reduce using rule 124 (add_ct_int -> .)
    NOT_EQUALS      reduce using rule 124 (add_ct_int -> .)
    AND             reduce using rule 124 (add_ct_int -> .)
    OR              reduce using rule 124 (add_ct_int -> .)
    SEMICOLON       reduce using rule 124 (add_ct_int -> .)
    COMMA           reduce using rule 124 (add_ct_int -> .)
    CLOSE_PAREN     reduce using rule 124 (add_ct_int -> .)
    CLOSE_BRACKETS  reduce using rule 124 (add_ct_int -> .)
    TO              reduce using rule 124 (add_ct_int -> .)
    OPEN_PAREN      reduce using rule 124 (add_ct_int -> .)
    CT_INT          reduce using rule 124 (add_ct_int -> .)
    CT_FLOAT        reduce using rule 124 (add_ct_int -> .)
    CT_CHAR         reduce using rule 124 (add_ct_int -> .)
    ID              reduce using rule 124 (add_ct_int -> .)
    DO              reduce using rule 124 (add_ct_int -> .)

    add_ct_int                     shift and go to state 151

state 120

    (120) factor -> CT_FLOAT . add_ct_float
    (125) add_ct_float -> .

    MULTIPLIES      reduce using rule 125 (add_ct_float -> .)
    DIVIDE          reduce using rule 125 (add_ct_float -> .)
    PLUS            reduce using rule 125 (add_ct_float -> .)
    MINUS           reduce using rule 125 (add_ct_float -> .)
    LESS_THAN       reduce using rule 125 (add_ct_float -> .)
    LESS_THAN_EQUAL reduce using rule 125 (add_ct_float -> .)
    MORE_THAN       reduce using rule 125 (add_ct_float -> .)
    MORE_THAN_EQUAL reduce using rule 125 (add_ct_float -> .)
    EQUALS          reduce using rule 125 (add_ct_float -> .)
    NOT_EQUALS      reduce using rule 125 (add_ct_float -> .)
    AND             reduce using rule 125 (add_ct_float -> .)
    OR              reduce using rule 125 (add_ct_float -> .)
    SEMICOLON       reduce using rule 125 (add_ct_float -> .)
    COMMA           reduce using rule 125 (add_ct_float -> .)
    CLOSE_PAREN     reduce using rule 125 (add_ct_float -> .)
    CLOSE_BRACKETS  reduce using rule 125 (add_ct_float -> .)
    TO              reduce using rule 125 (add_ct_float -> .)
    OPEN_PAREN      reduce using rule 125 (add_ct_float -> .)
    CT_INT          reduce using rule 125 (add_ct_float -> .)
    CT_FLOAT        reduce using rule 125 (add_ct_float -> .)
    CT_CHAR         reduce using rule 125 (add_ct_float -> .)
    ID              reduce using rule 125 (add_ct_float -> .)
    DO              reduce using rule 125 (add_ct_float -> .)

    add_ct_float                   shift and go to state 152

state 121

    (121) factor -> CT_CHAR . add_ct_char
    (126) add_ct_char -> .

    MULTIPLIES      reduce using rule 126 (add_ct_char -> .)
    DIVIDE          reduce using rule 126 (add_ct_char -> .)
    PLUS            reduce using rule 126 (add_ct_char -> .)
    MINUS           reduce using rule 126 (add_ct_char -> .)
    LESS_THAN       reduce using rule 126 (add_ct_char -> .)
    LESS_THAN_EQUAL reduce using rule 126 (add_ct_char -> .)
    MORE_THAN       reduce using rule 126 (add_ct_char -> .)
    MORE_THAN_EQUAL reduce using rule 126 (add_ct_char -> .)
    EQUALS          reduce using rule 126 (add_ct_char -> .)
    NOT_EQUALS      reduce using rule 126 (add_ct_char -> .)
    AND             reduce using rule 126 (add_ct_char -> .)
    OR              reduce using rule 126 (add_ct_char -> .)
    SEMICOLON       reduce using rule 126 (add_ct_char -> .)
    COMMA           reduce using rule 126 (add_ct_char -> .)
    CLOSE_PAREN     reduce using rule 126 (add_ct_char -> .)
    CLOSE_BRACKETS  reduce using rule 126 (add_ct_char -> .)
    TO              reduce using rule 126 (add_ct_char -> .)
    OPEN_PAREN      reduce using rule 126 (add_ct_char -> .)
    CT_INT          reduce using rule 126 (add_ct_char -> .)
    CT_FLOAT        reduce using rule 126 (add_ct_char -> .)
    CT_CHAR         reduce using rule 126 (add_ct_char -> .)
    ID              reduce using rule 126 (add_ct_char -> .)
    DO              reduce using rule 126 (add_ct_char -> .)

    add_ct_char                    shift and go to state 153

state 122

    (127) variable -> ID . add_id
    (128) variable -> ID . dim
    (79) func_call -> ID . verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global
    (129) add_id -> .
    (130) dim -> . OPEN_BRACKETS exp CLOSE_BRACKETS
    (82) verify_function_exists -> .

  ! reduce/reduce conflict for OPEN_PAREN resolved using rule 82 (verify_function_exists -> .)
    MULTIPLIES      reduce using rule 129 (add_id -> .)
    DIVIDE          reduce using rule 129 (add_id -> .)
    PLUS            reduce using rule 129 (add_id -> .)
    MINUS           reduce using rule 129 (add_id -> .)
    LESS_THAN       reduce using rule 129 (add_id -> .)
    LESS_THAN_EQUAL reduce using rule 129 (add_id -> .)
    MORE_THAN       reduce using rule 129 (add_id -> .)
    MORE_THAN_EQUAL reduce using rule 129 (add_id -> .)
    EQUALS          reduce using rule 129 (add_id -> .)
    NOT_EQUALS      reduce using rule 129 (add_id -> .)
    AND             reduce using rule 129 (add_id -> .)
    OR              reduce using rule 129 (add_id -> .)
    SEMICOLON       reduce using rule 129 (add_id -> .)
    COMMA           reduce using rule 129 (add_id -> .)
    CLOSE_PAREN     reduce using rule 129 (add_id -> .)
    CLOSE_BRACKETS  reduce using rule 129 (add_id -> .)
    TO              reduce using rule 129 (add_id -> .)
    CT_INT          reduce using rule 129 (add_id -> .)
    CT_FLOAT        reduce using rule 129 (add_id -> .)
    CT_CHAR         reduce using rule 129 (add_id -> .)
    ID              reduce using rule 129 (add_id -> .)
    DO              reduce using rule 129 (add_id -> .)
    OPEN_BRACKETS   shift and go to state 99
    OPEN_PAREN      reduce using rule 82 (verify_function_exists -> .)

  ! OPEN_PAREN      [ reduce using rule 129 (add_id -> .) ]

    add_id                         shift and go to state 154
    dim                            shift and go to state 155
    verify_function_exists         shift and go to state 92

state 123

    (52) read -> READ OPEN_PAREN ids . g_quad_read read_comp CLOSE_PAREN
    (55) g_quad_read -> .

    COMMA           reduce using rule 55 (g_quad_read -> .)
    CLOSE_PAREN     reduce using rule 55 (g_quad_read -> .)

    g_quad_read                    shift and go to state 156

state 124

    (56) write -> WRITE OPEN_PAREN CT_STRING . g_quad_write_str write_comp CLOSE_PAREN
    (61) g_quad_write_str -> .

    COMMA           reduce using rule 61 (g_quad_write_str -> .)
    CLOSE_PAREN     reduce using rule 61 (g_quad_write_str -> .)

    g_quad_write_str               shift and go to state 157

state 125

    (57) write -> WRITE OPEN_PAREN expressions . g_quad_write write_comp CLOSE_PAREN
    (62) g_quad_write -> .

    COMMA           reduce using rule 62 (g_quad_write -> .)
    CLOSE_PAREN     reduce using rule 62 (g_quad_write -> .)

    g_quad_write                   shift and go to state 158

state 126

    (64) condition -> IF OPEN_PAREN expressions . CLOSE_PAREN g_if_quad THEN block end_if
    (65) condition -> IF OPEN_PAREN expressions . CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if

    CLOSE_PAREN     shift and go to state 159


state 127

    (66) condition -> WHILE while_jump OPEN_PAREN . expressions CLOSE_PAREN g_while_quad DO block end_while
    (89) expressions -> . expressions_comp
    (90) expressions_comp -> . expression_comp_2
    (91) expressions_comp -> . expression_comp_2 OR expressions_comp
    (92) expression_comp_2 -> . expression_comp_3
    (93) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (94) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (95) expression_comp_3 -> . exp
    (103) exp -> . term g_quad_exp_as_alone
    (104) exp -> . term g_quad_exp_as exp_comp
    (109) term -> . factor g_quad_exp_md_alone
    (110) term -> . factor g_quad_exp_md term_comp
    (116) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (117) factor -> . variable
    (118) factor -> . func_call
    (119) factor -> . CT_INT add_ct_int
    (120) factor -> . CT_FLOAT add_ct_float
    (121) factor -> . CT_CHAR add_ct_char
    (127) variable -> . ID add_id
    (128) variable -> . ID dim
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global

    OPEN_PAREN      shift and go to state 116
    CT_INT          shift and go to state 119
    CT_FLOAT        shift and go to state 120
    CT_CHAR         shift and go to state 121
    ID              shift and go to state 122

    expressions                    shift and go to state 160
    expressions_comp               shift and go to state 110
    expression_comp_2              shift and go to state 111
    expression_comp_3              shift and go to state 112
    exp                            shift and go to state 113
    term                           shift and go to state 114
    factor                         shift and go to state 115
    variable                       shift and go to state 117
    func_call                      shift and go to state 118

state 128

    (67) condition -> FOR ids validate_for . ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for

    ASSIGN          shift and go to state 161


state 129

    (77) return -> RETURN OPEN_PAREN expressions . CLOSE_PAREN return_end

    CLOSE_PAREN     shift and go to state 162


state 130

    (79) func_call -> ID verify_function_exists OPEN_PAREN . era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global
    (83) era_activation -> .

    COMMA           reduce using rule 83 (era_activation -> .)
    OPEN_PAREN      reduce using rule 83 (era_activation -> .)
    CT_INT          reduce using rule 83 (era_activation -> .)
    CT_FLOAT        reduce using rule 83 (era_activation -> .)
    CT_CHAR         reduce using rule 83 (era_activation -> .)
    ID              reduce using rule 83 (era_activation -> .)
    CLOSE_PAREN     reduce using rule 83 (era_activation -> .)

    era_activation                 shift and go to state 163

state 131

    (41) ids -> ID OPEN_BRACKETS exp . CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (42) ids -> ID OPEN_BRACKETS exp . CLOSE_BRACKETS

    CLOSE_BRACKETS  shift and go to state 164


state 132

    (7) funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars . count_local_vars block end_funcs funcs
    (10) count_local_vars -> .

    OPEN_BRACES     reduce using rule 10 (count_local_vars -> .)

    count_local_vars               shift and go to state 165

state 133

    (16) funcs_params_comp -> COMMA var_type . variable_params funcs_params_comp
    (18) variable_params -> . ID
    (19) variable_params -> . ID dim

    ID              shift and go to state 72

    variable_params                shift and go to state 166

state 134

    (130) dim -> OPEN_BRACKETS exp . CLOSE_BRACKETS

    CLOSE_BRACKETS  shift and go to state 167


state 135

    (12) funcs_comp -> ID add_module OPEN_PAREN . funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs
    (14) funcs_params -> . var_type variable_params funcs_params_comp
    (15) funcs_params -> . empty
    (23) var_type -> . INT
    (24) var_type -> . FLOAT
    (25) var_type -> . CHAR
    (131) empty -> .

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    CLOSE_PAREN     reduce using rule 131 (empty -> .)

    funcs_params                   shift and go to state 168
    var_type                       shift and go to state 49
    empty                          shift and go to state 50

state 136

    (34) var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .

    VOID            reduce using rule 34 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    INT             reduce using rule 34 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    FLOAT           reduce using rule 34 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    CHAR            reduce using rule 34 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    MAIN            reduce using rule 34 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    OPEN_BRACES     reduce using rule 34 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)


state 137

    (91) expressions_comp -> expression_comp_2 OR . expressions_comp
    (90) expressions_comp -> . expression_comp_2
    (91) expressions_comp -> . expression_comp_2 OR expressions_comp
    (92) expression_comp_2 -> . expression_comp_3
    (93) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (94) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (95) expression_comp_3 -> . exp
    (103) exp -> . term g_quad_exp_as_alone
    (104) exp -> . term g_quad_exp_as exp_comp
    (109) term -> . factor g_quad_exp_md_alone
    (110) term -> . factor g_quad_exp_md term_comp
    (116) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (117) factor -> . variable
    (118) factor -> . func_call
    (119) factor -> . CT_INT add_ct_int
    (120) factor -> . CT_FLOAT add_ct_float
    (121) factor -> . CT_CHAR add_ct_char
    (127) variable -> . ID add_id
    (128) variable -> . ID dim
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global

    OPEN_PAREN      shift and go to state 116
    CT_INT          shift and go to state 119
    CT_FLOAT        shift and go to state 120
    CT_CHAR         shift and go to state 121
    ID              shift and go to state 122

    expression_comp_2              shift and go to state 111
    expressions_comp               shift and go to state 169
    expression_comp_3              shift and go to state 112
    exp                            shift and go to state 113
    term                           shift and go to state 114
    factor                         shift and go to state 115
    variable                       shift and go to state 117
    func_call                      shift and go to state 118

state 138

    (93) expression_comp_2 -> expression_comp_3 AND . expression_comp_2
    (92) expression_comp_2 -> . expression_comp_3
    (93) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (94) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (95) expression_comp_3 -> . exp
    (103) exp -> . term g_quad_exp_as_alone
    (104) exp -> . term g_quad_exp_as exp_comp
    (109) term -> . factor g_quad_exp_md_alone
    (110) term -> . factor g_quad_exp_md term_comp
    (116) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (117) factor -> . variable
    (118) factor -> . func_call
    (119) factor -> . CT_INT add_ct_int
    (120) factor -> . CT_FLOAT add_ct_float
    (121) factor -> . CT_CHAR add_ct_char
    (127) variable -> . ID add_id
    (128) variable -> . ID dim
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global

    OPEN_PAREN      shift and go to state 116
    CT_INT          shift and go to state 119
    CT_FLOAT        shift and go to state 120
    CT_CHAR         shift and go to state 121
    ID              shift and go to state 122

    expression_comp_3              shift and go to state 112
    expression_comp_2              shift and go to state 170
    exp                            shift and go to state 113
    term                           shift and go to state 114
    factor                         shift and go to state 115
    variable                       shift and go to state 117
    func_call                      shift and go to state 118

state 139

    (94) expression_comp_3 -> exp expressions_op . exp g_quad_logic
    (103) exp -> . term g_quad_exp_as_alone
    (104) exp -> . term g_quad_exp_as exp_comp
    (109) term -> . factor g_quad_exp_md_alone
    (110) term -> . factor g_quad_exp_md term_comp
    (116) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (117) factor -> . variable
    (118) factor -> . func_call
    (119) factor -> . CT_INT add_ct_int
    (120) factor -> . CT_FLOAT add_ct_float
    (121) factor -> . CT_CHAR add_ct_char
    (127) variable -> . ID add_id
    (128) variable -> . ID dim
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global

    OPEN_PAREN      shift and go to state 116
    CT_INT          shift and go to state 119
    CT_FLOAT        shift and go to state 120
    CT_CHAR         shift and go to state 121
    ID              shift and go to state 122

    exp                            shift and go to state 171
    term                           shift and go to state 114
    factor                         shift and go to state 115
    variable                       shift and go to state 117
    func_call                      shift and go to state 118

state 140

    (97) expressions_op -> LESS_THAN . add_op
    (115) add_op -> .

    OPEN_PAREN      reduce using rule 115 (add_op -> .)
    CT_INT          reduce using rule 115 (add_op -> .)
    CT_FLOAT        reduce using rule 115 (add_op -> .)
    CT_CHAR         reduce using rule 115 (add_op -> .)
    ID              reduce using rule 115 (add_op -> .)

    add_op                         shift and go to state 172

state 141

    (98) expressions_op -> LESS_THAN_EQUAL . add_op
    (115) add_op -> .

    OPEN_PAREN      reduce using rule 115 (add_op -> .)
    CT_INT          reduce using rule 115 (add_op -> .)
    CT_FLOAT        reduce using rule 115 (add_op -> .)
    CT_CHAR         reduce using rule 115 (add_op -> .)
    ID              reduce using rule 115 (add_op -> .)

    add_op                         shift and go to state 173

state 142

    (99) expressions_op -> MORE_THAN . add_op
    (115) add_op -> .

    OPEN_PAREN      reduce using rule 115 (add_op -> .)
    CT_INT          reduce using rule 115 (add_op -> .)
    CT_FLOAT        reduce using rule 115 (add_op -> .)
    CT_CHAR         reduce using rule 115 (add_op -> .)
    ID              reduce using rule 115 (add_op -> .)

    add_op                         shift and go to state 174

state 143

    (100) expressions_op -> MORE_THAN_EQUAL . add_op
    (115) add_op -> .

    OPEN_PAREN      reduce using rule 115 (add_op -> .)
    CT_INT          reduce using rule 115 (add_op -> .)
    CT_FLOAT        reduce using rule 115 (add_op -> .)
    CT_CHAR         reduce using rule 115 (add_op -> .)
    ID              reduce using rule 115 (add_op -> .)

    add_op                         shift and go to state 175

state 144

    (101) expressions_op -> EQUALS . add_op
    (115) add_op -> .

    OPEN_PAREN      reduce using rule 115 (add_op -> .)
    CT_INT          reduce using rule 115 (add_op -> .)
    CT_FLOAT        reduce using rule 115 (add_op -> .)
    CT_CHAR         reduce using rule 115 (add_op -> .)
    ID              reduce using rule 115 (add_op -> .)

    add_op                         shift and go to state 176

state 145

    (102) expressions_op -> NOT_EQUALS . add_op
    (115) add_op -> .

    OPEN_PAREN      reduce using rule 115 (add_op -> .)
    CT_INT          reduce using rule 115 (add_op -> .)
    CT_FLOAT        reduce using rule 115 (add_op -> .)
    CT_CHAR         reduce using rule 115 (add_op -> .)
    ID              reduce using rule 115 (add_op -> .)

    add_op                         shift and go to state 177

state 146

    (103) exp -> term g_quad_exp_as_alone .

    LESS_THAN       reduce using rule 103 (exp -> term g_quad_exp_as_alone .)
    LESS_THAN_EQUAL reduce using rule 103 (exp -> term g_quad_exp_as_alone .)
    MORE_THAN       reduce using rule 103 (exp -> term g_quad_exp_as_alone .)
    MORE_THAN_EQUAL reduce using rule 103 (exp -> term g_quad_exp_as_alone .)
    EQUALS          reduce using rule 103 (exp -> term g_quad_exp_as_alone .)
    NOT_EQUALS      reduce using rule 103 (exp -> term g_quad_exp_as_alone .)
    AND             reduce using rule 103 (exp -> term g_quad_exp_as_alone .)
    OR              reduce using rule 103 (exp -> term g_quad_exp_as_alone .)
    SEMICOLON       reduce using rule 103 (exp -> term g_quad_exp_as_alone .)
    COMMA           reduce using rule 103 (exp -> term g_quad_exp_as_alone .)
    CLOSE_PAREN     reduce using rule 103 (exp -> term g_quad_exp_as_alone .)
    CLOSE_BRACKETS  reduce using rule 103 (exp -> term g_quad_exp_as_alone .)
    TO              reduce using rule 103 (exp -> term g_quad_exp_as_alone .)
    OPEN_PAREN      reduce using rule 103 (exp -> term g_quad_exp_as_alone .)
    CT_INT          reduce using rule 103 (exp -> term g_quad_exp_as_alone .)
    CT_FLOAT        reduce using rule 103 (exp -> term g_quad_exp_as_alone .)
    CT_CHAR         reduce using rule 103 (exp -> term g_quad_exp_as_alone .)
    ID              reduce using rule 103 (exp -> term g_quad_exp_as_alone .)
    DO              reduce using rule 103 (exp -> term g_quad_exp_as_alone .)


state 147

    (104) exp -> term g_quad_exp_as . exp_comp
    (107) exp_comp -> . PLUS add_op exp
    (108) exp_comp -> . MINUS add_op exp

    PLUS            shift and go to state 179
    MINUS           shift and go to state 180

    exp_comp                       shift and go to state 178

state 148

    (109) term -> factor g_quad_exp_md_alone .

    PLUS            reduce using rule 109 (term -> factor g_quad_exp_md_alone .)
    MINUS           reduce using rule 109 (term -> factor g_quad_exp_md_alone .)
    LESS_THAN       reduce using rule 109 (term -> factor g_quad_exp_md_alone .)
    LESS_THAN_EQUAL reduce using rule 109 (term -> factor g_quad_exp_md_alone .)
    MORE_THAN       reduce using rule 109 (term -> factor g_quad_exp_md_alone .)
    MORE_THAN_EQUAL reduce using rule 109 (term -> factor g_quad_exp_md_alone .)
    EQUALS          reduce using rule 109 (term -> factor g_quad_exp_md_alone .)
    NOT_EQUALS      reduce using rule 109 (term -> factor g_quad_exp_md_alone .)
    AND             reduce using rule 109 (term -> factor g_quad_exp_md_alone .)
    OR              reduce using rule 109 (term -> factor g_quad_exp_md_alone .)
    SEMICOLON       reduce using rule 109 (term -> factor g_quad_exp_md_alone .)
    COMMA           reduce using rule 109 (term -> factor g_quad_exp_md_alone .)
    CLOSE_PAREN     reduce using rule 109 (term -> factor g_quad_exp_md_alone .)
    CLOSE_BRACKETS  reduce using rule 109 (term -> factor g_quad_exp_md_alone .)
    TO              reduce using rule 109 (term -> factor g_quad_exp_md_alone .)
    OPEN_PAREN      reduce using rule 109 (term -> factor g_quad_exp_md_alone .)
    CT_INT          reduce using rule 109 (term -> factor g_quad_exp_md_alone .)
    CT_FLOAT        reduce using rule 109 (term -> factor g_quad_exp_md_alone .)
    CT_CHAR         reduce using rule 109 (term -> factor g_quad_exp_md_alone .)
    ID              reduce using rule 109 (term -> factor g_quad_exp_md_alone .)
    DO              reduce using rule 109 (term -> factor g_quad_exp_md_alone .)


state 149

    (110) term -> factor g_quad_exp_md . term_comp
    (113) term_comp -> . MULTIPLIES add_op term
    (114) term_comp -> . DIVIDE add_op term

    MULTIPLIES      shift and go to state 182
    DIVIDE          shift and go to state 183

    term_comp                      shift and go to state 181

state 150

    (116) factor -> OPEN_PAREN add_fake . expressions CLOSE_PAREN rem_fake
    (89) expressions -> . expressions_comp
    (90) expressions_comp -> . expression_comp_2
    (91) expressions_comp -> . expression_comp_2 OR expressions_comp
    (92) expression_comp_2 -> . expression_comp_3
    (93) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (94) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (95) expression_comp_3 -> . exp
    (103) exp -> . term g_quad_exp_as_alone
    (104) exp -> . term g_quad_exp_as exp_comp
    (109) term -> . factor g_quad_exp_md_alone
    (110) term -> . factor g_quad_exp_md term_comp
    (116) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (117) factor -> . variable
    (118) factor -> . func_call
    (119) factor -> . CT_INT add_ct_int
    (120) factor -> . CT_FLOAT add_ct_float
    (121) factor -> . CT_CHAR add_ct_char
    (127) variable -> . ID add_id
    (128) variable -> . ID dim
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global

    OPEN_PAREN      shift and go to state 116
    CT_INT          shift and go to state 119
    CT_FLOAT        shift and go to state 120
    CT_CHAR         shift and go to state 121
    ID              shift and go to state 122

    expressions                    shift and go to state 184
    expressions_comp               shift and go to state 110
    expression_comp_2              shift and go to state 111
    expression_comp_3              shift and go to state 112
    exp                            shift and go to state 113
    term                           shift and go to state 114
    factor                         shift and go to state 115
    variable                       shift and go to state 117
    func_call                      shift and go to state 118

state 151

    (119) factor -> CT_INT add_ct_int .

    MULTIPLIES      reduce using rule 119 (factor -> CT_INT add_ct_int .)
    DIVIDE          reduce using rule 119 (factor -> CT_INT add_ct_int .)
    PLUS            reduce using rule 119 (factor -> CT_INT add_ct_int .)
    MINUS           reduce using rule 119 (factor -> CT_INT add_ct_int .)
    LESS_THAN       reduce using rule 119 (factor -> CT_INT add_ct_int .)
    LESS_THAN_EQUAL reduce using rule 119 (factor -> CT_INT add_ct_int .)
    MORE_THAN       reduce using rule 119 (factor -> CT_INT add_ct_int .)
    MORE_THAN_EQUAL reduce using rule 119 (factor -> CT_INT add_ct_int .)
    EQUALS          reduce using rule 119 (factor -> CT_INT add_ct_int .)
    NOT_EQUALS      reduce using rule 119 (factor -> CT_INT add_ct_int .)
    AND             reduce using rule 119 (factor -> CT_INT add_ct_int .)
    OR              reduce using rule 119 (factor -> CT_INT add_ct_int .)
    SEMICOLON       reduce using rule 119 (factor -> CT_INT add_ct_int .)
    COMMA           reduce using rule 119 (factor -> CT_INT add_ct_int .)
    CLOSE_PAREN     reduce using rule 119 (factor -> CT_INT add_ct_int .)
    CLOSE_BRACKETS  reduce using rule 119 (factor -> CT_INT add_ct_int .)
    TO              reduce using rule 119 (factor -> CT_INT add_ct_int .)
    OPEN_PAREN      reduce using rule 119 (factor -> CT_INT add_ct_int .)
    CT_INT          reduce using rule 119 (factor -> CT_INT add_ct_int .)
    CT_FLOAT        reduce using rule 119 (factor -> CT_INT add_ct_int .)
    CT_CHAR         reduce using rule 119 (factor -> CT_INT add_ct_int .)
    ID              reduce using rule 119 (factor -> CT_INT add_ct_int .)
    DO              reduce using rule 119 (factor -> CT_INT add_ct_int .)


state 152

    (120) factor -> CT_FLOAT add_ct_float .

    MULTIPLIES      reduce using rule 120 (factor -> CT_FLOAT add_ct_float .)
    DIVIDE          reduce using rule 120 (factor -> CT_FLOAT add_ct_float .)
    PLUS            reduce using rule 120 (factor -> CT_FLOAT add_ct_float .)
    MINUS           reduce using rule 120 (factor -> CT_FLOAT add_ct_float .)
    LESS_THAN       reduce using rule 120 (factor -> CT_FLOAT add_ct_float .)
    LESS_THAN_EQUAL reduce using rule 120 (factor -> CT_FLOAT add_ct_float .)
    MORE_THAN       reduce using rule 120 (factor -> CT_FLOAT add_ct_float .)
    MORE_THAN_EQUAL reduce using rule 120 (factor -> CT_FLOAT add_ct_float .)
    EQUALS          reduce using rule 120 (factor -> CT_FLOAT add_ct_float .)
    NOT_EQUALS      reduce using rule 120 (factor -> CT_FLOAT add_ct_float .)
    AND             reduce using rule 120 (factor -> CT_FLOAT add_ct_float .)
    OR              reduce using rule 120 (factor -> CT_FLOAT add_ct_float .)
    SEMICOLON       reduce using rule 120 (factor -> CT_FLOAT add_ct_float .)
    COMMA           reduce using rule 120 (factor -> CT_FLOAT add_ct_float .)
    CLOSE_PAREN     reduce using rule 120 (factor -> CT_FLOAT add_ct_float .)
    CLOSE_BRACKETS  reduce using rule 120 (factor -> CT_FLOAT add_ct_float .)
    TO              reduce using rule 120 (factor -> CT_FLOAT add_ct_float .)
    OPEN_PAREN      reduce using rule 120 (factor -> CT_FLOAT add_ct_float .)
    CT_INT          reduce using rule 120 (factor -> CT_FLOAT add_ct_float .)
    CT_FLOAT        reduce using rule 120 (factor -> CT_FLOAT add_ct_float .)
    CT_CHAR         reduce using rule 120 (factor -> CT_FLOAT add_ct_float .)
    ID              reduce using rule 120 (factor -> CT_FLOAT add_ct_float .)
    DO              reduce using rule 120 (factor -> CT_FLOAT add_ct_float .)


state 153

    (121) factor -> CT_CHAR add_ct_char .

    MULTIPLIES      reduce using rule 121 (factor -> CT_CHAR add_ct_char .)
    DIVIDE          reduce using rule 121 (factor -> CT_CHAR add_ct_char .)
    PLUS            reduce using rule 121 (factor -> CT_CHAR add_ct_char .)
    MINUS           reduce using rule 121 (factor -> CT_CHAR add_ct_char .)
    LESS_THAN       reduce using rule 121 (factor -> CT_CHAR add_ct_char .)
    LESS_THAN_EQUAL reduce using rule 121 (factor -> CT_CHAR add_ct_char .)
    MORE_THAN       reduce using rule 121 (factor -> CT_CHAR add_ct_char .)
    MORE_THAN_EQUAL reduce using rule 121 (factor -> CT_CHAR add_ct_char .)
    EQUALS          reduce using rule 121 (factor -> CT_CHAR add_ct_char .)
    NOT_EQUALS      reduce using rule 121 (factor -> CT_CHAR add_ct_char .)
    AND             reduce using rule 121 (factor -> CT_CHAR add_ct_char .)
    OR              reduce using rule 121 (factor -> CT_CHAR add_ct_char .)
    SEMICOLON       reduce using rule 121 (factor -> CT_CHAR add_ct_char .)
    COMMA           reduce using rule 121 (factor -> CT_CHAR add_ct_char .)
    CLOSE_PAREN     reduce using rule 121 (factor -> CT_CHAR add_ct_char .)
    CLOSE_BRACKETS  reduce using rule 121 (factor -> CT_CHAR add_ct_char .)
    TO              reduce using rule 121 (factor -> CT_CHAR add_ct_char .)
    OPEN_PAREN      reduce using rule 121 (factor -> CT_CHAR add_ct_char .)
    CT_INT          reduce using rule 121 (factor -> CT_CHAR add_ct_char .)
    CT_FLOAT        reduce using rule 121 (factor -> CT_CHAR add_ct_char .)
    CT_CHAR         reduce using rule 121 (factor -> CT_CHAR add_ct_char .)
    ID              reduce using rule 121 (factor -> CT_CHAR add_ct_char .)
    DO              reduce using rule 121 (factor -> CT_CHAR add_ct_char .)


state 154

    (127) variable -> ID add_id .

    MULTIPLIES      reduce using rule 127 (variable -> ID add_id .)
    DIVIDE          reduce using rule 127 (variable -> ID add_id .)
    PLUS            reduce using rule 127 (variable -> ID add_id .)
    MINUS           reduce using rule 127 (variable -> ID add_id .)
    LESS_THAN       reduce using rule 127 (variable -> ID add_id .)
    LESS_THAN_EQUAL reduce using rule 127 (variable -> ID add_id .)
    MORE_THAN       reduce using rule 127 (variable -> ID add_id .)
    MORE_THAN_EQUAL reduce using rule 127 (variable -> ID add_id .)
    EQUALS          reduce using rule 127 (variable -> ID add_id .)
    NOT_EQUALS      reduce using rule 127 (variable -> ID add_id .)
    AND             reduce using rule 127 (variable -> ID add_id .)
    OR              reduce using rule 127 (variable -> ID add_id .)
    SEMICOLON       reduce using rule 127 (variable -> ID add_id .)
    COMMA           reduce using rule 127 (variable -> ID add_id .)
    CLOSE_PAREN     reduce using rule 127 (variable -> ID add_id .)
    CLOSE_BRACKETS  reduce using rule 127 (variable -> ID add_id .)
    TO              reduce using rule 127 (variable -> ID add_id .)
    OPEN_PAREN      reduce using rule 127 (variable -> ID add_id .)
    CT_INT          reduce using rule 127 (variable -> ID add_id .)
    CT_FLOAT        reduce using rule 127 (variable -> ID add_id .)
    CT_CHAR         reduce using rule 127 (variable -> ID add_id .)
    ID              reduce using rule 127 (variable -> ID add_id .)
    DO              reduce using rule 127 (variable -> ID add_id .)


state 155

    (128) variable -> ID dim .

    MULTIPLIES      reduce using rule 128 (variable -> ID dim .)
    DIVIDE          reduce using rule 128 (variable -> ID dim .)
    PLUS            reduce using rule 128 (variable -> ID dim .)
    MINUS           reduce using rule 128 (variable -> ID dim .)
    LESS_THAN       reduce using rule 128 (variable -> ID dim .)
    LESS_THAN_EQUAL reduce using rule 128 (variable -> ID dim .)
    MORE_THAN       reduce using rule 128 (variable -> ID dim .)
    MORE_THAN_EQUAL reduce using rule 128 (variable -> ID dim .)
    EQUALS          reduce using rule 128 (variable -> ID dim .)
    NOT_EQUALS      reduce using rule 128 (variable -> ID dim .)
    AND             reduce using rule 128 (variable -> ID dim .)
    OR              reduce using rule 128 (variable -> ID dim .)
    SEMICOLON       reduce using rule 128 (variable -> ID dim .)
    COMMA           reduce using rule 128 (variable -> ID dim .)
    CLOSE_PAREN     reduce using rule 128 (variable -> ID dim .)
    CLOSE_BRACKETS  reduce using rule 128 (variable -> ID dim .)
    TO              reduce using rule 128 (variable -> ID dim .)
    OPEN_PAREN      reduce using rule 128 (variable -> ID dim .)
    CT_INT          reduce using rule 128 (variable -> ID dim .)
    CT_FLOAT        reduce using rule 128 (variable -> ID dim .)
    CT_CHAR         reduce using rule 128 (variable -> ID dim .)
    ID              reduce using rule 128 (variable -> ID dim .)
    DO              reduce using rule 128 (variable -> ID dim .)


state 156

    (52) read -> READ OPEN_PAREN ids g_quad_read . read_comp CLOSE_PAREN
    (53) read_comp -> . COMMA ids g_quad_read read_comp
    (54) read_comp -> . empty
    (131) empty -> .

    COMMA           shift and go to state 186
    CLOSE_PAREN     reduce using rule 131 (empty -> .)

    read_comp                      shift and go to state 185
    empty                          shift and go to state 187

state 157

    (56) write -> WRITE OPEN_PAREN CT_STRING g_quad_write_str . write_comp CLOSE_PAREN
    (58) write_comp -> . COMMA CT_STRING g_quad_write_str write_comp
    (59) write_comp -> . COMMA expressions g_quad_write write_comp
    (60) write_comp -> . empty
    (131) empty -> .

    COMMA           shift and go to state 189
    CLOSE_PAREN     reduce using rule 131 (empty -> .)

    write_comp                     shift and go to state 188
    empty                          shift and go to state 190

state 158

    (57) write -> WRITE OPEN_PAREN expressions g_quad_write . write_comp CLOSE_PAREN
    (58) write_comp -> . COMMA CT_STRING g_quad_write_str write_comp
    (59) write_comp -> . COMMA expressions g_quad_write write_comp
    (60) write_comp -> . empty
    (131) empty -> .

    COMMA           shift and go to state 189
    CLOSE_PAREN     reduce using rule 131 (empty -> .)

    write_comp                     shift and go to state 191
    empty                          shift and go to state 190

state 159

    (64) condition -> IF OPEN_PAREN expressions CLOSE_PAREN . g_if_quad THEN block end_if
    (65) condition -> IF OPEN_PAREN expressions CLOSE_PAREN . g_if_quad THEN block ELSE g_else_quad block end_if
    (68) g_if_quad -> .

    THEN            reduce using rule 68 (g_if_quad -> .)

    g_if_quad                      shift and go to state 192

state 160

    (66) condition -> WHILE while_jump OPEN_PAREN expressions . CLOSE_PAREN g_while_quad DO block end_while

    CLOSE_PAREN     shift and go to state 193


state 161

    (67) condition -> FOR ids validate_for ASSIGN . expressions for_counter_control TO expressions for_counter_end DO block end_for
    (89) expressions -> . expressions_comp
    (90) expressions_comp -> . expression_comp_2
    (91) expressions_comp -> . expression_comp_2 OR expressions_comp
    (92) expression_comp_2 -> . expression_comp_3
    (93) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (94) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (95) expression_comp_3 -> . exp
    (103) exp -> . term g_quad_exp_as_alone
    (104) exp -> . term g_quad_exp_as exp_comp
    (109) term -> . factor g_quad_exp_md_alone
    (110) term -> . factor g_quad_exp_md term_comp
    (116) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (117) factor -> . variable
    (118) factor -> . func_call
    (119) factor -> . CT_INT add_ct_int
    (120) factor -> . CT_FLOAT add_ct_float
    (121) factor -> . CT_CHAR add_ct_char
    (127) variable -> . ID add_id
    (128) variable -> . ID dim
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global

    OPEN_PAREN      shift and go to state 116
    CT_INT          shift and go to state 119
    CT_FLOAT        shift and go to state 120
    CT_CHAR         shift and go to state 121
    ID              shift and go to state 122

    expressions                    shift and go to state 194
    expressions_comp               shift and go to state 110
    expression_comp_2              shift and go to state 111
    expression_comp_3              shift and go to state 112
    exp                            shift and go to state 113
    term                           shift and go to state 114
    factor                         shift and go to state 115
    variable                       shift and go to state 117
    func_call                      shift and go to state 118

state 162

    (77) return -> RETURN OPEN_PAREN expressions CLOSE_PAREN . return_end
    (78) return_end -> .

    SEMICOLON       reduce using rule 78 (return_end -> .)

    return_end                     shift and go to state 195

state 163

    (79) func_call -> ID verify_function_exists OPEN_PAREN era_activation . func_call_comp CLOSE_PAREN g_gosub_quad change_to_global
    (84) func_call_comp -> . expressions g_parameter_quad func_call_comp
    (85) func_call_comp -> . COMMA expressions g_parameter_quad func_call_comp
    (86) func_call_comp -> . empty
    (89) expressions -> . expressions_comp
    (131) empty -> .
    (90) expressions_comp -> . expression_comp_2
    (91) expressions_comp -> . expression_comp_2 OR expressions_comp
    (92) expression_comp_2 -> . expression_comp_3
    (93) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (94) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (95) expression_comp_3 -> . exp
    (103) exp -> . term g_quad_exp_as_alone
    (104) exp -> . term g_quad_exp_as exp_comp
    (109) term -> . factor g_quad_exp_md_alone
    (110) term -> . factor g_quad_exp_md term_comp
    (116) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (117) factor -> . variable
    (118) factor -> . func_call
    (119) factor -> . CT_INT add_ct_int
    (120) factor -> . CT_FLOAT add_ct_float
    (121) factor -> . CT_CHAR add_ct_char
    (127) variable -> . ID add_id
    (128) variable -> . ID dim
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global

    COMMA           shift and go to state 198
    CLOSE_PAREN     reduce using rule 131 (empty -> .)
    OPEN_PAREN      shift and go to state 116
    CT_INT          shift and go to state 119
    CT_FLOAT        shift and go to state 120
    CT_CHAR         shift and go to state 121
    ID              shift and go to state 122

    func_call_comp                 shift and go to state 196
    expressions                    shift and go to state 197
    empty                          shift and go to state 199
    expressions_comp               shift and go to state 110
    expression_comp_2              shift and go to state 111
    expression_comp_3              shift and go to state 112
    exp                            shift and go to state 113
    term                           shift and go to state 114
    factor                         shift and go to state 115
    variable                       shift and go to state 117
    func_call                      shift and go to state 118

state 164

    (41) ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS . OPEN_BRACKETS exp CLOSE_BRACKETS
    (42) ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS .

    OPEN_BRACKETS   shift and go to state 200
    ASSIGN          reduce using rule 42 (ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS .)
    COMMA           reduce using rule 42 (ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CLOSE_PAREN     reduce using rule 42 (ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS .)


state 165

    (7) funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars . block end_funcs funcs
    (20) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 47

    block                          shift and go to state 201

state 166

    (16) funcs_params_comp -> COMMA var_type variable_params . funcs_params_comp
    (16) funcs_params_comp -> . COMMA var_type variable_params funcs_params_comp
    (17) funcs_params_comp -> . empty
    (131) empty -> .

    COMMA           shift and go to state 96
    CLOSE_PAREN     reduce using rule 131 (empty -> .)

    funcs_params_comp              shift and go to state 202
    empty                          shift and go to state 97

state 167

    (130) dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .

    COMMA           reduce using rule 130 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CLOSE_PAREN     reduce using rule 130 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    MULTIPLIES      reduce using rule 130 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    DIVIDE          reduce using rule 130 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    PLUS            reduce using rule 130 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    MINUS           reduce using rule 130 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    LESS_THAN       reduce using rule 130 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    LESS_THAN_EQUAL reduce using rule 130 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    MORE_THAN       reduce using rule 130 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    MORE_THAN_EQUAL reduce using rule 130 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    EQUALS          reduce using rule 130 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    NOT_EQUALS      reduce using rule 130 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    AND             reduce using rule 130 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    OR              reduce using rule 130 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    SEMICOLON       reduce using rule 130 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CLOSE_BRACKETS  reduce using rule 130 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    TO              reduce using rule 130 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    OPEN_PAREN      reduce using rule 130 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CT_INT          reduce using rule 130 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CT_FLOAT        reduce using rule 130 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CT_CHAR         reduce using rule 130 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    ID              reduce using rule 130 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    DO              reduce using rule 130 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)


state 168

    (12) funcs_comp -> ID add_module OPEN_PAREN funcs_params . CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs

    CLOSE_PAREN     shift and go to state 203


state 169

    (91) expressions_comp -> expression_comp_2 OR expressions_comp .

    SEMICOLON       reduce using rule 91 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    COMMA           reduce using rule 91 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    CLOSE_PAREN     reduce using rule 91 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    TO              reduce using rule 91 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    OPEN_PAREN      reduce using rule 91 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    CT_INT          reduce using rule 91 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    CT_FLOAT        reduce using rule 91 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    CT_CHAR         reduce using rule 91 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    ID              reduce using rule 91 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    DO              reduce using rule 91 (expressions_comp -> expression_comp_2 OR expressions_comp .)


state 170

    (93) expression_comp_2 -> expression_comp_3 AND expression_comp_2 .

    OR              reduce using rule 93 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    SEMICOLON       reduce using rule 93 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    COMMA           reduce using rule 93 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    CLOSE_PAREN     reduce using rule 93 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    TO              reduce using rule 93 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    OPEN_PAREN      reduce using rule 93 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    CT_INT          reduce using rule 93 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    CT_FLOAT        reduce using rule 93 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    CT_CHAR         reduce using rule 93 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    ID              reduce using rule 93 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    DO              reduce using rule 93 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)


state 171

    (94) expression_comp_3 -> exp expressions_op exp . g_quad_logic
    (96) g_quad_logic -> .

    AND             reduce using rule 96 (g_quad_logic -> .)
    OR              reduce using rule 96 (g_quad_logic -> .)
    SEMICOLON       reduce using rule 96 (g_quad_logic -> .)
    COMMA           reduce using rule 96 (g_quad_logic -> .)
    CLOSE_PAREN     reduce using rule 96 (g_quad_logic -> .)
    TO              reduce using rule 96 (g_quad_logic -> .)
    OPEN_PAREN      reduce using rule 96 (g_quad_logic -> .)
    CT_INT          reduce using rule 96 (g_quad_logic -> .)
    CT_FLOAT        reduce using rule 96 (g_quad_logic -> .)
    CT_CHAR         reduce using rule 96 (g_quad_logic -> .)
    ID              reduce using rule 96 (g_quad_logic -> .)
    DO              reduce using rule 96 (g_quad_logic -> .)

    g_quad_logic                   shift and go to state 204

state 172

    (97) expressions_op -> LESS_THAN add_op .

    OPEN_PAREN      reduce using rule 97 (expressions_op -> LESS_THAN add_op .)
    CT_INT          reduce using rule 97 (expressions_op -> LESS_THAN add_op .)
    CT_FLOAT        reduce using rule 97 (expressions_op -> LESS_THAN add_op .)
    CT_CHAR         reduce using rule 97 (expressions_op -> LESS_THAN add_op .)
    ID              reduce using rule 97 (expressions_op -> LESS_THAN add_op .)


state 173

    (98) expressions_op -> LESS_THAN_EQUAL add_op .

    OPEN_PAREN      reduce using rule 98 (expressions_op -> LESS_THAN_EQUAL add_op .)
    CT_INT          reduce using rule 98 (expressions_op -> LESS_THAN_EQUAL add_op .)
    CT_FLOAT        reduce using rule 98 (expressions_op -> LESS_THAN_EQUAL add_op .)
    CT_CHAR         reduce using rule 98 (expressions_op -> LESS_THAN_EQUAL add_op .)
    ID              reduce using rule 98 (expressions_op -> LESS_THAN_EQUAL add_op .)


state 174

    (99) expressions_op -> MORE_THAN add_op .

    OPEN_PAREN      reduce using rule 99 (expressions_op -> MORE_THAN add_op .)
    CT_INT          reduce using rule 99 (expressions_op -> MORE_THAN add_op .)
    CT_FLOAT        reduce using rule 99 (expressions_op -> MORE_THAN add_op .)
    CT_CHAR         reduce using rule 99 (expressions_op -> MORE_THAN add_op .)
    ID              reduce using rule 99 (expressions_op -> MORE_THAN add_op .)


state 175

    (100) expressions_op -> MORE_THAN_EQUAL add_op .

    OPEN_PAREN      reduce using rule 100 (expressions_op -> MORE_THAN_EQUAL add_op .)
    CT_INT          reduce using rule 100 (expressions_op -> MORE_THAN_EQUAL add_op .)
    CT_FLOAT        reduce using rule 100 (expressions_op -> MORE_THAN_EQUAL add_op .)
    CT_CHAR         reduce using rule 100 (expressions_op -> MORE_THAN_EQUAL add_op .)
    ID              reduce using rule 100 (expressions_op -> MORE_THAN_EQUAL add_op .)


state 176

    (101) expressions_op -> EQUALS add_op .

    OPEN_PAREN      reduce using rule 101 (expressions_op -> EQUALS add_op .)
    CT_INT          reduce using rule 101 (expressions_op -> EQUALS add_op .)
    CT_FLOAT        reduce using rule 101 (expressions_op -> EQUALS add_op .)
    CT_CHAR         reduce using rule 101 (expressions_op -> EQUALS add_op .)
    ID              reduce using rule 101 (expressions_op -> EQUALS add_op .)


state 177

    (102) expressions_op -> NOT_EQUALS add_op .

    OPEN_PAREN      reduce using rule 102 (expressions_op -> NOT_EQUALS add_op .)
    CT_INT          reduce using rule 102 (expressions_op -> NOT_EQUALS add_op .)
    CT_FLOAT        reduce using rule 102 (expressions_op -> NOT_EQUALS add_op .)
    CT_CHAR         reduce using rule 102 (expressions_op -> NOT_EQUALS add_op .)
    ID              reduce using rule 102 (expressions_op -> NOT_EQUALS add_op .)


state 178

    (104) exp -> term g_quad_exp_as exp_comp .

    LESS_THAN       reduce using rule 104 (exp -> term g_quad_exp_as exp_comp .)
    LESS_THAN_EQUAL reduce using rule 104 (exp -> term g_quad_exp_as exp_comp .)
    MORE_THAN       reduce using rule 104 (exp -> term g_quad_exp_as exp_comp .)
    MORE_THAN_EQUAL reduce using rule 104 (exp -> term g_quad_exp_as exp_comp .)
    EQUALS          reduce using rule 104 (exp -> term g_quad_exp_as exp_comp .)
    NOT_EQUALS      reduce using rule 104 (exp -> term g_quad_exp_as exp_comp .)
    AND             reduce using rule 104 (exp -> term g_quad_exp_as exp_comp .)
    OR              reduce using rule 104 (exp -> term g_quad_exp_as exp_comp .)
    SEMICOLON       reduce using rule 104 (exp -> term g_quad_exp_as exp_comp .)
    COMMA           reduce using rule 104 (exp -> term g_quad_exp_as exp_comp .)
    CLOSE_PAREN     reduce using rule 104 (exp -> term g_quad_exp_as exp_comp .)
    CLOSE_BRACKETS  reduce using rule 104 (exp -> term g_quad_exp_as exp_comp .)
    TO              reduce using rule 104 (exp -> term g_quad_exp_as exp_comp .)
    OPEN_PAREN      reduce using rule 104 (exp -> term g_quad_exp_as exp_comp .)
    CT_INT          reduce using rule 104 (exp -> term g_quad_exp_as exp_comp .)
    CT_FLOAT        reduce using rule 104 (exp -> term g_quad_exp_as exp_comp .)
    CT_CHAR         reduce using rule 104 (exp -> term g_quad_exp_as exp_comp .)
    ID              reduce using rule 104 (exp -> term g_quad_exp_as exp_comp .)
    DO              reduce using rule 104 (exp -> term g_quad_exp_as exp_comp .)


state 179

    (107) exp_comp -> PLUS . add_op exp
    (115) add_op -> .

    OPEN_PAREN      reduce using rule 115 (add_op -> .)
    CT_INT          reduce using rule 115 (add_op -> .)
    CT_FLOAT        reduce using rule 115 (add_op -> .)
    CT_CHAR         reduce using rule 115 (add_op -> .)
    ID              reduce using rule 115 (add_op -> .)

    add_op                         shift and go to state 205

state 180

    (108) exp_comp -> MINUS . add_op exp
    (115) add_op -> .

    OPEN_PAREN      reduce using rule 115 (add_op -> .)
    CT_INT          reduce using rule 115 (add_op -> .)
    CT_FLOAT        reduce using rule 115 (add_op -> .)
    CT_CHAR         reduce using rule 115 (add_op -> .)
    ID              reduce using rule 115 (add_op -> .)

    add_op                         shift and go to state 206

state 181

    (110) term -> factor g_quad_exp_md term_comp .

    PLUS            reduce using rule 110 (term -> factor g_quad_exp_md term_comp .)
    MINUS           reduce using rule 110 (term -> factor g_quad_exp_md term_comp .)
    LESS_THAN       reduce using rule 110 (term -> factor g_quad_exp_md term_comp .)
    LESS_THAN_EQUAL reduce using rule 110 (term -> factor g_quad_exp_md term_comp .)
    MORE_THAN       reduce using rule 110 (term -> factor g_quad_exp_md term_comp .)
    MORE_THAN_EQUAL reduce using rule 110 (term -> factor g_quad_exp_md term_comp .)
    EQUALS          reduce using rule 110 (term -> factor g_quad_exp_md term_comp .)
    NOT_EQUALS      reduce using rule 110 (term -> factor g_quad_exp_md term_comp .)
    AND             reduce using rule 110 (term -> factor g_quad_exp_md term_comp .)
    OR              reduce using rule 110 (term -> factor g_quad_exp_md term_comp .)
    SEMICOLON       reduce using rule 110 (term -> factor g_quad_exp_md term_comp .)
    COMMA           reduce using rule 110 (term -> factor g_quad_exp_md term_comp .)
    CLOSE_PAREN     reduce using rule 110 (term -> factor g_quad_exp_md term_comp .)
    CLOSE_BRACKETS  reduce using rule 110 (term -> factor g_quad_exp_md term_comp .)
    TO              reduce using rule 110 (term -> factor g_quad_exp_md term_comp .)
    OPEN_PAREN      reduce using rule 110 (term -> factor g_quad_exp_md term_comp .)
    CT_INT          reduce using rule 110 (term -> factor g_quad_exp_md term_comp .)
    CT_FLOAT        reduce using rule 110 (term -> factor g_quad_exp_md term_comp .)
    CT_CHAR         reduce using rule 110 (term -> factor g_quad_exp_md term_comp .)
    ID              reduce using rule 110 (term -> factor g_quad_exp_md term_comp .)
    DO              reduce using rule 110 (term -> factor g_quad_exp_md term_comp .)


state 182

    (113) term_comp -> MULTIPLIES . add_op term
    (115) add_op -> .

    OPEN_PAREN      reduce using rule 115 (add_op -> .)
    CT_INT          reduce using rule 115 (add_op -> .)
    CT_FLOAT        reduce using rule 115 (add_op -> .)
    CT_CHAR         reduce using rule 115 (add_op -> .)
    ID              reduce using rule 115 (add_op -> .)

    add_op                         shift and go to state 207

state 183

    (114) term_comp -> DIVIDE . add_op term
    (115) add_op -> .

    OPEN_PAREN      reduce using rule 115 (add_op -> .)
    CT_INT          reduce using rule 115 (add_op -> .)
    CT_FLOAT        reduce using rule 115 (add_op -> .)
    CT_CHAR         reduce using rule 115 (add_op -> .)
    ID              reduce using rule 115 (add_op -> .)

    add_op                         shift and go to state 208

state 184

    (116) factor -> OPEN_PAREN add_fake expressions . CLOSE_PAREN rem_fake

    CLOSE_PAREN     shift and go to state 209


state 185

    (52) read -> READ OPEN_PAREN ids g_quad_read read_comp . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 210


state 186

    (53) read_comp -> COMMA . ids g_quad_read read_comp
    (41) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (42) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (43) ids -> . ID

    ID              shift and go to state 90

    ids                            shift and go to state 211

state 187

    (54) read_comp -> empty .

    CLOSE_PAREN     reduce using rule 54 (read_comp -> empty .)


state 188

    (56) write -> WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 212


state 189

    (58) write_comp -> COMMA . CT_STRING g_quad_write_str write_comp
    (59) write_comp -> COMMA . expressions g_quad_write write_comp
    (89) expressions -> . expressions_comp
    (90) expressions_comp -> . expression_comp_2
    (91) expressions_comp -> . expression_comp_2 OR expressions_comp
    (92) expression_comp_2 -> . expression_comp_3
    (93) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (94) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (95) expression_comp_3 -> . exp
    (103) exp -> . term g_quad_exp_as_alone
    (104) exp -> . term g_quad_exp_as exp_comp
    (109) term -> . factor g_quad_exp_md_alone
    (110) term -> . factor g_quad_exp_md term_comp
    (116) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (117) factor -> . variable
    (118) factor -> . func_call
    (119) factor -> . CT_INT add_ct_int
    (120) factor -> . CT_FLOAT add_ct_float
    (121) factor -> . CT_CHAR add_ct_char
    (127) variable -> . ID add_id
    (128) variable -> . ID dim
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global

    CT_STRING       shift and go to state 213
    OPEN_PAREN      shift and go to state 116
    CT_INT          shift and go to state 119
    CT_FLOAT        shift and go to state 120
    CT_CHAR         shift and go to state 121
    ID              shift and go to state 122

    expressions                    shift and go to state 214
    expressions_comp               shift and go to state 110
    expression_comp_2              shift and go to state 111
    expression_comp_3              shift and go to state 112
    exp                            shift and go to state 113
    term                           shift and go to state 114
    factor                         shift and go to state 115
    variable                       shift and go to state 117
    func_call                      shift and go to state 118

state 190

    (60) write_comp -> empty .

    CLOSE_PAREN     reduce using rule 60 (write_comp -> empty .)


state 191

    (57) write -> WRITE OPEN_PAREN expressions g_quad_write write_comp . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 215


state 192

    (64) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad . THEN block end_if
    (65) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad . THEN block ELSE g_else_quad block end_if

    THEN            shift and go to state 216


state 193

    (66) condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN . g_while_quad DO block end_while
    (71) g_while_quad -> .

    DO              reduce using rule 71 (g_while_quad -> .)

    g_while_quad                   shift and go to state 217

state 194

    (67) condition -> FOR ids validate_for ASSIGN expressions . for_counter_control TO expressions for_counter_end DO block end_for
    (74) for_counter_control -> .

    TO              reduce using rule 74 (for_counter_control -> .)

    for_counter_control            shift and go to state 218

state 195

    (77) return -> RETURN OPEN_PAREN expressions CLOSE_PAREN return_end .

    SEMICOLON       reduce using rule 77 (return -> RETURN OPEN_PAREN expressions CLOSE_PAREN return_end .)


state 196

    (79) func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp . CLOSE_PAREN g_gosub_quad change_to_global

    CLOSE_PAREN     shift and go to state 219


state 197

    (84) func_call_comp -> expressions . g_parameter_quad func_call_comp
    (87) g_parameter_quad -> .

    COMMA           reduce using rule 87 (g_parameter_quad -> .)
    OPEN_PAREN      reduce using rule 87 (g_parameter_quad -> .)
    CT_INT          reduce using rule 87 (g_parameter_quad -> .)
    CT_FLOAT        reduce using rule 87 (g_parameter_quad -> .)
    CT_CHAR         reduce using rule 87 (g_parameter_quad -> .)
    ID              reduce using rule 87 (g_parameter_quad -> .)
    CLOSE_PAREN     reduce using rule 87 (g_parameter_quad -> .)

    g_parameter_quad               shift and go to state 220

state 198

    (85) func_call_comp -> COMMA . expressions g_parameter_quad func_call_comp
    (89) expressions -> . expressions_comp
    (90) expressions_comp -> . expression_comp_2
    (91) expressions_comp -> . expression_comp_2 OR expressions_comp
    (92) expression_comp_2 -> . expression_comp_3
    (93) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (94) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (95) expression_comp_3 -> . exp
    (103) exp -> . term g_quad_exp_as_alone
    (104) exp -> . term g_quad_exp_as exp_comp
    (109) term -> . factor g_quad_exp_md_alone
    (110) term -> . factor g_quad_exp_md term_comp
    (116) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (117) factor -> . variable
    (118) factor -> . func_call
    (119) factor -> . CT_INT add_ct_int
    (120) factor -> . CT_FLOAT add_ct_float
    (121) factor -> . CT_CHAR add_ct_char
    (127) variable -> . ID add_id
    (128) variable -> . ID dim
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global

    OPEN_PAREN      shift and go to state 116
    CT_INT          shift and go to state 119
    CT_FLOAT        shift and go to state 120
    CT_CHAR         shift and go to state 121
    ID              shift and go to state 122

    expressions                    shift and go to state 221
    expressions_comp               shift and go to state 110
    expression_comp_2              shift and go to state 111
    expression_comp_3              shift and go to state 112
    exp                            shift and go to state 113
    term                           shift and go to state 114
    factor                         shift and go to state 115
    variable                       shift and go to state 117
    func_call                      shift and go to state 118

state 199

    (86) func_call_comp -> empty .

    CLOSE_PAREN     reduce using rule 86 (func_call_comp -> empty .)


state 200

    (41) ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS . exp CLOSE_BRACKETS
    (103) exp -> . term g_quad_exp_as_alone
    (104) exp -> . term g_quad_exp_as exp_comp
    (109) term -> . factor g_quad_exp_md_alone
    (110) term -> . factor g_quad_exp_md term_comp
    (116) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (117) factor -> . variable
    (118) factor -> . func_call
    (119) factor -> . CT_INT add_ct_int
    (120) factor -> . CT_FLOAT add_ct_float
    (121) factor -> . CT_CHAR add_ct_char
    (127) variable -> . ID add_id
    (128) variable -> . ID dim
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global

    OPEN_PAREN      shift and go to state 116
    CT_INT          shift and go to state 119
    CT_FLOAT        shift and go to state 120
    CT_CHAR         shift and go to state 121
    ID              shift and go to state 122

    exp                            shift and go to state 222
    term                           shift and go to state 114
    factor                         shift and go to state 115
    variable                       shift and go to state 117
    func_call                      shift and go to state 118

state 201

    (7) funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block . end_funcs funcs
    (9) end_funcs -> .

    VOID            reduce using rule 9 (end_funcs -> .)
    INT             reduce using rule 9 (end_funcs -> .)
    FLOAT           reduce using rule 9 (end_funcs -> .)
    CHAR            reduce using rule 9 (end_funcs -> .)
    MAIN            reduce using rule 9 (end_funcs -> .)
    OPEN_BRACES     reduce using rule 9 (end_funcs -> .)

    end_funcs                      shift and go to state 223

state 202

    (16) funcs_params_comp -> COMMA var_type variable_params funcs_params_comp .

    CLOSE_PAREN     reduce using rule 16 (funcs_params_comp -> COMMA var_type variable_params funcs_params_comp .)


state 203

    (12) funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN . add_parameter_amount vars count_local_vars block end_funcs funcs
    (13) add_parameter_amount -> .

    VARS            reduce using rule 13 (add_parameter_amount -> .)
    OPEN_BRACES     reduce using rule 13 (add_parameter_amount -> .)

    add_parameter_amount           shift and go to state 224

state 204

    (94) expression_comp_3 -> exp expressions_op exp g_quad_logic .

    AND             reduce using rule 94 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    OR              reduce using rule 94 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    SEMICOLON       reduce using rule 94 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    COMMA           reduce using rule 94 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    CLOSE_PAREN     reduce using rule 94 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    TO              reduce using rule 94 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    OPEN_PAREN      reduce using rule 94 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    CT_INT          reduce using rule 94 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    CT_FLOAT        reduce using rule 94 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    CT_CHAR         reduce using rule 94 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    ID              reduce using rule 94 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    DO              reduce using rule 94 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)


state 205

    (107) exp_comp -> PLUS add_op . exp
    (103) exp -> . term g_quad_exp_as_alone
    (104) exp -> . term g_quad_exp_as exp_comp
    (109) term -> . factor g_quad_exp_md_alone
    (110) term -> . factor g_quad_exp_md term_comp
    (116) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (117) factor -> . variable
    (118) factor -> . func_call
    (119) factor -> . CT_INT add_ct_int
    (120) factor -> . CT_FLOAT add_ct_float
    (121) factor -> . CT_CHAR add_ct_char
    (127) variable -> . ID add_id
    (128) variable -> . ID dim
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global

    OPEN_PAREN      shift and go to state 116
    CT_INT          shift and go to state 119
    CT_FLOAT        shift and go to state 120
    CT_CHAR         shift and go to state 121
    ID              shift and go to state 122

    exp                            shift and go to state 225
    term                           shift and go to state 114
    factor                         shift and go to state 115
    variable                       shift and go to state 117
    func_call                      shift and go to state 118

state 206

    (108) exp_comp -> MINUS add_op . exp
    (103) exp -> . term g_quad_exp_as_alone
    (104) exp -> . term g_quad_exp_as exp_comp
    (109) term -> . factor g_quad_exp_md_alone
    (110) term -> . factor g_quad_exp_md term_comp
    (116) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (117) factor -> . variable
    (118) factor -> . func_call
    (119) factor -> . CT_INT add_ct_int
    (120) factor -> . CT_FLOAT add_ct_float
    (121) factor -> . CT_CHAR add_ct_char
    (127) variable -> . ID add_id
    (128) variable -> . ID dim
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global

    OPEN_PAREN      shift and go to state 116
    CT_INT          shift and go to state 119
    CT_FLOAT        shift and go to state 120
    CT_CHAR         shift and go to state 121
    ID              shift and go to state 122

    exp                            shift and go to state 226
    term                           shift and go to state 114
    factor                         shift and go to state 115
    variable                       shift and go to state 117
    func_call                      shift and go to state 118

state 207

    (113) term_comp -> MULTIPLIES add_op . term
    (109) term -> . factor g_quad_exp_md_alone
    (110) term -> . factor g_quad_exp_md term_comp
    (116) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (117) factor -> . variable
    (118) factor -> . func_call
    (119) factor -> . CT_INT add_ct_int
    (120) factor -> . CT_FLOAT add_ct_float
    (121) factor -> . CT_CHAR add_ct_char
    (127) variable -> . ID add_id
    (128) variable -> . ID dim
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global

    OPEN_PAREN      shift and go to state 116
    CT_INT          shift and go to state 119
    CT_FLOAT        shift and go to state 120
    CT_CHAR         shift and go to state 121
    ID              shift and go to state 122

    term                           shift and go to state 227
    factor                         shift and go to state 115
    variable                       shift and go to state 117
    func_call                      shift and go to state 118

state 208

    (114) term_comp -> DIVIDE add_op . term
    (109) term -> . factor g_quad_exp_md_alone
    (110) term -> . factor g_quad_exp_md term_comp
    (116) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (117) factor -> . variable
    (118) factor -> . func_call
    (119) factor -> . CT_INT add_ct_int
    (120) factor -> . CT_FLOAT add_ct_float
    (121) factor -> . CT_CHAR add_ct_char
    (127) variable -> . ID add_id
    (128) variable -> . ID dim
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global

    OPEN_PAREN      shift and go to state 116
    CT_INT          shift and go to state 119
    CT_FLOAT        shift and go to state 120
    CT_CHAR         shift and go to state 121
    ID              shift and go to state 122

    term                           shift and go to state 228
    factor                         shift and go to state 115
    variable                       shift and go to state 117
    func_call                      shift and go to state 118

state 209

    (116) factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN . rem_fake
    (123) rem_fake -> .

    MULTIPLIES      reduce using rule 123 (rem_fake -> .)
    DIVIDE          reduce using rule 123 (rem_fake -> .)
    PLUS            reduce using rule 123 (rem_fake -> .)
    MINUS           reduce using rule 123 (rem_fake -> .)
    LESS_THAN       reduce using rule 123 (rem_fake -> .)
    LESS_THAN_EQUAL reduce using rule 123 (rem_fake -> .)
    MORE_THAN       reduce using rule 123 (rem_fake -> .)
    MORE_THAN_EQUAL reduce using rule 123 (rem_fake -> .)
    EQUALS          reduce using rule 123 (rem_fake -> .)
    NOT_EQUALS      reduce using rule 123 (rem_fake -> .)
    AND             reduce using rule 123 (rem_fake -> .)
    OR              reduce using rule 123 (rem_fake -> .)
    SEMICOLON       reduce using rule 123 (rem_fake -> .)
    COMMA           reduce using rule 123 (rem_fake -> .)
    CLOSE_PAREN     reduce using rule 123 (rem_fake -> .)
    CLOSE_BRACKETS  reduce using rule 123 (rem_fake -> .)
    TO              reduce using rule 123 (rem_fake -> .)
    OPEN_PAREN      reduce using rule 123 (rem_fake -> .)
    CT_INT          reduce using rule 123 (rem_fake -> .)
    CT_FLOAT        reduce using rule 123 (rem_fake -> .)
    CT_CHAR         reduce using rule 123 (rem_fake -> .)
    ID              reduce using rule 123 (rem_fake -> .)
    DO              reduce using rule 123 (rem_fake -> .)

    rem_fake                       shift and go to state 229

state 210

    (52) read -> READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN .

    SEMICOLON       reduce using rule 52 (read -> READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN .)


state 211

    (53) read_comp -> COMMA ids . g_quad_read read_comp
    (55) g_quad_read -> .

    COMMA           reduce using rule 55 (g_quad_read -> .)
    CLOSE_PAREN     reduce using rule 55 (g_quad_read -> .)

    g_quad_read                    shift and go to state 230

state 212

    (56) write -> WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN .

    SEMICOLON       reduce using rule 56 (write -> WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN .)


state 213

    (58) write_comp -> COMMA CT_STRING . g_quad_write_str write_comp
    (61) g_quad_write_str -> .

    COMMA           reduce using rule 61 (g_quad_write_str -> .)
    CLOSE_PAREN     reduce using rule 61 (g_quad_write_str -> .)

    g_quad_write_str               shift and go to state 231

state 214

    (59) write_comp -> COMMA expressions . g_quad_write write_comp
    (62) g_quad_write -> .

    COMMA           reduce using rule 62 (g_quad_write -> .)
    CLOSE_PAREN     reduce using rule 62 (g_quad_write -> .)

    g_quad_write                   shift and go to state 232

state 215

    (57) write -> WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN .

    SEMICOLON       reduce using rule 57 (write -> WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN .)


state 216

    (64) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN . block end_if
    (65) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN . block ELSE g_else_quad block end_if
    (20) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 47

    block                          shift and go to state 233

state 217

    (66) condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad . DO block end_while

    DO              shift and go to state 234


state 218

    (67) condition -> FOR ids validate_for ASSIGN expressions for_counter_control . TO expressions for_counter_end DO block end_for

    TO              shift and go to state 235


state 219

    (79) func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN . g_gosub_quad change_to_global
    (80) g_gosub_quad -> .

    SEMICOLON       reduce using rule 80 (g_gosub_quad -> .)
    MULTIPLIES      reduce using rule 80 (g_gosub_quad -> .)
    DIVIDE          reduce using rule 80 (g_gosub_quad -> .)
    PLUS            reduce using rule 80 (g_gosub_quad -> .)
    MINUS           reduce using rule 80 (g_gosub_quad -> .)
    LESS_THAN       reduce using rule 80 (g_gosub_quad -> .)
    LESS_THAN_EQUAL reduce using rule 80 (g_gosub_quad -> .)
    MORE_THAN       reduce using rule 80 (g_gosub_quad -> .)
    MORE_THAN_EQUAL reduce using rule 80 (g_gosub_quad -> .)
    EQUALS          reduce using rule 80 (g_gosub_quad -> .)
    NOT_EQUALS      reduce using rule 80 (g_gosub_quad -> .)
    AND             reduce using rule 80 (g_gosub_quad -> .)
    OR              reduce using rule 80 (g_gosub_quad -> .)
    COMMA           reduce using rule 80 (g_gosub_quad -> .)
    CLOSE_PAREN     reduce using rule 80 (g_gosub_quad -> .)
    CLOSE_BRACKETS  reduce using rule 80 (g_gosub_quad -> .)
    TO              reduce using rule 80 (g_gosub_quad -> .)
    OPEN_PAREN      reduce using rule 80 (g_gosub_quad -> .)
    CT_INT          reduce using rule 80 (g_gosub_quad -> .)
    CT_FLOAT        reduce using rule 80 (g_gosub_quad -> .)
    CT_CHAR         reduce using rule 80 (g_gosub_quad -> .)
    ID              reduce using rule 80 (g_gosub_quad -> .)
    DO              reduce using rule 80 (g_gosub_quad -> .)

    g_gosub_quad                   shift and go to state 236

state 220

    (84) func_call_comp -> expressions g_parameter_quad . func_call_comp
    (84) func_call_comp -> . expressions g_parameter_quad func_call_comp
    (85) func_call_comp -> . COMMA expressions g_parameter_quad func_call_comp
    (86) func_call_comp -> . empty
    (89) expressions -> . expressions_comp
    (131) empty -> .
    (90) expressions_comp -> . expression_comp_2
    (91) expressions_comp -> . expression_comp_2 OR expressions_comp
    (92) expression_comp_2 -> . expression_comp_3
    (93) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (94) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (95) expression_comp_3 -> . exp
    (103) exp -> . term g_quad_exp_as_alone
    (104) exp -> . term g_quad_exp_as exp_comp
    (109) term -> . factor g_quad_exp_md_alone
    (110) term -> . factor g_quad_exp_md term_comp
    (116) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (117) factor -> . variable
    (118) factor -> . func_call
    (119) factor -> . CT_INT add_ct_int
    (120) factor -> . CT_FLOAT add_ct_float
    (121) factor -> . CT_CHAR add_ct_char
    (127) variable -> . ID add_id
    (128) variable -> . ID dim
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global

    COMMA           shift and go to state 198
    CLOSE_PAREN     reduce using rule 131 (empty -> .)
    OPEN_PAREN      shift and go to state 116
    CT_INT          shift and go to state 119
    CT_FLOAT        shift and go to state 120
    CT_CHAR         shift and go to state 121
    ID              shift and go to state 122

    expressions                    shift and go to state 197
    func_call_comp                 shift and go to state 237
    empty                          shift and go to state 199
    expressions_comp               shift and go to state 110
    expression_comp_2              shift and go to state 111
    expression_comp_3              shift and go to state 112
    exp                            shift and go to state 113
    term                           shift and go to state 114
    factor                         shift and go to state 115
    variable                       shift and go to state 117
    func_call                      shift and go to state 118

state 221

    (85) func_call_comp -> COMMA expressions . g_parameter_quad func_call_comp
    (87) g_parameter_quad -> .

    COMMA           reduce using rule 87 (g_parameter_quad -> .)
    OPEN_PAREN      reduce using rule 87 (g_parameter_quad -> .)
    CT_INT          reduce using rule 87 (g_parameter_quad -> .)
    CT_FLOAT        reduce using rule 87 (g_parameter_quad -> .)
    CT_CHAR         reduce using rule 87 (g_parameter_quad -> .)
    ID              reduce using rule 87 (g_parameter_quad -> .)
    CLOSE_PAREN     reduce using rule 87 (g_parameter_quad -> .)

    g_parameter_quad               shift and go to state 238

state 222

    (41) ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp . CLOSE_BRACKETS

    CLOSE_BRACKETS  shift and go to state 239


state 223

    (7) funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs . funcs
    (7) funcs -> . func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs
    (8) funcs -> . empty
    (21) func_type -> . var_type
    (22) func_type -> . VOID
    (131) empty -> .
    (23) var_type -> . INT
    (24) var_type -> . FLOAT
    (25) var_type -> . CHAR

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
    VOID            shift and go to state 14
    MAIN            reduce using rule 131 (empty -> .)
    OPEN_BRACES     reduce using rule 131 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

  ! VOID            [ reduce using rule 131 (empty -> .) ]
  ! INT             [ reduce using rule 131 (empty -> .) ]
  ! FLOAT           [ reduce using rule 131 (empty -> .) ]
  ! CHAR            [ reduce using rule 131 (empty -> .) ]

    func_type                      shift and go to state 11
    funcs                          shift and go to state 240
    empty                          shift and go to state 12
    var_type                       shift and go to state 13

state 224

    (12) funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount . vars count_local_vars block end_funcs funcs
    (26) vars -> . VARS var_comp
    (27) vars -> . empty
    (131) empty -> .

    VARS            shift and go to state 8
    OPEN_BRACES     reduce using rule 131 (empty -> .)

    vars                           shift and go to state 241
    empty                          shift and go to state 9

state 225

    (107) exp_comp -> PLUS add_op exp .

    LESS_THAN       reduce using rule 107 (exp_comp -> PLUS add_op exp .)
    LESS_THAN_EQUAL reduce using rule 107 (exp_comp -> PLUS add_op exp .)
    MORE_THAN       reduce using rule 107 (exp_comp -> PLUS add_op exp .)
    MORE_THAN_EQUAL reduce using rule 107 (exp_comp -> PLUS add_op exp .)
    EQUALS          reduce using rule 107 (exp_comp -> PLUS add_op exp .)
    NOT_EQUALS      reduce using rule 107 (exp_comp -> PLUS add_op exp .)
    AND             reduce using rule 107 (exp_comp -> PLUS add_op exp .)
    OR              reduce using rule 107 (exp_comp -> PLUS add_op exp .)
    SEMICOLON       reduce using rule 107 (exp_comp -> PLUS add_op exp .)
    COMMA           reduce using rule 107 (exp_comp -> PLUS add_op exp .)
    CLOSE_PAREN     reduce using rule 107 (exp_comp -> PLUS add_op exp .)
    CLOSE_BRACKETS  reduce using rule 107 (exp_comp -> PLUS add_op exp .)
    TO              reduce using rule 107 (exp_comp -> PLUS add_op exp .)
    OPEN_PAREN      reduce using rule 107 (exp_comp -> PLUS add_op exp .)
    CT_INT          reduce using rule 107 (exp_comp -> PLUS add_op exp .)
    CT_FLOAT        reduce using rule 107 (exp_comp -> PLUS add_op exp .)
    CT_CHAR         reduce using rule 107 (exp_comp -> PLUS add_op exp .)
    ID              reduce using rule 107 (exp_comp -> PLUS add_op exp .)
    DO              reduce using rule 107 (exp_comp -> PLUS add_op exp .)


state 226

    (108) exp_comp -> MINUS add_op exp .

    LESS_THAN       reduce using rule 108 (exp_comp -> MINUS add_op exp .)
    LESS_THAN_EQUAL reduce using rule 108 (exp_comp -> MINUS add_op exp .)
    MORE_THAN       reduce using rule 108 (exp_comp -> MINUS add_op exp .)
    MORE_THAN_EQUAL reduce using rule 108 (exp_comp -> MINUS add_op exp .)
    EQUALS          reduce using rule 108 (exp_comp -> MINUS add_op exp .)
    NOT_EQUALS      reduce using rule 108 (exp_comp -> MINUS add_op exp .)
    AND             reduce using rule 108 (exp_comp -> MINUS add_op exp .)
    OR              reduce using rule 108 (exp_comp -> MINUS add_op exp .)
    SEMICOLON       reduce using rule 108 (exp_comp -> MINUS add_op exp .)
    COMMA           reduce using rule 108 (exp_comp -> MINUS add_op exp .)
    CLOSE_PAREN     reduce using rule 108 (exp_comp -> MINUS add_op exp .)
    CLOSE_BRACKETS  reduce using rule 108 (exp_comp -> MINUS add_op exp .)
    TO              reduce using rule 108 (exp_comp -> MINUS add_op exp .)
    OPEN_PAREN      reduce using rule 108 (exp_comp -> MINUS add_op exp .)
    CT_INT          reduce using rule 108 (exp_comp -> MINUS add_op exp .)
    CT_FLOAT        reduce using rule 108 (exp_comp -> MINUS add_op exp .)
    CT_CHAR         reduce using rule 108 (exp_comp -> MINUS add_op exp .)
    ID              reduce using rule 108 (exp_comp -> MINUS add_op exp .)
    DO              reduce using rule 108 (exp_comp -> MINUS add_op exp .)


state 227

    (113) term_comp -> MULTIPLIES add_op term .

    PLUS            reduce using rule 113 (term_comp -> MULTIPLIES add_op term .)
    MINUS           reduce using rule 113 (term_comp -> MULTIPLIES add_op term .)
    LESS_THAN       reduce using rule 113 (term_comp -> MULTIPLIES add_op term .)
    LESS_THAN_EQUAL reduce using rule 113 (term_comp -> MULTIPLIES add_op term .)
    MORE_THAN       reduce using rule 113 (term_comp -> MULTIPLIES add_op term .)
    MORE_THAN_EQUAL reduce using rule 113 (term_comp -> MULTIPLIES add_op term .)
    EQUALS          reduce using rule 113 (term_comp -> MULTIPLIES add_op term .)
    NOT_EQUALS      reduce using rule 113 (term_comp -> MULTIPLIES add_op term .)
    AND             reduce using rule 113 (term_comp -> MULTIPLIES add_op term .)
    OR              reduce using rule 113 (term_comp -> MULTIPLIES add_op term .)
    SEMICOLON       reduce using rule 113 (term_comp -> MULTIPLIES add_op term .)
    COMMA           reduce using rule 113 (term_comp -> MULTIPLIES add_op term .)
    CLOSE_PAREN     reduce using rule 113 (term_comp -> MULTIPLIES add_op term .)
    CLOSE_BRACKETS  reduce using rule 113 (term_comp -> MULTIPLIES add_op term .)
    TO              reduce using rule 113 (term_comp -> MULTIPLIES add_op term .)
    OPEN_PAREN      reduce using rule 113 (term_comp -> MULTIPLIES add_op term .)
    CT_INT          reduce using rule 113 (term_comp -> MULTIPLIES add_op term .)
    CT_FLOAT        reduce using rule 113 (term_comp -> MULTIPLIES add_op term .)
    CT_CHAR         reduce using rule 113 (term_comp -> MULTIPLIES add_op term .)
    ID              reduce using rule 113 (term_comp -> MULTIPLIES add_op term .)
    DO              reduce using rule 113 (term_comp -> MULTIPLIES add_op term .)


state 228

    (114) term_comp -> DIVIDE add_op term .

    PLUS            reduce using rule 114 (term_comp -> DIVIDE add_op term .)
    MINUS           reduce using rule 114 (term_comp -> DIVIDE add_op term .)
    LESS_THAN       reduce using rule 114 (term_comp -> DIVIDE add_op term .)
    LESS_THAN_EQUAL reduce using rule 114 (term_comp -> DIVIDE add_op term .)
    MORE_THAN       reduce using rule 114 (term_comp -> DIVIDE add_op term .)
    MORE_THAN_EQUAL reduce using rule 114 (term_comp -> DIVIDE add_op term .)
    EQUALS          reduce using rule 114 (term_comp -> DIVIDE add_op term .)
    NOT_EQUALS      reduce using rule 114 (term_comp -> DIVIDE add_op term .)
    AND             reduce using rule 114 (term_comp -> DIVIDE add_op term .)
    OR              reduce using rule 114 (term_comp -> DIVIDE add_op term .)
    SEMICOLON       reduce using rule 114 (term_comp -> DIVIDE add_op term .)
    COMMA           reduce using rule 114 (term_comp -> DIVIDE add_op term .)
    CLOSE_PAREN     reduce using rule 114 (term_comp -> DIVIDE add_op term .)
    CLOSE_BRACKETS  reduce using rule 114 (term_comp -> DIVIDE add_op term .)
    TO              reduce using rule 114 (term_comp -> DIVIDE add_op term .)
    OPEN_PAREN      reduce using rule 114 (term_comp -> DIVIDE add_op term .)
    CT_INT          reduce using rule 114 (term_comp -> DIVIDE add_op term .)
    CT_FLOAT        reduce using rule 114 (term_comp -> DIVIDE add_op term .)
    CT_CHAR         reduce using rule 114 (term_comp -> DIVIDE add_op term .)
    ID              reduce using rule 114 (term_comp -> DIVIDE add_op term .)
    DO              reduce using rule 114 (term_comp -> DIVIDE add_op term .)


state 229

    (116) factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .

    MULTIPLIES      reduce using rule 116 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    DIVIDE          reduce using rule 116 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    PLUS            reduce using rule 116 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    MINUS           reduce using rule 116 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    LESS_THAN       reduce using rule 116 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    LESS_THAN_EQUAL reduce using rule 116 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    MORE_THAN       reduce using rule 116 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    MORE_THAN_EQUAL reduce using rule 116 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    EQUALS          reduce using rule 116 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    NOT_EQUALS      reduce using rule 116 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    AND             reduce using rule 116 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    OR              reduce using rule 116 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    SEMICOLON       reduce using rule 116 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    COMMA           reduce using rule 116 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    CLOSE_PAREN     reduce using rule 116 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    CLOSE_BRACKETS  reduce using rule 116 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    TO              reduce using rule 116 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    OPEN_PAREN      reduce using rule 116 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    CT_INT          reduce using rule 116 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    CT_FLOAT        reduce using rule 116 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    CT_CHAR         reduce using rule 116 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    ID              reduce using rule 116 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    DO              reduce using rule 116 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)


state 230

    (53) read_comp -> COMMA ids g_quad_read . read_comp
    (53) read_comp -> . COMMA ids g_quad_read read_comp
    (54) read_comp -> . empty
    (131) empty -> .

    COMMA           shift and go to state 186
    CLOSE_PAREN     reduce using rule 131 (empty -> .)

    read_comp                      shift and go to state 242
    empty                          shift and go to state 187

state 231

    (58) write_comp -> COMMA CT_STRING g_quad_write_str . write_comp
    (58) write_comp -> . COMMA CT_STRING g_quad_write_str write_comp
    (59) write_comp -> . COMMA expressions g_quad_write write_comp
    (60) write_comp -> . empty
    (131) empty -> .

    COMMA           shift and go to state 189
    CLOSE_PAREN     reduce using rule 131 (empty -> .)

    write_comp                     shift and go to state 243
    empty                          shift and go to state 190

state 232

    (59) write_comp -> COMMA expressions g_quad_write . write_comp
    (58) write_comp -> . COMMA CT_STRING g_quad_write_str write_comp
    (59) write_comp -> . COMMA expressions g_quad_write write_comp
    (60) write_comp -> . empty
    (131) empty -> .

    COMMA           shift and go to state 189
    CLOSE_PAREN     reduce using rule 131 (empty -> .)

    write_comp                     shift and go to state 244
    empty                          shift and go to state 190

state 233

    (64) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block . end_if
    (65) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block . ELSE g_else_quad block end_if
    (63) end_if -> .

    ELSE            shift and go to state 246
    READ            reduce using rule 63 (end_if -> .)
    WRITE           reduce using rule 63 (end_if -> .)
    IF              reduce using rule 63 (end_if -> .)
    WHILE           reduce using rule 63 (end_if -> .)
    FOR             reduce using rule 63 (end_if -> .)
    RETURN          reduce using rule 63 (end_if -> .)
    ID              reduce using rule 63 (end_if -> .)
    CLOSE_BRACES    reduce using rule 63 (end_if -> .)

    end_if                         shift and go to state 245

state 234

    (66) condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO . block end_while
    (20) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 47

    block                          shift and go to state 247

state 235

    (67) condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO . expressions for_counter_end DO block end_for
    (89) expressions -> . expressions_comp
    (90) expressions_comp -> . expression_comp_2
    (91) expressions_comp -> . expression_comp_2 OR expressions_comp
    (92) expression_comp_2 -> . expression_comp_3
    (93) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (94) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (95) expression_comp_3 -> . exp
    (103) exp -> . term g_quad_exp_as_alone
    (104) exp -> . term g_quad_exp_as exp_comp
    (109) term -> . factor g_quad_exp_md_alone
    (110) term -> . factor g_quad_exp_md term_comp
    (116) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (117) factor -> . variable
    (118) factor -> . func_call
    (119) factor -> . CT_INT add_ct_int
    (120) factor -> . CT_FLOAT add_ct_float
    (121) factor -> . CT_CHAR add_ct_char
    (127) variable -> . ID add_id
    (128) variable -> . ID dim
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global

    OPEN_PAREN      shift and go to state 116
    CT_INT          shift and go to state 119
    CT_FLOAT        shift and go to state 120
    CT_CHAR         shift and go to state 121
    ID              shift and go to state 122

    expressions                    shift and go to state 248
    expressions_comp               shift and go to state 110
    expression_comp_2              shift and go to state 111
    expression_comp_3              shift and go to state 112
    exp                            shift and go to state 113
    term                           shift and go to state 114
    factor                         shift and go to state 115
    variable                       shift and go to state 117
    func_call                      shift and go to state 118

state 236

    (79) func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad . change_to_global
    (81) change_to_global -> .

    SEMICOLON       reduce using rule 81 (change_to_global -> .)
    MULTIPLIES      reduce using rule 81 (change_to_global -> .)
    DIVIDE          reduce using rule 81 (change_to_global -> .)
    PLUS            reduce using rule 81 (change_to_global -> .)
    MINUS           reduce using rule 81 (change_to_global -> .)
    LESS_THAN       reduce using rule 81 (change_to_global -> .)
    LESS_THAN_EQUAL reduce using rule 81 (change_to_global -> .)
    MORE_THAN       reduce using rule 81 (change_to_global -> .)
    MORE_THAN_EQUAL reduce using rule 81 (change_to_global -> .)
    EQUALS          reduce using rule 81 (change_to_global -> .)
    NOT_EQUALS      reduce using rule 81 (change_to_global -> .)
    AND             reduce using rule 81 (change_to_global -> .)
    OR              reduce using rule 81 (change_to_global -> .)
    COMMA           reduce using rule 81 (change_to_global -> .)
    CLOSE_PAREN     reduce using rule 81 (change_to_global -> .)
    CLOSE_BRACKETS  reduce using rule 81 (change_to_global -> .)
    TO              reduce using rule 81 (change_to_global -> .)
    OPEN_PAREN      reduce using rule 81 (change_to_global -> .)
    CT_INT          reduce using rule 81 (change_to_global -> .)
    CT_FLOAT        reduce using rule 81 (change_to_global -> .)
    CT_CHAR         reduce using rule 81 (change_to_global -> .)
    ID              reduce using rule 81 (change_to_global -> .)
    DO              reduce using rule 81 (change_to_global -> .)

    change_to_global               shift and go to state 249

state 237

    (84) func_call_comp -> expressions g_parameter_quad func_call_comp .

    CLOSE_PAREN     reduce using rule 84 (func_call_comp -> expressions g_parameter_quad func_call_comp .)


state 238

    (85) func_call_comp -> COMMA expressions g_parameter_quad . func_call_comp
    (84) func_call_comp -> . expressions g_parameter_quad func_call_comp
    (85) func_call_comp -> . COMMA expressions g_parameter_quad func_call_comp
    (86) func_call_comp -> . empty
    (89) expressions -> . expressions_comp
    (131) empty -> .
    (90) expressions_comp -> . expression_comp_2
    (91) expressions_comp -> . expression_comp_2 OR expressions_comp
    (92) expression_comp_2 -> . expression_comp_3
    (93) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (94) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (95) expression_comp_3 -> . exp
    (103) exp -> . term g_quad_exp_as_alone
    (104) exp -> . term g_quad_exp_as exp_comp
    (109) term -> . factor g_quad_exp_md_alone
    (110) term -> . factor g_quad_exp_md term_comp
    (116) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (117) factor -> . variable
    (118) factor -> . func_call
    (119) factor -> . CT_INT add_ct_int
    (120) factor -> . CT_FLOAT add_ct_float
    (121) factor -> . CT_CHAR add_ct_char
    (127) variable -> . ID add_id
    (128) variable -> . ID dim
    (79) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global

    COMMA           shift and go to state 198
    CLOSE_PAREN     reduce using rule 131 (empty -> .)
    OPEN_PAREN      shift and go to state 116
    CT_INT          shift and go to state 119
    CT_FLOAT        shift and go to state 120
    CT_CHAR         shift and go to state 121
    ID              shift and go to state 122

    expressions                    shift and go to state 197
    func_call_comp                 shift and go to state 250
    empty                          shift and go to state 199
    expressions_comp               shift and go to state 110
    expression_comp_2              shift and go to state 111
    expression_comp_3              shift and go to state 112
    exp                            shift and go to state 113
    term                           shift and go to state 114
    factor                         shift and go to state 115
    variable                       shift and go to state 117
    func_call                      shift and go to state 118

state 239

    (41) ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS .

    ASSIGN          reduce using rule 41 (ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS .)
    COMMA           reduce using rule 41 (ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CLOSE_PAREN     reduce using rule 41 (ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS .)


state 240

    (7) funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .

    MAIN            reduce using rule 7 (funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .)
    VOID            reduce using rule 7 (funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .)
    INT             reduce using rule 7 (funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .)
    FLOAT           reduce using rule 7 (funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .)
    CHAR            reduce using rule 7 (funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .)
    OPEN_BRACES     reduce using rule 7 (funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .)


state 241

    (12) funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars . count_local_vars block end_funcs funcs
    (10) count_local_vars -> .

    OPEN_BRACES     reduce using rule 10 (count_local_vars -> .)

    count_local_vars               shift and go to state 251

state 242

    (53) read_comp -> COMMA ids g_quad_read read_comp .

    CLOSE_PAREN     reduce using rule 53 (read_comp -> COMMA ids g_quad_read read_comp .)


state 243

    (58) write_comp -> COMMA CT_STRING g_quad_write_str write_comp .

    CLOSE_PAREN     reduce using rule 58 (write_comp -> COMMA CT_STRING g_quad_write_str write_comp .)


state 244

    (59) write_comp -> COMMA expressions g_quad_write write_comp .

    CLOSE_PAREN     reduce using rule 59 (write_comp -> COMMA expressions g_quad_write write_comp .)


state 245

    (64) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .

    READ            reduce using rule 64 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    WRITE           reduce using rule 64 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    IF              reduce using rule 64 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    WHILE           reduce using rule 64 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    FOR             reduce using rule 64 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    RETURN          reduce using rule 64 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    ID              reduce using rule 64 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    CLOSE_BRACES    reduce using rule 64 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)


state 246

    (65) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE . g_else_quad block end_if
    (69) g_else_quad -> .

    OPEN_BRACES     reduce using rule 69 (g_else_quad -> .)

    g_else_quad                    shift and go to state 252

state 247

    (66) condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block . end_while
    (72) end_while -> .

    READ            reduce using rule 72 (end_while -> .)
    WRITE           reduce using rule 72 (end_while -> .)
    IF              reduce using rule 72 (end_while -> .)
    WHILE           reduce using rule 72 (end_while -> .)
    FOR             reduce using rule 72 (end_while -> .)
    RETURN          reduce using rule 72 (end_while -> .)
    ID              reduce using rule 72 (end_while -> .)
    CLOSE_BRACES    reduce using rule 72 (end_while -> .)

    end_while                      shift and go to state 253

state 248

    (67) condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions . for_counter_end DO block end_for
    (75) for_counter_end -> .

    DO              reduce using rule 75 (for_counter_end -> .)

    for_counter_end                shift and go to state 254

state 249

    (79) func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global .

    SEMICOLON       reduce using rule 79 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global .)
    MULTIPLIES      reduce using rule 79 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global .)
    DIVIDE          reduce using rule 79 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global .)
    PLUS            reduce using rule 79 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global .)
    MINUS           reduce using rule 79 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global .)
    LESS_THAN       reduce using rule 79 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global .)
    LESS_THAN_EQUAL reduce using rule 79 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global .)
    MORE_THAN       reduce using rule 79 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global .)
    MORE_THAN_EQUAL reduce using rule 79 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global .)
    EQUALS          reduce using rule 79 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global .)
    NOT_EQUALS      reduce using rule 79 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global .)
    AND             reduce using rule 79 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global .)
    OR              reduce using rule 79 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global .)
    COMMA           reduce using rule 79 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global .)
    CLOSE_PAREN     reduce using rule 79 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global .)
    CLOSE_BRACKETS  reduce using rule 79 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global .)
    TO              reduce using rule 79 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global .)
    OPEN_PAREN      reduce using rule 79 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global .)
    CT_INT          reduce using rule 79 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global .)
    CT_FLOAT        reduce using rule 79 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global .)
    CT_CHAR         reduce using rule 79 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global .)
    ID              reduce using rule 79 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global .)
    DO              reduce using rule 79 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad change_to_global .)


state 250

    (85) func_call_comp -> COMMA expressions g_parameter_quad func_call_comp .

    CLOSE_PAREN     reduce using rule 85 (func_call_comp -> COMMA expressions g_parameter_quad func_call_comp .)


state 251

    (12) funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars . block end_funcs funcs
    (20) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 47

    block                          shift and go to state 255

state 252

    (65) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad . block end_if
    (20) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 47

    block                          shift and go to state 256

state 253

    (66) condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .

    READ            reduce using rule 66 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .)
    WRITE           reduce using rule 66 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .)
    IF              reduce using rule 66 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .)
    WHILE           reduce using rule 66 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .)
    FOR             reduce using rule 66 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .)
    RETURN          reduce using rule 66 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .)
    ID              reduce using rule 66 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .)
    CLOSE_BRACES    reduce using rule 66 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .)


state 254

    (67) condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end . DO block end_for

    DO              shift and go to state 257


state 255

    (12) funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block . end_funcs funcs
    (9) end_funcs -> .

    VOID            reduce using rule 9 (end_funcs -> .)
    INT             reduce using rule 9 (end_funcs -> .)
    FLOAT           reduce using rule 9 (end_funcs -> .)
    CHAR            reduce using rule 9 (end_funcs -> .)
    MAIN            reduce using rule 9 (end_funcs -> .)
    OPEN_BRACES     reduce using rule 9 (end_funcs -> .)

    end_funcs                      shift and go to state 258

state 256

    (65) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block . end_if
    (63) end_if -> .

    READ            reduce using rule 63 (end_if -> .)
    WRITE           reduce using rule 63 (end_if -> .)
    IF              reduce using rule 63 (end_if -> .)
    WHILE           reduce using rule 63 (end_if -> .)
    FOR             reduce using rule 63 (end_if -> .)
    RETURN          reduce using rule 63 (end_if -> .)
    ID              reduce using rule 63 (end_if -> .)
    CLOSE_BRACES    reduce using rule 63 (end_if -> .)

    end_if                         shift and go to state 259

state 257

    (67) condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO . block end_for
    (20) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 47

    block                          shift and go to state 260

state 258

    (12) funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs . funcs
    (7) funcs -> . func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs
    (8) funcs -> . empty
    (21) func_type -> . var_type
    (22) func_type -> . VOID
    (131) empty -> .
    (23) var_type -> . INT
    (24) var_type -> . FLOAT
    (25) var_type -> . CHAR

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
    VOID            shift and go to state 14
    MAIN            reduce using rule 131 (empty -> .)
    OPEN_BRACES     reduce using rule 131 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

  ! VOID            [ reduce using rule 131 (empty -> .) ]
  ! INT             [ reduce using rule 131 (empty -> .) ]
  ! FLOAT           [ reduce using rule 131 (empty -> .) ]
  ! CHAR            [ reduce using rule 131 (empty -> .) ]

    funcs                          shift and go to state 261
    func_type                      shift and go to state 11
    empty                          shift and go to state 12
    var_type                       shift and go to state 13

state 259

    (65) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .

    READ            reduce using rule 65 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .)
    WRITE           reduce using rule 65 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .)
    IF              reduce using rule 65 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .)
    WHILE           reduce using rule 65 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .)
    FOR             reduce using rule 65 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .)
    RETURN          reduce using rule 65 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .)
    ID              reduce using rule 65 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .)
    CLOSE_BRACES    reduce using rule 65 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .)


state 260

    (67) condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block . end_for
    (76) end_for -> .

    READ            reduce using rule 76 (end_for -> .)
    WRITE           reduce using rule 76 (end_for -> .)
    IF              reduce using rule 76 (end_for -> .)
    WHILE           reduce using rule 76 (end_for -> .)
    FOR             reduce using rule 76 (end_for -> .)
    RETURN          reduce using rule 76 (end_for -> .)
    ID              reduce using rule 76 (end_for -> .)
    CLOSE_BRACES    reduce using rule 76 (end_for -> .)

    end_for                        shift and go to state 262

state 261

    (12) funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .

    VOID            reduce using rule 12 (funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .)
    INT             reduce using rule 12 (funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .)
    FLOAT           reduce using rule 12 (funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .)
    CHAR            reduce using rule 12 (funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .)
    MAIN            reduce using rule 12 (funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .)
    OPEN_BRACES     reduce using rule 12 (funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .)


state 262

    (67) condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .

    READ            reduce using rule 67 (condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .)
    WRITE           reduce using rule 67 (condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .)
    IF              reduce using rule 67 (condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .)
    WHILE           reduce using rule 67 (condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .)
    FOR             reduce using rule 67 (condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .)
    RETURN          reduce using rule 67 (condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .)
    ID              reduce using rule 67 (condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .)
    CLOSE_BRACES    reduce using rule 67 (condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for INT in state 35 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 35 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 35 resolved as shift
WARNING: shift/reduce conflict for INT in state 102 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 102 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 102 resolved as shift
WARNING: shift/reduce conflict for VOID in state 223 resolved as shift
WARNING: shift/reduce conflict for INT in state 223 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 223 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 223 resolved as shift
WARNING: shift/reduce conflict for VOID in state 258 resolved as shift
WARNING: shift/reduce conflict for INT in state 258 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 258 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 258 resolved as shift
WARNING: reduce/reduce conflict in state 122 resolved using rule (verify_function_exists -> <empty>)
WARNING: rejected rule (add_id -> <empty>) in state 122
