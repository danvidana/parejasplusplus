Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID add_program SEMICOLON vars funcs main end_program
Rule 2     add_program -> <empty>
Rule 3     end_program -> <empty>
Rule 4     main -> MAIN OPEN_PAREN CLOSE_PAREN block
Rule 5     funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block
Rule 6     funcs -> empty
Rule 7     add_module -> <empty>
Rule 8     funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block
Rule 9     funcs_params -> var_type variable_params funcs_params_comp
Rule 10    funcs_params -> empty
Rule 11    funcs_params_comp -> COMMA var_type variable_params funcs_params_comp
Rule 12    funcs_params_comp -> empty
Rule 13    block -> OPEN_BRACES statements CLOSE_BRACES
Rule 14    func_type -> var_type
Rule 15    func_type -> VOID
Rule 16    var_type -> INT
Rule 17    var_type -> FLOAT
Rule 18    var_type -> CHAR
Rule 19    vars -> VARS var_comp
Rule 20    vars -> empty
Rule 21    var_comp -> var_type ids_dec var_comp_2 var_comp_final
Rule 22    var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive
Rule 23    create_var_table -> empty
Rule 24    var_comp_2 -> COMMA ids_dec var_comp_3
Rule 25    var_comp_2 -> empty
Rule 26    var_comp_3 -> var_comp_2
Rule 27    var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final
Rule 28    var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive
Rule 29    var_comp_final -> SEMICOLON
Rule 30    var_comp_final -> var_module_trans
Rule 31    var_module_trans -> SEMICOLON var_type MODULE funcs_comp
Rule 32    ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
Rule 33    ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS
Rule 34    ids_dec -> ID
Rule 35    ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
Rule 36    ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS
Rule 37    ids -> ID
Rule 38    statements -> assignment SEMICOLON statements
Rule 39    statements -> read SEMICOLON statements
Rule 40    statements -> write SEMICOLON statements
Rule 41    statements -> condition statements
Rule 42    statements -> return SEMICOLON statements
Rule 43    statements -> func_call SEMICOLON statements
Rule 44    statements -> empty
Rule 45    assignment -> ids ASSIGN expressions
Rule 46    read -> READ OPEN_PAREN ids read_comp CLOSE_PAREN
Rule 47    read_comp -> COMMA ids read_comp
Rule 48    read_comp -> empty
Rule 49    write -> WRITE OPEN_PAREN CT_STRING write_comp CLOSE_PAREN
Rule 50    write -> WRITE OPEN_PAREN expressions write_comp CLOSE_PAREN
Rule 51    write_comp -> COMMA CT_STRING write_comp
Rule 52    write_comp -> COMMA expressions write_comp
Rule 53    write_comp -> empty
Rule 54    end_if -> <empty>
Rule 55    condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE g_else_quad block end_if
Rule 56    condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
Rule 57    condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN DO block
Rule 58    condition -> FOR ids ASSIGN expressions TO expressions DO block
Rule 59    g_if_quad -> <empty>
Rule 60    g_else_quad -> <empty>
Rule 61    while_jump -> <empty>
Rule 62    return -> RETURN OPEN_PAREN exp CLOSE_PAREN
Rule 63    func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN
Rule 64    func_call_comp -> expressions func_call_comp
Rule 65    func_call_comp -> COMMA expressions func_call_comp
Rule 66    func_call_comp -> empty
Rule 67    expressions -> expressions_comp
Rule 68    expressions_comp -> expression_comp_2
Rule 69    expressions_comp -> expression_comp_2 OR expressions_comp
Rule 70    expression_comp_2 -> expression_comp_3
Rule 71    expression_comp_2 -> expression_comp_3 AND expression_comp_2
Rule 72    expression_comp_3 -> exp
Rule 73    expression_comp_3 -> exp expressions_op exp
Rule 74    expressions_op -> LESS_THAN
Rule 75    expressions_op -> LESS_THAN_EQUAL
Rule 76    expressions_op -> MORE_THAN
Rule 77    expressions_op -> MORE_THAN_EQUAL
Rule 78    expressions_op -> EQUALS
Rule 79    expressions_op -> NOT_EQUALS
Rule 80    exp -> term g_quad_exp_as
Rule 81    exp -> term g_quad_exp_as exp_comp
Rule 82    g_quad_exp_as -> <empty>
Rule 83    exp_comp -> PLUS add_op exp
Rule 84    exp_comp -> MINUS add_op exp
Rule 85    term -> factor g_quad_exp_md
Rule 86    term -> factor g_quad_exp_md term_comp
Rule 87    g_quad_exp_md -> <empty>
Rule 88    term_comp -> MULTIPLIES add_op term
Rule 89    term_comp -> DIVIDE add_op term
Rule 90    add_op -> <empty>
Rule 91    factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
Rule 92    factor -> variable
Rule 93    factor -> func_call
Rule 94    factor -> CT_INT add_ct_int
Rule 95    factor -> CT_FLOAT add_ct_float
Rule 96    factor -> CT_CHAR add_ct_char
Rule 97    add_fake -> <empty>
Rule 98    rem_fake -> <empty>
Rule 99    add_ct_int -> <empty>
Rule 100   add_ct_float -> <empty>
Rule 101   add_ct_char -> <empty>
Rule 102   variable_params -> ID
Rule 103   variable_params -> ID dim
Rule 104   variable -> ID add_id
Rule 105   variable -> ID dim
Rule 106   add_id -> <empty>
Rule 107   dim -> OPEN_BRACKETS exp CLOSE_BRACKETS
Rule 108   empty -> <empty>

Terminals, with rules where they appear

AND                  : 71
ASSIGN               : 45 58
CHAR                 : 18
CLOSE_BRACES         : 13
CLOSE_BRACKETS       : 32 32 33 35 35 36 107
CLOSE_PAREN          : 4 5 8 46 49 50 55 56 57 62 63 91
COMMA                : 11 24 47 51 52 65
CT_CHAR              : 96
CT_FLOAT             : 95
CT_INT               : 32 32 33 94
CT_STRING            : 49 51
DIVIDE               : 89
DO                   : 57 58
ELSE                 : 55
EQUALS               : 78
FLOAT                : 17
FOR                  : 58
ID                   : 1 5 8 32 33 34 35 36 37 63 102 103 104 105
IF                   : 55 56
INT                  : 16
LESS_THAN            : 74
LESS_THAN_EQUAL      : 75
MAIN                 : 4
MINUS                : 84
MODULE               : 5 31
MORE_THAN            : 76
MORE_THAN_EQUAL      : 77
MULTIPLIES           : 88
NOT_EQUALS           : 79
OPEN_BRACES          : 13
OPEN_BRACKETS        : 32 32 33 35 35 36 107
OPEN_PAREN           : 4 5 8 46 49 50 55 56 57 62 63 91
OR                   : 69
PLUS                 : 83
PROGRAM              : 1
READ                 : 46
RETURN               : 62
SEMICOLON            : 1 22 28 29 31 38 39 40 42 43
THEN                 : 55 56
TO                   : 58
VARS                 : 19
VOID                 : 15
WHILE                : 57
WRITE                : 49 50
error                : 

Nonterminals, with rules where they appear

add_ct_char          : 96
add_ct_float         : 95
add_ct_int           : 94
add_fake             : 91
add_id               : 104
add_module           : 5 8
add_op               : 83 84 88 89
add_program          : 1
assignment           : 38
block                : 4 5 8 55 55 56 57 58
condition            : 41
create_var_table     : 
dim                  : 103 105
empty                : 6 10 12 20 23 25 44 48 53 66
end_if               : 55 56
end_program          : 1
exp                  : 35 35 36 62 72 73 73 83 84 107
exp_comp             : 81
expression_comp_2    : 68 69 71
expression_comp_3    : 70 71
expressions          : 45 50 52 55 56 57 58 58 64 65 91
expressions_comp     : 67 69
expressions_op       : 73
factor               : 85 86
func_call            : 43 93
func_call_comp       : 63 64 65
func_type            : 5
funcs                : 1
funcs_comp           : 31
funcs_params         : 5 8
funcs_params_comp    : 9 11
g_else_quad          : 55
g_if_quad            : 56
g_quad_exp_as        : 80 81
g_quad_exp_md        : 85 86
ids                  : 45 46 47 58
ids_dec              : 21 22 24 27 28
main                 : 1
program              : 0
read                 : 39
read_comp            : 46 47
rem_fake             : 91
return               : 42
statements           : 13 38 39 40 41 42 43
term                 : 80 81 88 89
term_comp            : 86
var_comp             : 19
var_comp_2           : 21 22 26 27 28
var_comp_3           : 24
var_comp_final       : 21 27
var_comp_recursive   : 22 28
var_module_trans     : 30
var_type             : 9 11 14 21 22 27 28 31
variable             : 92
variable_params      : 9 11
vars                 : 1 5 8
while_jump           : 57
write                : 40
write_comp           : 49 50 51 52

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID add_program SEMICOLON vars funcs main end_program

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID add_program SEMICOLON vars funcs main end_program

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . add_program SEMICOLON vars funcs main end_program
    (2) add_program -> .

    SEMICOLON       reduce using rule 2 (add_program -> .)

    add_program                    shift and go to state 4

state 4

    (1) program -> PROGRAM ID add_program . SEMICOLON vars funcs main end_program

    SEMICOLON       shift and go to state 5


state 5

    (1) program -> PROGRAM ID add_program SEMICOLON . vars funcs main end_program
    (19) vars -> . VARS var_comp
    (20) vars -> . empty
    (108) empty -> .

    VARS            shift and go to state 7
    VOID            reduce using rule 108 (empty -> .)
    INT             reduce using rule 108 (empty -> .)
    FLOAT           reduce using rule 108 (empty -> .)
    CHAR            reduce using rule 108 (empty -> .)
    MAIN            reduce using rule 108 (empty -> .)

    vars                           shift and go to state 6
    empty                          shift and go to state 8

state 6

    (1) program -> PROGRAM ID add_program SEMICOLON vars . funcs main end_program
    (5) funcs -> . func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block
    (6) funcs -> . empty
    (14) func_type -> . var_type
    (15) func_type -> . VOID
    (108) empty -> .
    (16) var_type -> . INT
    (17) var_type -> . FLOAT
    (18) var_type -> . CHAR

    VOID            shift and go to state 13
    MAIN            reduce using rule 108 (empty -> .)
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16

    funcs                          shift and go to state 9
    func_type                      shift and go to state 10
    empty                          shift and go to state 11
    var_type                       shift and go to state 12

state 7

    (19) vars -> VARS . var_comp
    (21) var_comp -> . var_type ids_dec var_comp_2 var_comp_final
    (22) var_comp -> . var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive
    (16) var_type -> . INT
    (17) var_type -> . FLOAT
    (18) var_type -> . CHAR

    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16

    var_comp                       shift and go to state 17
    var_type                       shift and go to state 18

state 8

    (20) vars -> empty .

    VOID            reduce using rule 20 (vars -> empty .)
    INT             reduce using rule 20 (vars -> empty .)
    FLOAT           reduce using rule 20 (vars -> empty .)
    CHAR            reduce using rule 20 (vars -> empty .)
    MAIN            reduce using rule 20 (vars -> empty .)
    OPEN_BRACES     reduce using rule 20 (vars -> empty .)


state 9

    (1) program -> PROGRAM ID add_program SEMICOLON vars funcs . main end_program
    (4) main -> . MAIN OPEN_PAREN CLOSE_PAREN block

    MAIN            shift and go to state 20

    main                           shift and go to state 19

state 10

    (5) funcs -> func_type . MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block

    MODULE          shift and go to state 21


state 11

    (6) funcs -> empty .

    MAIN            reduce using rule 6 (funcs -> empty .)


state 12

    (14) func_type -> var_type .

    MODULE          reduce using rule 14 (func_type -> var_type .)


state 13

    (15) func_type -> VOID .

    MODULE          reduce using rule 15 (func_type -> VOID .)


state 14

    (16) var_type -> INT .

    MODULE          reduce using rule 16 (var_type -> INT .)
    ID              reduce using rule 16 (var_type -> INT .)


state 15

    (17) var_type -> FLOAT .

    MODULE          reduce using rule 17 (var_type -> FLOAT .)
    ID              reduce using rule 17 (var_type -> FLOAT .)


state 16

    (18) var_type -> CHAR .

    MODULE          reduce using rule 18 (var_type -> CHAR .)
    ID              reduce using rule 18 (var_type -> CHAR .)


state 17

    (19) vars -> VARS var_comp .

    VOID            reduce using rule 19 (vars -> VARS var_comp .)
    INT             reduce using rule 19 (vars -> VARS var_comp .)
    FLOAT           reduce using rule 19 (vars -> VARS var_comp .)
    CHAR            reduce using rule 19 (vars -> VARS var_comp .)
    MAIN            reduce using rule 19 (vars -> VARS var_comp .)
    OPEN_BRACES     reduce using rule 19 (vars -> VARS var_comp .)


state 18

    (21) var_comp -> var_type . ids_dec var_comp_2 var_comp_final
    (22) var_comp -> var_type . ids_dec var_comp_2 SEMICOLON var_comp_recursive
    (32) ids_dec -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (33) ids_dec -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (34) ids_dec -> . ID

    ID              shift and go to state 23

    ids_dec                        shift and go to state 22

state 19

    (1) program -> PROGRAM ID add_program SEMICOLON vars funcs main . end_program
    (3) end_program -> .

    $end            reduce using rule 3 (end_program -> .)

    end_program                    shift and go to state 24

state 20

    (4) main -> MAIN . OPEN_PAREN CLOSE_PAREN block

    OPEN_PAREN      shift and go to state 25


state 21

    (5) funcs -> func_type MODULE . ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block

    ID              shift and go to state 26


state 22

    (21) var_comp -> var_type ids_dec . var_comp_2 var_comp_final
    (22) var_comp -> var_type ids_dec . var_comp_2 SEMICOLON var_comp_recursive
    (24) var_comp_2 -> . COMMA ids_dec var_comp_3
    (25) var_comp_2 -> . empty
    (108) empty -> .

    COMMA           shift and go to state 28
    SEMICOLON       reduce using rule 108 (empty -> .)

    var_comp_2                     shift and go to state 27
    empty                          shift and go to state 29

state 23

    (32) ids_dec -> ID . OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (33) ids_dec -> ID . OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (34) ids_dec -> ID .

    OPEN_BRACKETS   shift and go to state 30
    COMMA           reduce using rule 34 (ids_dec -> ID .)
    SEMICOLON       reduce using rule 34 (ids_dec -> ID .)


state 24

    (1) program -> PROGRAM ID add_program SEMICOLON vars funcs main end_program .

    $end            reduce using rule 1 (program -> PROGRAM ID add_program SEMICOLON vars funcs main end_program .)


state 25

    (4) main -> MAIN OPEN_PAREN . CLOSE_PAREN block

    CLOSE_PAREN     shift and go to state 31


state 26

    (5) funcs -> func_type MODULE ID . add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block
    (7) add_module -> .

    OPEN_PAREN      reduce using rule 7 (add_module -> .)

    add_module                     shift and go to state 32

state 27

    (21) var_comp -> var_type ids_dec var_comp_2 . var_comp_final
    (22) var_comp -> var_type ids_dec var_comp_2 . SEMICOLON var_comp_recursive
    (29) var_comp_final -> . SEMICOLON
    (30) var_comp_final -> . var_module_trans
    (31) var_module_trans -> . SEMICOLON var_type MODULE funcs_comp

    SEMICOLON       shift and go to state 34

    var_comp_final                 shift and go to state 33
    var_module_trans               shift and go to state 35

state 28

    (24) var_comp_2 -> COMMA . ids_dec var_comp_3
    (32) ids_dec -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (33) ids_dec -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (34) ids_dec -> . ID

    ID              shift and go to state 23

    ids_dec                        shift and go to state 36

state 29

    (25) var_comp_2 -> empty .

    SEMICOLON       reduce using rule 25 (var_comp_2 -> empty .)


state 30

    (32) ids_dec -> ID OPEN_BRACKETS . CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (33) ids_dec -> ID OPEN_BRACKETS . CT_INT CLOSE_BRACKETS

    CT_INT          shift and go to state 37


state 31

    (4) main -> MAIN OPEN_PAREN CLOSE_PAREN . block
    (13) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 39

    block                          shift and go to state 38

state 32

    (5) funcs -> func_type MODULE ID add_module . OPEN_PAREN funcs_params CLOSE_PAREN vars block

    OPEN_PAREN      shift and go to state 40


state 33

    (21) var_comp -> var_type ids_dec var_comp_2 var_comp_final .

    VOID            reduce using rule 21 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)
    INT             reduce using rule 21 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)
    FLOAT           reduce using rule 21 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)
    CHAR            reduce using rule 21 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)
    MAIN            reduce using rule 21 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)
    OPEN_BRACES     reduce using rule 21 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)


state 34

    (22) var_comp -> var_type ids_dec var_comp_2 SEMICOLON . var_comp_recursive
    (29) var_comp_final -> SEMICOLON .
    (31) var_module_trans -> SEMICOLON . var_type MODULE funcs_comp
    (27) var_comp_recursive -> . var_type ids_dec var_comp_2 var_comp_final
    (28) var_comp_recursive -> . var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive
    (16) var_type -> . INT
    (17) var_type -> . FLOAT
    (18) var_type -> . CHAR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
    VOID            reduce using rule 29 (var_comp_final -> SEMICOLON .)
    MAIN            reduce using rule 29 (var_comp_final -> SEMICOLON .)
    OPEN_BRACES     reduce using rule 29 (var_comp_final -> SEMICOLON .)
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16

  ! INT             [ reduce using rule 29 (var_comp_final -> SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 29 (var_comp_final -> SEMICOLON .) ]
  ! CHAR            [ reduce using rule 29 (var_comp_final -> SEMICOLON .) ]

    var_type                       shift and go to state 41
    var_comp_recursive             shift and go to state 42

state 35

    (30) var_comp_final -> var_module_trans .

    VOID            reduce using rule 30 (var_comp_final -> var_module_trans .)
    INT             reduce using rule 30 (var_comp_final -> var_module_trans .)
    FLOAT           reduce using rule 30 (var_comp_final -> var_module_trans .)
    CHAR            reduce using rule 30 (var_comp_final -> var_module_trans .)
    MAIN            reduce using rule 30 (var_comp_final -> var_module_trans .)
    OPEN_BRACES     reduce using rule 30 (var_comp_final -> var_module_trans .)


state 36

    (24) var_comp_2 -> COMMA ids_dec . var_comp_3
    (26) var_comp_3 -> . var_comp_2
    (24) var_comp_2 -> . COMMA ids_dec var_comp_3
    (25) var_comp_2 -> . empty
    (108) empty -> .

    COMMA           shift and go to state 28
    SEMICOLON       reduce using rule 108 (empty -> .)

    var_comp_3                     shift and go to state 43
    var_comp_2                     shift and go to state 44
    empty                          shift and go to state 29

state 37

    (32) ids_dec -> ID OPEN_BRACKETS CT_INT . CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (33) ids_dec -> ID OPEN_BRACKETS CT_INT . CLOSE_BRACKETS

    CLOSE_BRACKETS  shift and go to state 45


state 38

    (4) main -> MAIN OPEN_PAREN CLOSE_PAREN block .

    $end            reduce using rule 4 (main -> MAIN OPEN_PAREN CLOSE_PAREN block .)


state 39

    (13) block -> OPEN_BRACES . statements CLOSE_BRACES
    (38) statements -> . assignment SEMICOLON statements
    (39) statements -> . read SEMICOLON statements
    (40) statements -> . write SEMICOLON statements
    (41) statements -> . condition statements
    (42) statements -> . return SEMICOLON statements
    (43) statements -> . func_call SEMICOLON statements
    (44) statements -> . empty
    (45) assignment -> . ids ASSIGN expressions
    (46) read -> . READ OPEN_PAREN ids read_comp CLOSE_PAREN
    (49) write -> . WRITE OPEN_PAREN CT_STRING write_comp CLOSE_PAREN
    (50) write -> . WRITE OPEN_PAREN expressions write_comp CLOSE_PAREN
    (55) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE g_else_quad block end_if
    (56) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (57) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN DO block
    (58) condition -> . FOR ids ASSIGN expressions TO expressions DO block
    (62) return -> . RETURN OPEN_PAREN exp CLOSE_PAREN
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN
    (108) empty -> .
    (35) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (36) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (37) ids -> . ID

    READ            shift and go to state 55
    WRITE           shift and go to state 56
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    FOR             shift and go to state 59
    RETURN          shift and go to state 60
    ID              shift and go to state 61
    CLOSE_BRACES    reduce using rule 108 (empty -> .)

    statements                     shift and go to state 46
    assignment                     shift and go to state 47
    read                           shift and go to state 48
    write                          shift and go to state 49
    condition                      shift and go to state 50
    return                         shift and go to state 51
    func_call                      shift and go to state 52
    empty                          shift and go to state 53
    ids                            shift and go to state 54

state 40

    (5) funcs -> func_type MODULE ID add_module OPEN_PAREN . funcs_params CLOSE_PAREN vars block
    (9) funcs_params -> . var_type variable_params funcs_params_comp
    (10) funcs_params -> . empty
    (16) var_type -> . INT
    (17) var_type -> . FLOAT
    (18) var_type -> . CHAR
    (108) empty -> .

    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16
    CLOSE_PAREN     reduce using rule 108 (empty -> .)

    funcs_params                   shift and go to state 62
    var_type                       shift and go to state 63
    empty                          shift and go to state 64

state 41

    (31) var_module_trans -> SEMICOLON var_type . MODULE funcs_comp
    (27) var_comp_recursive -> var_type . ids_dec var_comp_2 var_comp_final
    (28) var_comp_recursive -> var_type . ids_dec var_comp_2 SEMICOLON var_comp_recursive
    (32) ids_dec -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (33) ids_dec -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (34) ids_dec -> . ID

    MODULE          shift and go to state 65
    ID              shift and go to state 23

    ids_dec                        shift and go to state 66

state 42

    (22) var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .

    VOID            reduce using rule 22 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    INT             reduce using rule 22 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    FLOAT           reduce using rule 22 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    CHAR            reduce using rule 22 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    MAIN            reduce using rule 22 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    OPEN_BRACES     reduce using rule 22 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)


state 43

    (24) var_comp_2 -> COMMA ids_dec var_comp_3 .

    SEMICOLON       reduce using rule 24 (var_comp_2 -> COMMA ids_dec var_comp_3 .)


state 44

    (26) var_comp_3 -> var_comp_2 .

    SEMICOLON       reduce using rule 26 (var_comp_3 -> var_comp_2 .)


state 45

    (32) ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS . OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (33) ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS .

    OPEN_BRACKETS   shift and go to state 67
    COMMA           reduce using rule 33 (ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS .)
    SEMICOLON       reduce using rule 33 (ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS .)


state 46

    (13) block -> OPEN_BRACES statements . CLOSE_BRACES

    CLOSE_BRACES    shift and go to state 68


state 47

    (38) statements -> assignment . SEMICOLON statements

    SEMICOLON       shift and go to state 69


state 48

    (39) statements -> read . SEMICOLON statements

    SEMICOLON       shift and go to state 70


state 49

    (40) statements -> write . SEMICOLON statements

    SEMICOLON       shift and go to state 71


state 50

    (41) statements -> condition . statements
    (38) statements -> . assignment SEMICOLON statements
    (39) statements -> . read SEMICOLON statements
    (40) statements -> . write SEMICOLON statements
    (41) statements -> . condition statements
    (42) statements -> . return SEMICOLON statements
    (43) statements -> . func_call SEMICOLON statements
    (44) statements -> . empty
    (45) assignment -> . ids ASSIGN expressions
    (46) read -> . READ OPEN_PAREN ids read_comp CLOSE_PAREN
    (49) write -> . WRITE OPEN_PAREN CT_STRING write_comp CLOSE_PAREN
    (50) write -> . WRITE OPEN_PAREN expressions write_comp CLOSE_PAREN
    (55) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE g_else_quad block end_if
    (56) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (57) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN DO block
    (58) condition -> . FOR ids ASSIGN expressions TO expressions DO block
    (62) return -> . RETURN OPEN_PAREN exp CLOSE_PAREN
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN
    (108) empty -> .
    (35) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (36) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (37) ids -> . ID

    READ            shift and go to state 55
    WRITE           shift and go to state 56
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    FOR             shift and go to state 59
    RETURN          shift and go to state 60
    ID              shift and go to state 61
    CLOSE_BRACES    reduce using rule 108 (empty -> .)

    condition                      shift and go to state 50
    statements                     shift and go to state 72
    assignment                     shift and go to state 47
    read                           shift and go to state 48
    write                          shift and go to state 49
    return                         shift and go to state 51
    func_call                      shift and go to state 52
    empty                          shift and go to state 53
    ids                            shift and go to state 54

state 51

    (42) statements -> return . SEMICOLON statements

    SEMICOLON       shift and go to state 73


state 52

    (43) statements -> func_call . SEMICOLON statements

    SEMICOLON       shift and go to state 74


state 53

    (44) statements -> empty .

    CLOSE_BRACES    reduce using rule 44 (statements -> empty .)


state 54

    (45) assignment -> ids . ASSIGN expressions

    ASSIGN          shift and go to state 75


state 55

    (46) read -> READ . OPEN_PAREN ids read_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 76


state 56

    (49) write -> WRITE . OPEN_PAREN CT_STRING write_comp CLOSE_PAREN
    (50) write -> WRITE . OPEN_PAREN expressions write_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 77


state 57

    (55) condition -> IF . OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE g_else_quad block end_if
    (56) condition -> IF . OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if

    OPEN_PAREN      shift and go to state 78


state 58

    (57) condition -> WHILE . while_jump OPEN_PAREN expressions CLOSE_PAREN DO block
    (61) while_jump -> .

    OPEN_PAREN      reduce using rule 61 (while_jump -> .)

    while_jump                     shift and go to state 79

state 59

    (58) condition -> FOR . ids ASSIGN expressions TO expressions DO block
    (35) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (36) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (37) ids -> . ID

    ID              shift and go to state 81

    ids                            shift and go to state 80

state 60

    (62) return -> RETURN . OPEN_PAREN exp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 82


state 61

    (63) func_call -> ID . OPEN_PAREN func_call_comp CLOSE_PAREN
    (35) ids -> ID . OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (36) ids -> ID . OPEN_BRACKETS exp CLOSE_BRACKETS
    (37) ids -> ID .

    OPEN_PAREN      shift and go to state 83
    OPEN_BRACKETS   shift and go to state 84
    ASSIGN          reduce using rule 37 (ids -> ID .)


state 62

    (5) funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params . CLOSE_PAREN vars block

    CLOSE_PAREN     shift and go to state 85


state 63

    (9) funcs_params -> var_type . variable_params funcs_params_comp
    (102) variable_params -> . ID
    (103) variable_params -> . ID dim

    ID              shift and go to state 87

    variable_params                shift and go to state 86

state 64

    (10) funcs_params -> empty .

    CLOSE_PAREN     reduce using rule 10 (funcs_params -> empty .)


state 65

    (31) var_module_trans -> SEMICOLON var_type MODULE . funcs_comp
    (8) funcs_comp -> . ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block

    ID              shift and go to state 89

    funcs_comp                     shift and go to state 88

state 66

    (27) var_comp_recursive -> var_type ids_dec . var_comp_2 var_comp_final
    (28) var_comp_recursive -> var_type ids_dec . var_comp_2 SEMICOLON var_comp_recursive
    (24) var_comp_2 -> . COMMA ids_dec var_comp_3
    (25) var_comp_2 -> . empty
    (108) empty -> .

    COMMA           shift and go to state 28
    SEMICOLON       reduce using rule 108 (empty -> .)

    var_comp_2                     shift and go to state 90
    empty                          shift and go to state 29

state 67

    (32) ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS . CT_INT CLOSE_BRACKETS

    CT_INT          shift and go to state 91


state 68

    (13) block -> OPEN_BRACES statements CLOSE_BRACES .

    $end            reduce using rule 13 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    MAIN            reduce using rule 13 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    ELSE            reduce using rule 13 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    READ            reduce using rule 13 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    WRITE           reduce using rule 13 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    IF              reduce using rule 13 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    WHILE           reduce using rule 13 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    FOR             reduce using rule 13 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    RETURN          reduce using rule 13 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    ID              reduce using rule 13 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    CLOSE_BRACES    reduce using rule 13 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    VOID            reduce using rule 13 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    INT             reduce using rule 13 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    FLOAT           reduce using rule 13 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    CHAR            reduce using rule 13 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    OPEN_BRACES     reduce using rule 13 (block -> OPEN_BRACES statements CLOSE_BRACES .)


state 69

    (38) statements -> assignment SEMICOLON . statements
    (38) statements -> . assignment SEMICOLON statements
    (39) statements -> . read SEMICOLON statements
    (40) statements -> . write SEMICOLON statements
    (41) statements -> . condition statements
    (42) statements -> . return SEMICOLON statements
    (43) statements -> . func_call SEMICOLON statements
    (44) statements -> . empty
    (45) assignment -> . ids ASSIGN expressions
    (46) read -> . READ OPEN_PAREN ids read_comp CLOSE_PAREN
    (49) write -> . WRITE OPEN_PAREN CT_STRING write_comp CLOSE_PAREN
    (50) write -> . WRITE OPEN_PAREN expressions write_comp CLOSE_PAREN
    (55) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE g_else_quad block end_if
    (56) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (57) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN DO block
    (58) condition -> . FOR ids ASSIGN expressions TO expressions DO block
    (62) return -> . RETURN OPEN_PAREN exp CLOSE_PAREN
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN
    (108) empty -> .
    (35) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (36) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (37) ids -> . ID

    READ            shift and go to state 55
    WRITE           shift and go to state 56
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    FOR             shift and go to state 59
    RETURN          shift and go to state 60
    ID              shift and go to state 61
    CLOSE_BRACES    reduce using rule 108 (empty -> .)

    assignment                     shift and go to state 47
    statements                     shift and go to state 92
    read                           shift and go to state 48
    write                          shift and go to state 49
    condition                      shift and go to state 50
    return                         shift and go to state 51
    func_call                      shift and go to state 52
    empty                          shift and go to state 53
    ids                            shift and go to state 54

state 70

    (39) statements -> read SEMICOLON . statements
    (38) statements -> . assignment SEMICOLON statements
    (39) statements -> . read SEMICOLON statements
    (40) statements -> . write SEMICOLON statements
    (41) statements -> . condition statements
    (42) statements -> . return SEMICOLON statements
    (43) statements -> . func_call SEMICOLON statements
    (44) statements -> . empty
    (45) assignment -> . ids ASSIGN expressions
    (46) read -> . READ OPEN_PAREN ids read_comp CLOSE_PAREN
    (49) write -> . WRITE OPEN_PAREN CT_STRING write_comp CLOSE_PAREN
    (50) write -> . WRITE OPEN_PAREN expressions write_comp CLOSE_PAREN
    (55) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE g_else_quad block end_if
    (56) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (57) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN DO block
    (58) condition -> . FOR ids ASSIGN expressions TO expressions DO block
    (62) return -> . RETURN OPEN_PAREN exp CLOSE_PAREN
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN
    (108) empty -> .
    (35) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (36) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (37) ids -> . ID

    READ            shift and go to state 55
    WRITE           shift and go to state 56
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    FOR             shift and go to state 59
    RETURN          shift and go to state 60
    ID              shift and go to state 61
    CLOSE_BRACES    reduce using rule 108 (empty -> .)

    read                           shift and go to state 48
    statements                     shift and go to state 93
    assignment                     shift and go to state 47
    write                          shift and go to state 49
    condition                      shift and go to state 50
    return                         shift and go to state 51
    func_call                      shift and go to state 52
    empty                          shift and go to state 53
    ids                            shift and go to state 54

state 71

    (40) statements -> write SEMICOLON . statements
    (38) statements -> . assignment SEMICOLON statements
    (39) statements -> . read SEMICOLON statements
    (40) statements -> . write SEMICOLON statements
    (41) statements -> . condition statements
    (42) statements -> . return SEMICOLON statements
    (43) statements -> . func_call SEMICOLON statements
    (44) statements -> . empty
    (45) assignment -> . ids ASSIGN expressions
    (46) read -> . READ OPEN_PAREN ids read_comp CLOSE_PAREN
    (49) write -> . WRITE OPEN_PAREN CT_STRING write_comp CLOSE_PAREN
    (50) write -> . WRITE OPEN_PAREN expressions write_comp CLOSE_PAREN
    (55) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE g_else_quad block end_if
    (56) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (57) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN DO block
    (58) condition -> . FOR ids ASSIGN expressions TO expressions DO block
    (62) return -> . RETURN OPEN_PAREN exp CLOSE_PAREN
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN
    (108) empty -> .
    (35) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (36) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (37) ids -> . ID

    READ            shift and go to state 55
    WRITE           shift and go to state 56
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    FOR             shift and go to state 59
    RETURN          shift and go to state 60
    ID              shift and go to state 61
    CLOSE_BRACES    reduce using rule 108 (empty -> .)

    write                          shift and go to state 49
    statements                     shift and go to state 94
    assignment                     shift and go to state 47
    read                           shift and go to state 48
    condition                      shift and go to state 50
    return                         shift and go to state 51
    func_call                      shift and go to state 52
    empty                          shift and go to state 53
    ids                            shift and go to state 54

state 72

    (41) statements -> condition statements .

    CLOSE_BRACES    reduce using rule 41 (statements -> condition statements .)


state 73

    (42) statements -> return SEMICOLON . statements
    (38) statements -> . assignment SEMICOLON statements
    (39) statements -> . read SEMICOLON statements
    (40) statements -> . write SEMICOLON statements
    (41) statements -> . condition statements
    (42) statements -> . return SEMICOLON statements
    (43) statements -> . func_call SEMICOLON statements
    (44) statements -> . empty
    (45) assignment -> . ids ASSIGN expressions
    (46) read -> . READ OPEN_PAREN ids read_comp CLOSE_PAREN
    (49) write -> . WRITE OPEN_PAREN CT_STRING write_comp CLOSE_PAREN
    (50) write -> . WRITE OPEN_PAREN expressions write_comp CLOSE_PAREN
    (55) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE g_else_quad block end_if
    (56) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (57) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN DO block
    (58) condition -> . FOR ids ASSIGN expressions TO expressions DO block
    (62) return -> . RETURN OPEN_PAREN exp CLOSE_PAREN
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN
    (108) empty -> .
    (35) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (36) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (37) ids -> . ID

    READ            shift and go to state 55
    WRITE           shift and go to state 56
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    FOR             shift and go to state 59
    RETURN          shift and go to state 60
    ID              shift and go to state 61
    CLOSE_BRACES    reduce using rule 108 (empty -> .)

    return                         shift and go to state 51
    statements                     shift and go to state 95
    assignment                     shift and go to state 47
    read                           shift and go to state 48
    write                          shift and go to state 49
    condition                      shift and go to state 50
    func_call                      shift and go to state 52
    empty                          shift and go to state 53
    ids                            shift and go to state 54

state 74

    (43) statements -> func_call SEMICOLON . statements
    (38) statements -> . assignment SEMICOLON statements
    (39) statements -> . read SEMICOLON statements
    (40) statements -> . write SEMICOLON statements
    (41) statements -> . condition statements
    (42) statements -> . return SEMICOLON statements
    (43) statements -> . func_call SEMICOLON statements
    (44) statements -> . empty
    (45) assignment -> . ids ASSIGN expressions
    (46) read -> . READ OPEN_PAREN ids read_comp CLOSE_PAREN
    (49) write -> . WRITE OPEN_PAREN CT_STRING write_comp CLOSE_PAREN
    (50) write -> . WRITE OPEN_PAREN expressions write_comp CLOSE_PAREN
    (55) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE g_else_quad block end_if
    (56) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (57) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN DO block
    (58) condition -> . FOR ids ASSIGN expressions TO expressions DO block
    (62) return -> . RETURN OPEN_PAREN exp CLOSE_PAREN
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN
    (108) empty -> .
    (35) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (36) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (37) ids -> . ID

    READ            shift and go to state 55
    WRITE           shift and go to state 56
    IF              shift and go to state 57
    WHILE           shift and go to state 58
    FOR             shift and go to state 59
    RETURN          shift and go to state 60
    ID              shift and go to state 61
    CLOSE_BRACES    reduce using rule 108 (empty -> .)

    func_call                      shift and go to state 52
    statements                     shift and go to state 96
    assignment                     shift and go to state 47
    read                           shift and go to state 48
    write                          shift and go to state 49
    condition                      shift and go to state 50
    return                         shift and go to state 51
    empty                          shift and go to state 53
    ids                            shift and go to state 54

state 75

    (45) assignment -> ids ASSIGN . expressions
    (67) expressions -> . expressions_comp
    (68) expressions_comp -> . expression_comp_2
    (69) expressions_comp -> . expression_comp_2 OR expressions_comp
    (70) expression_comp_2 -> . expression_comp_3
    (71) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (72) expression_comp_3 -> . exp
    (73) expression_comp_3 -> . exp expressions_op exp
    (80) exp -> . term g_quad_exp_as
    (81) exp -> . term g_quad_exp_as exp_comp
    (85) term -> . factor g_quad_exp_md
    (86) term -> . factor g_quad_exp_md term_comp
    (91) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (92) factor -> . variable
    (93) factor -> . func_call
    (94) factor -> . CT_INT add_ct_int
    (95) factor -> . CT_FLOAT add_ct_float
    (96) factor -> . CT_CHAR add_ct_char
    (104) variable -> . ID add_id
    (105) variable -> . ID dim
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 104
    CT_INT          shift and go to state 107
    CT_FLOAT        shift and go to state 108
    CT_CHAR         shift and go to state 109
    ID              shift and go to state 110

    expressions                    shift and go to state 97
    expressions_comp               shift and go to state 98
    expression_comp_2              shift and go to state 99
    expression_comp_3              shift and go to state 100
    exp                            shift and go to state 101
    term                           shift and go to state 102
    factor                         shift and go to state 103
    variable                       shift and go to state 105
    func_call                      shift and go to state 106

state 76

    (46) read -> READ OPEN_PAREN . ids read_comp CLOSE_PAREN
    (35) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (36) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (37) ids -> . ID

    ID              shift and go to state 81

    ids                            shift and go to state 111

state 77

    (49) write -> WRITE OPEN_PAREN . CT_STRING write_comp CLOSE_PAREN
    (50) write -> WRITE OPEN_PAREN . expressions write_comp CLOSE_PAREN
    (67) expressions -> . expressions_comp
    (68) expressions_comp -> . expression_comp_2
    (69) expressions_comp -> . expression_comp_2 OR expressions_comp
    (70) expression_comp_2 -> . expression_comp_3
    (71) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (72) expression_comp_3 -> . exp
    (73) expression_comp_3 -> . exp expressions_op exp
    (80) exp -> . term g_quad_exp_as
    (81) exp -> . term g_quad_exp_as exp_comp
    (85) term -> . factor g_quad_exp_md
    (86) term -> . factor g_quad_exp_md term_comp
    (91) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (92) factor -> . variable
    (93) factor -> . func_call
    (94) factor -> . CT_INT add_ct_int
    (95) factor -> . CT_FLOAT add_ct_float
    (96) factor -> . CT_CHAR add_ct_char
    (104) variable -> . ID add_id
    (105) variable -> . ID dim
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    CT_STRING       shift and go to state 112
    OPEN_PAREN      shift and go to state 104
    CT_INT          shift and go to state 107
    CT_FLOAT        shift and go to state 108
    CT_CHAR         shift and go to state 109
    ID              shift and go to state 110

    expressions                    shift and go to state 113
    expressions_comp               shift and go to state 98
    expression_comp_2              shift and go to state 99
    expression_comp_3              shift and go to state 100
    exp                            shift and go to state 101
    term                           shift and go to state 102
    factor                         shift and go to state 103
    variable                       shift and go to state 105
    func_call                      shift and go to state 106

state 78

    (55) condition -> IF OPEN_PAREN . expressions CLOSE_PAREN THEN block ELSE g_else_quad block end_if
    (56) condition -> IF OPEN_PAREN . expressions CLOSE_PAREN g_if_quad THEN block end_if
    (67) expressions -> . expressions_comp
    (68) expressions_comp -> . expression_comp_2
    (69) expressions_comp -> . expression_comp_2 OR expressions_comp
    (70) expression_comp_2 -> . expression_comp_3
    (71) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (72) expression_comp_3 -> . exp
    (73) expression_comp_3 -> . exp expressions_op exp
    (80) exp -> . term g_quad_exp_as
    (81) exp -> . term g_quad_exp_as exp_comp
    (85) term -> . factor g_quad_exp_md
    (86) term -> . factor g_quad_exp_md term_comp
    (91) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (92) factor -> . variable
    (93) factor -> . func_call
    (94) factor -> . CT_INT add_ct_int
    (95) factor -> . CT_FLOAT add_ct_float
    (96) factor -> . CT_CHAR add_ct_char
    (104) variable -> . ID add_id
    (105) variable -> . ID dim
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 104
    CT_INT          shift and go to state 107
    CT_FLOAT        shift and go to state 108
    CT_CHAR         shift and go to state 109
    ID              shift and go to state 110

    expressions                    shift and go to state 114
    expressions_comp               shift and go to state 98
    expression_comp_2              shift and go to state 99
    expression_comp_3              shift and go to state 100
    exp                            shift and go to state 101
    term                           shift and go to state 102
    factor                         shift and go to state 103
    variable                       shift and go to state 105
    func_call                      shift and go to state 106

state 79

    (57) condition -> WHILE while_jump . OPEN_PAREN expressions CLOSE_PAREN DO block

    OPEN_PAREN      shift and go to state 115


state 80

    (58) condition -> FOR ids . ASSIGN expressions TO expressions DO block

    ASSIGN          shift and go to state 116


state 81

    (35) ids -> ID . OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (36) ids -> ID . OPEN_BRACKETS exp CLOSE_BRACKETS
    (37) ids -> ID .

    OPEN_BRACKETS   shift and go to state 84
    ASSIGN          reduce using rule 37 (ids -> ID .)
    COMMA           reduce using rule 37 (ids -> ID .)
    CLOSE_PAREN     reduce using rule 37 (ids -> ID .)


state 82

    (62) return -> RETURN OPEN_PAREN . exp CLOSE_PAREN
    (80) exp -> . term g_quad_exp_as
    (81) exp -> . term g_quad_exp_as exp_comp
    (85) term -> . factor g_quad_exp_md
    (86) term -> . factor g_quad_exp_md term_comp
    (91) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (92) factor -> . variable
    (93) factor -> . func_call
    (94) factor -> . CT_INT add_ct_int
    (95) factor -> . CT_FLOAT add_ct_float
    (96) factor -> . CT_CHAR add_ct_char
    (104) variable -> . ID add_id
    (105) variable -> . ID dim
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 104
    CT_INT          shift and go to state 107
    CT_FLOAT        shift and go to state 108
    CT_CHAR         shift and go to state 109
    ID              shift and go to state 110

    exp                            shift and go to state 117
    term                           shift and go to state 102
    factor                         shift and go to state 103
    variable                       shift and go to state 105
    func_call                      shift and go to state 106

state 83

    (63) func_call -> ID OPEN_PAREN . func_call_comp CLOSE_PAREN
    (64) func_call_comp -> . expressions func_call_comp
    (65) func_call_comp -> . COMMA expressions func_call_comp
    (66) func_call_comp -> . empty
    (67) expressions -> . expressions_comp
    (108) empty -> .
    (68) expressions_comp -> . expression_comp_2
    (69) expressions_comp -> . expression_comp_2 OR expressions_comp
    (70) expression_comp_2 -> . expression_comp_3
    (71) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (72) expression_comp_3 -> . exp
    (73) expression_comp_3 -> . exp expressions_op exp
    (80) exp -> . term g_quad_exp_as
    (81) exp -> . term g_quad_exp_as exp_comp
    (85) term -> . factor g_quad_exp_md
    (86) term -> . factor g_quad_exp_md term_comp
    (91) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (92) factor -> . variable
    (93) factor -> . func_call
    (94) factor -> . CT_INT add_ct_int
    (95) factor -> . CT_FLOAT add_ct_float
    (96) factor -> . CT_CHAR add_ct_char
    (104) variable -> . ID add_id
    (105) variable -> . ID dim
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    COMMA           shift and go to state 120
    CLOSE_PAREN     reduce using rule 108 (empty -> .)
    OPEN_PAREN      shift and go to state 104
    CT_INT          shift and go to state 107
    CT_FLOAT        shift and go to state 108
    CT_CHAR         shift and go to state 109
    ID              shift and go to state 110

    func_call_comp                 shift and go to state 118
    expressions                    shift and go to state 119
    empty                          shift and go to state 121
    expressions_comp               shift and go to state 98
    expression_comp_2              shift and go to state 99
    expression_comp_3              shift and go to state 100
    exp                            shift and go to state 101
    term                           shift and go to state 102
    factor                         shift and go to state 103
    variable                       shift and go to state 105
    func_call                      shift and go to state 106

state 84

    (35) ids -> ID OPEN_BRACKETS . exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (36) ids -> ID OPEN_BRACKETS . exp CLOSE_BRACKETS
    (80) exp -> . term g_quad_exp_as
    (81) exp -> . term g_quad_exp_as exp_comp
    (85) term -> . factor g_quad_exp_md
    (86) term -> . factor g_quad_exp_md term_comp
    (91) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (92) factor -> . variable
    (93) factor -> . func_call
    (94) factor -> . CT_INT add_ct_int
    (95) factor -> . CT_FLOAT add_ct_float
    (96) factor -> . CT_CHAR add_ct_char
    (104) variable -> . ID add_id
    (105) variable -> . ID dim
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 104
    CT_INT          shift and go to state 107
    CT_FLOAT        shift and go to state 108
    CT_CHAR         shift and go to state 109
    ID              shift and go to state 110

    exp                            shift and go to state 122
    term                           shift and go to state 102
    factor                         shift and go to state 103
    variable                       shift and go to state 105
    func_call                      shift and go to state 106

state 85

    (5) funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN . vars block
    (19) vars -> . VARS var_comp
    (20) vars -> . empty
    (108) empty -> .

    VARS            shift and go to state 7
    OPEN_BRACES     reduce using rule 108 (empty -> .)

    vars                           shift and go to state 123
    empty                          shift and go to state 8

state 86

    (9) funcs_params -> var_type variable_params . funcs_params_comp
    (11) funcs_params_comp -> . COMMA var_type variable_params funcs_params_comp
    (12) funcs_params_comp -> . empty
    (108) empty -> .

    COMMA           shift and go to state 125
    CLOSE_PAREN     reduce using rule 108 (empty -> .)

    funcs_params_comp              shift and go to state 124
    empty                          shift and go to state 126

state 87

    (102) variable_params -> ID .
    (103) variable_params -> ID . dim
    (107) dim -> . OPEN_BRACKETS exp CLOSE_BRACKETS

    COMMA           reduce using rule 102 (variable_params -> ID .)
    CLOSE_PAREN     reduce using rule 102 (variable_params -> ID .)
    OPEN_BRACKETS   shift and go to state 128

    dim                            shift and go to state 127

state 88

    (31) var_module_trans -> SEMICOLON var_type MODULE funcs_comp .

    VOID            reduce using rule 31 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)
    INT             reduce using rule 31 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)
    FLOAT           reduce using rule 31 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)
    CHAR            reduce using rule 31 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)
    MAIN            reduce using rule 31 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)
    OPEN_BRACES     reduce using rule 31 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)


state 89

    (8) funcs_comp -> ID . add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block
    (7) add_module -> .

    OPEN_PAREN      reduce using rule 7 (add_module -> .)

    add_module                     shift and go to state 129

state 90

    (27) var_comp_recursive -> var_type ids_dec var_comp_2 . var_comp_final
    (28) var_comp_recursive -> var_type ids_dec var_comp_2 . SEMICOLON var_comp_recursive
    (29) var_comp_final -> . SEMICOLON
    (30) var_comp_final -> . var_module_trans
    (31) var_module_trans -> . SEMICOLON var_type MODULE funcs_comp

    SEMICOLON       shift and go to state 131

    var_comp_final                 shift and go to state 130
    var_module_trans               shift and go to state 35

state 91

    (32) ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT . CLOSE_BRACKETS

    CLOSE_BRACKETS  shift and go to state 132


state 92

    (38) statements -> assignment SEMICOLON statements .

    CLOSE_BRACES    reduce using rule 38 (statements -> assignment SEMICOLON statements .)


state 93

    (39) statements -> read SEMICOLON statements .

    CLOSE_BRACES    reduce using rule 39 (statements -> read SEMICOLON statements .)


state 94

    (40) statements -> write SEMICOLON statements .

    CLOSE_BRACES    reduce using rule 40 (statements -> write SEMICOLON statements .)


state 95

    (42) statements -> return SEMICOLON statements .

    CLOSE_BRACES    reduce using rule 42 (statements -> return SEMICOLON statements .)


state 96

    (43) statements -> func_call SEMICOLON statements .

    CLOSE_BRACES    reduce using rule 43 (statements -> func_call SEMICOLON statements .)


state 97

    (45) assignment -> ids ASSIGN expressions .

    SEMICOLON       reduce using rule 45 (assignment -> ids ASSIGN expressions .)


state 98

    (67) expressions -> expressions_comp .

    SEMICOLON       reduce using rule 67 (expressions -> expressions_comp .)
    COMMA           reduce using rule 67 (expressions -> expressions_comp .)
    CLOSE_PAREN     reduce using rule 67 (expressions -> expressions_comp .)
    OPEN_PAREN      reduce using rule 67 (expressions -> expressions_comp .)
    CT_INT          reduce using rule 67 (expressions -> expressions_comp .)
    CT_FLOAT        reduce using rule 67 (expressions -> expressions_comp .)
    CT_CHAR         reduce using rule 67 (expressions -> expressions_comp .)
    ID              reduce using rule 67 (expressions -> expressions_comp .)
    TO              reduce using rule 67 (expressions -> expressions_comp .)
    DO              reduce using rule 67 (expressions -> expressions_comp .)


state 99

    (68) expressions_comp -> expression_comp_2 .
    (69) expressions_comp -> expression_comp_2 . OR expressions_comp

    SEMICOLON       reduce using rule 68 (expressions_comp -> expression_comp_2 .)
    COMMA           reduce using rule 68 (expressions_comp -> expression_comp_2 .)
    CLOSE_PAREN     reduce using rule 68 (expressions_comp -> expression_comp_2 .)
    OPEN_PAREN      reduce using rule 68 (expressions_comp -> expression_comp_2 .)
    CT_INT          reduce using rule 68 (expressions_comp -> expression_comp_2 .)
    CT_FLOAT        reduce using rule 68 (expressions_comp -> expression_comp_2 .)
    CT_CHAR         reduce using rule 68 (expressions_comp -> expression_comp_2 .)
    ID              reduce using rule 68 (expressions_comp -> expression_comp_2 .)
    TO              reduce using rule 68 (expressions_comp -> expression_comp_2 .)
    DO              reduce using rule 68 (expressions_comp -> expression_comp_2 .)
    OR              shift and go to state 133


state 100

    (70) expression_comp_2 -> expression_comp_3 .
    (71) expression_comp_2 -> expression_comp_3 . AND expression_comp_2

    OR              reduce using rule 70 (expression_comp_2 -> expression_comp_3 .)
    SEMICOLON       reduce using rule 70 (expression_comp_2 -> expression_comp_3 .)
    COMMA           reduce using rule 70 (expression_comp_2 -> expression_comp_3 .)
    CLOSE_PAREN     reduce using rule 70 (expression_comp_2 -> expression_comp_3 .)
    OPEN_PAREN      reduce using rule 70 (expression_comp_2 -> expression_comp_3 .)
    CT_INT          reduce using rule 70 (expression_comp_2 -> expression_comp_3 .)
    CT_FLOAT        reduce using rule 70 (expression_comp_2 -> expression_comp_3 .)
    CT_CHAR         reduce using rule 70 (expression_comp_2 -> expression_comp_3 .)
    ID              reduce using rule 70 (expression_comp_2 -> expression_comp_3 .)
    TO              reduce using rule 70 (expression_comp_2 -> expression_comp_3 .)
    DO              reduce using rule 70 (expression_comp_2 -> expression_comp_3 .)
    AND             shift and go to state 134


state 101

    (72) expression_comp_3 -> exp .
    (73) expression_comp_3 -> exp . expressions_op exp
    (74) expressions_op -> . LESS_THAN
    (75) expressions_op -> . LESS_THAN_EQUAL
    (76) expressions_op -> . MORE_THAN
    (77) expressions_op -> . MORE_THAN_EQUAL
    (78) expressions_op -> . EQUALS
    (79) expressions_op -> . NOT_EQUALS

    AND             reduce using rule 72 (expression_comp_3 -> exp .)
    OR              reduce using rule 72 (expression_comp_3 -> exp .)
    SEMICOLON       reduce using rule 72 (expression_comp_3 -> exp .)
    COMMA           reduce using rule 72 (expression_comp_3 -> exp .)
    CLOSE_PAREN     reduce using rule 72 (expression_comp_3 -> exp .)
    OPEN_PAREN      reduce using rule 72 (expression_comp_3 -> exp .)
    CT_INT          reduce using rule 72 (expression_comp_3 -> exp .)
    CT_FLOAT        reduce using rule 72 (expression_comp_3 -> exp .)
    CT_CHAR         reduce using rule 72 (expression_comp_3 -> exp .)
    ID              reduce using rule 72 (expression_comp_3 -> exp .)
    TO              reduce using rule 72 (expression_comp_3 -> exp .)
    DO              reduce using rule 72 (expression_comp_3 -> exp .)
    LESS_THAN       shift and go to state 136
    LESS_THAN_EQUAL shift and go to state 137
    MORE_THAN       shift and go to state 138
    MORE_THAN_EQUAL shift and go to state 139
    EQUALS          shift and go to state 140
    NOT_EQUALS      shift and go to state 141

    expressions_op                 shift and go to state 135

state 102

    (80) exp -> term . g_quad_exp_as
    (81) exp -> term . g_quad_exp_as exp_comp
    (82) g_quad_exp_as -> .

    PLUS            reduce using rule 82 (g_quad_exp_as -> .)
    MINUS           reduce using rule 82 (g_quad_exp_as -> .)
    LESS_THAN       reduce using rule 82 (g_quad_exp_as -> .)
    LESS_THAN_EQUAL reduce using rule 82 (g_quad_exp_as -> .)
    MORE_THAN       reduce using rule 82 (g_quad_exp_as -> .)
    MORE_THAN_EQUAL reduce using rule 82 (g_quad_exp_as -> .)
    EQUALS          reduce using rule 82 (g_quad_exp_as -> .)
    NOT_EQUALS      reduce using rule 82 (g_quad_exp_as -> .)
    AND             reduce using rule 82 (g_quad_exp_as -> .)
    OR              reduce using rule 82 (g_quad_exp_as -> .)
    SEMICOLON       reduce using rule 82 (g_quad_exp_as -> .)
    COMMA           reduce using rule 82 (g_quad_exp_as -> .)
    CLOSE_PAREN     reduce using rule 82 (g_quad_exp_as -> .)
    OPEN_PAREN      reduce using rule 82 (g_quad_exp_as -> .)
    CT_INT          reduce using rule 82 (g_quad_exp_as -> .)
    CT_FLOAT        reduce using rule 82 (g_quad_exp_as -> .)
    CT_CHAR         reduce using rule 82 (g_quad_exp_as -> .)
    ID              reduce using rule 82 (g_quad_exp_as -> .)
    CLOSE_BRACKETS  reduce using rule 82 (g_quad_exp_as -> .)
    TO              reduce using rule 82 (g_quad_exp_as -> .)
    DO              reduce using rule 82 (g_quad_exp_as -> .)

    g_quad_exp_as                  shift and go to state 142

state 103

    (85) term -> factor . g_quad_exp_md
    (86) term -> factor . g_quad_exp_md term_comp
    (87) g_quad_exp_md -> .

    MULTIPLIES      reduce using rule 87 (g_quad_exp_md -> .)
    DIVIDE          reduce using rule 87 (g_quad_exp_md -> .)
    PLUS            reduce using rule 87 (g_quad_exp_md -> .)
    MINUS           reduce using rule 87 (g_quad_exp_md -> .)
    LESS_THAN       reduce using rule 87 (g_quad_exp_md -> .)
    LESS_THAN_EQUAL reduce using rule 87 (g_quad_exp_md -> .)
    MORE_THAN       reduce using rule 87 (g_quad_exp_md -> .)
    MORE_THAN_EQUAL reduce using rule 87 (g_quad_exp_md -> .)
    EQUALS          reduce using rule 87 (g_quad_exp_md -> .)
    NOT_EQUALS      reduce using rule 87 (g_quad_exp_md -> .)
    AND             reduce using rule 87 (g_quad_exp_md -> .)
    OR              reduce using rule 87 (g_quad_exp_md -> .)
    SEMICOLON       reduce using rule 87 (g_quad_exp_md -> .)
    COMMA           reduce using rule 87 (g_quad_exp_md -> .)
    CLOSE_PAREN     reduce using rule 87 (g_quad_exp_md -> .)
    OPEN_PAREN      reduce using rule 87 (g_quad_exp_md -> .)
    CT_INT          reduce using rule 87 (g_quad_exp_md -> .)
    CT_FLOAT        reduce using rule 87 (g_quad_exp_md -> .)
    CT_CHAR         reduce using rule 87 (g_quad_exp_md -> .)
    ID              reduce using rule 87 (g_quad_exp_md -> .)
    CLOSE_BRACKETS  reduce using rule 87 (g_quad_exp_md -> .)
    TO              reduce using rule 87 (g_quad_exp_md -> .)
    DO              reduce using rule 87 (g_quad_exp_md -> .)

    g_quad_exp_md                  shift and go to state 143

state 104

    (91) factor -> OPEN_PAREN . add_fake expressions CLOSE_PAREN rem_fake
    (97) add_fake -> .

    OPEN_PAREN      reduce using rule 97 (add_fake -> .)
    CT_INT          reduce using rule 97 (add_fake -> .)
    CT_FLOAT        reduce using rule 97 (add_fake -> .)
    CT_CHAR         reduce using rule 97 (add_fake -> .)
    ID              reduce using rule 97 (add_fake -> .)

    add_fake                       shift and go to state 144

state 105

    (92) factor -> variable .

    MULTIPLIES      reduce using rule 92 (factor -> variable .)
    DIVIDE          reduce using rule 92 (factor -> variable .)
    PLUS            reduce using rule 92 (factor -> variable .)
    MINUS           reduce using rule 92 (factor -> variable .)
    LESS_THAN       reduce using rule 92 (factor -> variable .)
    LESS_THAN_EQUAL reduce using rule 92 (factor -> variable .)
    MORE_THAN       reduce using rule 92 (factor -> variable .)
    MORE_THAN_EQUAL reduce using rule 92 (factor -> variable .)
    EQUALS          reduce using rule 92 (factor -> variable .)
    NOT_EQUALS      reduce using rule 92 (factor -> variable .)
    AND             reduce using rule 92 (factor -> variable .)
    OR              reduce using rule 92 (factor -> variable .)
    SEMICOLON       reduce using rule 92 (factor -> variable .)
    COMMA           reduce using rule 92 (factor -> variable .)
    CLOSE_PAREN     reduce using rule 92 (factor -> variable .)
    OPEN_PAREN      reduce using rule 92 (factor -> variable .)
    CT_INT          reduce using rule 92 (factor -> variable .)
    CT_FLOAT        reduce using rule 92 (factor -> variable .)
    CT_CHAR         reduce using rule 92 (factor -> variable .)
    ID              reduce using rule 92 (factor -> variable .)
    CLOSE_BRACKETS  reduce using rule 92 (factor -> variable .)
    TO              reduce using rule 92 (factor -> variable .)
    DO              reduce using rule 92 (factor -> variable .)


state 106

    (93) factor -> func_call .

    MULTIPLIES      reduce using rule 93 (factor -> func_call .)
    DIVIDE          reduce using rule 93 (factor -> func_call .)
    PLUS            reduce using rule 93 (factor -> func_call .)
    MINUS           reduce using rule 93 (factor -> func_call .)
    LESS_THAN       reduce using rule 93 (factor -> func_call .)
    LESS_THAN_EQUAL reduce using rule 93 (factor -> func_call .)
    MORE_THAN       reduce using rule 93 (factor -> func_call .)
    MORE_THAN_EQUAL reduce using rule 93 (factor -> func_call .)
    EQUALS          reduce using rule 93 (factor -> func_call .)
    NOT_EQUALS      reduce using rule 93 (factor -> func_call .)
    AND             reduce using rule 93 (factor -> func_call .)
    OR              reduce using rule 93 (factor -> func_call .)
    SEMICOLON       reduce using rule 93 (factor -> func_call .)
    COMMA           reduce using rule 93 (factor -> func_call .)
    CLOSE_PAREN     reduce using rule 93 (factor -> func_call .)
    OPEN_PAREN      reduce using rule 93 (factor -> func_call .)
    CT_INT          reduce using rule 93 (factor -> func_call .)
    CT_FLOAT        reduce using rule 93 (factor -> func_call .)
    CT_CHAR         reduce using rule 93 (factor -> func_call .)
    ID              reduce using rule 93 (factor -> func_call .)
    CLOSE_BRACKETS  reduce using rule 93 (factor -> func_call .)
    TO              reduce using rule 93 (factor -> func_call .)
    DO              reduce using rule 93 (factor -> func_call .)


state 107

    (94) factor -> CT_INT . add_ct_int
    (99) add_ct_int -> .

    MULTIPLIES      reduce using rule 99 (add_ct_int -> .)
    DIVIDE          reduce using rule 99 (add_ct_int -> .)
    PLUS            reduce using rule 99 (add_ct_int -> .)
    MINUS           reduce using rule 99 (add_ct_int -> .)
    LESS_THAN       reduce using rule 99 (add_ct_int -> .)
    LESS_THAN_EQUAL reduce using rule 99 (add_ct_int -> .)
    MORE_THAN       reduce using rule 99 (add_ct_int -> .)
    MORE_THAN_EQUAL reduce using rule 99 (add_ct_int -> .)
    EQUALS          reduce using rule 99 (add_ct_int -> .)
    NOT_EQUALS      reduce using rule 99 (add_ct_int -> .)
    AND             reduce using rule 99 (add_ct_int -> .)
    OR              reduce using rule 99 (add_ct_int -> .)
    SEMICOLON       reduce using rule 99 (add_ct_int -> .)
    COMMA           reduce using rule 99 (add_ct_int -> .)
    CLOSE_PAREN     reduce using rule 99 (add_ct_int -> .)
    OPEN_PAREN      reduce using rule 99 (add_ct_int -> .)
    CT_INT          reduce using rule 99 (add_ct_int -> .)
    CT_FLOAT        reduce using rule 99 (add_ct_int -> .)
    CT_CHAR         reduce using rule 99 (add_ct_int -> .)
    ID              reduce using rule 99 (add_ct_int -> .)
    CLOSE_BRACKETS  reduce using rule 99 (add_ct_int -> .)
    TO              reduce using rule 99 (add_ct_int -> .)
    DO              reduce using rule 99 (add_ct_int -> .)

    add_ct_int                     shift and go to state 145

state 108

    (95) factor -> CT_FLOAT . add_ct_float
    (100) add_ct_float -> .

    MULTIPLIES      reduce using rule 100 (add_ct_float -> .)
    DIVIDE          reduce using rule 100 (add_ct_float -> .)
    PLUS            reduce using rule 100 (add_ct_float -> .)
    MINUS           reduce using rule 100 (add_ct_float -> .)
    LESS_THAN       reduce using rule 100 (add_ct_float -> .)
    LESS_THAN_EQUAL reduce using rule 100 (add_ct_float -> .)
    MORE_THAN       reduce using rule 100 (add_ct_float -> .)
    MORE_THAN_EQUAL reduce using rule 100 (add_ct_float -> .)
    EQUALS          reduce using rule 100 (add_ct_float -> .)
    NOT_EQUALS      reduce using rule 100 (add_ct_float -> .)
    AND             reduce using rule 100 (add_ct_float -> .)
    OR              reduce using rule 100 (add_ct_float -> .)
    SEMICOLON       reduce using rule 100 (add_ct_float -> .)
    COMMA           reduce using rule 100 (add_ct_float -> .)
    CLOSE_PAREN     reduce using rule 100 (add_ct_float -> .)
    OPEN_PAREN      reduce using rule 100 (add_ct_float -> .)
    CT_INT          reduce using rule 100 (add_ct_float -> .)
    CT_FLOAT        reduce using rule 100 (add_ct_float -> .)
    CT_CHAR         reduce using rule 100 (add_ct_float -> .)
    ID              reduce using rule 100 (add_ct_float -> .)
    CLOSE_BRACKETS  reduce using rule 100 (add_ct_float -> .)
    TO              reduce using rule 100 (add_ct_float -> .)
    DO              reduce using rule 100 (add_ct_float -> .)

    add_ct_float                   shift and go to state 146

state 109

    (96) factor -> CT_CHAR . add_ct_char
    (101) add_ct_char -> .

    MULTIPLIES      reduce using rule 101 (add_ct_char -> .)
    DIVIDE          reduce using rule 101 (add_ct_char -> .)
    PLUS            reduce using rule 101 (add_ct_char -> .)
    MINUS           reduce using rule 101 (add_ct_char -> .)
    LESS_THAN       reduce using rule 101 (add_ct_char -> .)
    LESS_THAN_EQUAL reduce using rule 101 (add_ct_char -> .)
    MORE_THAN       reduce using rule 101 (add_ct_char -> .)
    MORE_THAN_EQUAL reduce using rule 101 (add_ct_char -> .)
    EQUALS          reduce using rule 101 (add_ct_char -> .)
    NOT_EQUALS      reduce using rule 101 (add_ct_char -> .)
    AND             reduce using rule 101 (add_ct_char -> .)
    OR              reduce using rule 101 (add_ct_char -> .)
    SEMICOLON       reduce using rule 101 (add_ct_char -> .)
    COMMA           reduce using rule 101 (add_ct_char -> .)
    CLOSE_PAREN     reduce using rule 101 (add_ct_char -> .)
    OPEN_PAREN      reduce using rule 101 (add_ct_char -> .)
    CT_INT          reduce using rule 101 (add_ct_char -> .)
    CT_FLOAT        reduce using rule 101 (add_ct_char -> .)
    CT_CHAR         reduce using rule 101 (add_ct_char -> .)
    ID              reduce using rule 101 (add_ct_char -> .)
    CLOSE_BRACKETS  reduce using rule 101 (add_ct_char -> .)
    TO              reduce using rule 101 (add_ct_char -> .)
    DO              reduce using rule 101 (add_ct_char -> .)

    add_ct_char                    shift and go to state 147

state 110

    (104) variable -> ID . add_id
    (105) variable -> ID . dim
    (63) func_call -> ID . OPEN_PAREN func_call_comp CLOSE_PAREN
    (106) add_id -> .
    (107) dim -> . OPEN_BRACKETS exp CLOSE_BRACKETS

  ! shift/reduce conflict for OPEN_PAREN resolved as shift
    OPEN_PAREN      shift and go to state 83
    MULTIPLIES      reduce using rule 106 (add_id -> .)
    DIVIDE          reduce using rule 106 (add_id -> .)
    PLUS            reduce using rule 106 (add_id -> .)
    MINUS           reduce using rule 106 (add_id -> .)
    LESS_THAN       reduce using rule 106 (add_id -> .)
    LESS_THAN_EQUAL reduce using rule 106 (add_id -> .)
    MORE_THAN       reduce using rule 106 (add_id -> .)
    MORE_THAN_EQUAL reduce using rule 106 (add_id -> .)
    EQUALS          reduce using rule 106 (add_id -> .)
    NOT_EQUALS      reduce using rule 106 (add_id -> .)
    AND             reduce using rule 106 (add_id -> .)
    OR              reduce using rule 106 (add_id -> .)
    SEMICOLON       reduce using rule 106 (add_id -> .)
    COMMA           reduce using rule 106 (add_id -> .)
    CLOSE_PAREN     reduce using rule 106 (add_id -> .)
    CT_INT          reduce using rule 106 (add_id -> .)
    CT_FLOAT        reduce using rule 106 (add_id -> .)
    CT_CHAR         reduce using rule 106 (add_id -> .)
    ID              reduce using rule 106 (add_id -> .)
    CLOSE_BRACKETS  reduce using rule 106 (add_id -> .)
    TO              reduce using rule 106 (add_id -> .)
    DO              reduce using rule 106 (add_id -> .)
    OPEN_BRACKETS   shift and go to state 128

  ! OPEN_PAREN      [ reduce using rule 106 (add_id -> .) ]

    add_id                         shift and go to state 148
    dim                            shift and go to state 149

state 111

    (46) read -> READ OPEN_PAREN ids . read_comp CLOSE_PAREN
    (47) read_comp -> . COMMA ids read_comp
    (48) read_comp -> . empty
    (108) empty -> .

    COMMA           shift and go to state 151
    CLOSE_PAREN     reduce using rule 108 (empty -> .)

    read_comp                      shift and go to state 150
    empty                          shift and go to state 152

state 112

    (49) write -> WRITE OPEN_PAREN CT_STRING . write_comp CLOSE_PAREN
    (51) write_comp -> . COMMA CT_STRING write_comp
    (52) write_comp -> . COMMA expressions write_comp
    (53) write_comp -> . empty
    (108) empty -> .

    COMMA           shift and go to state 154
    CLOSE_PAREN     reduce using rule 108 (empty -> .)

    write_comp                     shift and go to state 153
    empty                          shift and go to state 155

state 113

    (50) write -> WRITE OPEN_PAREN expressions . write_comp CLOSE_PAREN
    (51) write_comp -> . COMMA CT_STRING write_comp
    (52) write_comp -> . COMMA expressions write_comp
    (53) write_comp -> . empty
    (108) empty -> .

    COMMA           shift and go to state 154
    CLOSE_PAREN     reduce using rule 108 (empty -> .)

    write_comp                     shift and go to state 156
    empty                          shift and go to state 155

state 114

    (55) condition -> IF OPEN_PAREN expressions . CLOSE_PAREN THEN block ELSE g_else_quad block end_if
    (56) condition -> IF OPEN_PAREN expressions . CLOSE_PAREN g_if_quad THEN block end_if

    CLOSE_PAREN     shift and go to state 157


state 115

    (57) condition -> WHILE while_jump OPEN_PAREN . expressions CLOSE_PAREN DO block
    (67) expressions -> . expressions_comp
    (68) expressions_comp -> . expression_comp_2
    (69) expressions_comp -> . expression_comp_2 OR expressions_comp
    (70) expression_comp_2 -> . expression_comp_3
    (71) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (72) expression_comp_3 -> . exp
    (73) expression_comp_3 -> . exp expressions_op exp
    (80) exp -> . term g_quad_exp_as
    (81) exp -> . term g_quad_exp_as exp_comp
    (85) term -> . factor g_quad_exp_md
    (86) term -> . factor g_quad_exp_md term_comp
    (91) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (92) factor -> . variable
    (93) factor -> . func_call
    (94) factor -> . CT_INT add_ct_int
    (95) factor -> . CT_FLOAT add_ct_float
    (96) factor -> . CT_CHAR add_ct_char
    (104) variable -> . ID add_id
    (105) variable -> . ID dim
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 104
    CT_INT          shift and go to state 107
    CT_FLOAT        shift and go to state 108
    CT_CHAR         shift and go to state 109
    ID              shift and go to state 110

    expressions                    shift and go to state 158
    expressions_comp               shift and go to state 98
    expression_comp_2              shift and go to state 99
    expression_comp_3              shift and go to state 100
    exp                            shift and go to state 101
    term                           shift and go to state 102
    factor                         shift and go to state 103
    variable                       shift and go to state 105
    func_call                      shift and go to state 106

state 116

    (58) condition -> FOR ids ASSIGN . expressions TO expressions DO block
    (67) expressions -> . expressions_comp
    (68) expressions_comp -> . expression_comp_2
    (69) expressions_comp -> . expression_comp_2 OR expressions_comp
    (70) expression_comp_2 -> . expression_comp_3
    (71) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (72) expression_comp_3 -> . exp
    (73) expression_comp_3 -> . exp expressions_op exp
    (80) exp -> . term g_quad_exp_as
    (81) exp -> . term g_quad_exp_as exp_comp
    (85) term -> . factor g_quad_exp_md
    (86) term -> . factor g_quad_exp_md term_comp
    (91) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (92) factor -> . variable
    (93) factor -> . func_call
    (94) factor -> . CT_INT add_ct_int
    (95) factor -> . CT_FLOAT add_ct_float
    (96) factor -> . CT_CHAR add_ct_char
    (104) variable -> . ID add_id
    (105) variable -> . ID dim
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 104
    CT_INT          shift and go to state 107
    CT_FLOAT        shift and go to state 108
    CT_CHAR         shift and go to state 109
    ID              shift and go to state 110

    expressions                    shift and go to state 159
    expressions_comp               shift and go to state 98
    expression_comp_2              shift and go to state 99
    expression_comp_3              shift and go to state 100
    exp                            shift and go to state 101
    term                           shift and go to state 102
    factor                         shift and go to state 103
    variable                       shift and go to state 105
    func_call                      shift and go to state 106

state 117

    (62) return -> RETURN OPEN_PAREN exp . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 160


state 118

    (63) func_call -> ID OPEN_PAREN func_call_comp . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 161


state 119

    (64) func_call_comp -> expressions . func_call_comp
    (64) func_call_comp -> . expressions func_call_comp
    (65) func_call_comp -> . COMMA expressions func_call_comp
    (66) func_call_comp -> . empty
    (67) expressions -> . expressions_comp
    (108) empty -> .
    (68) expressions_comp -> . expression_comp_2
    (69) expressions_comp -> . expression_comp_2 OR expressions_comp
    (70) expression_comp_2 -> . expression_comp_3
    (71) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (72) expression_comp_3 -> . exp
    (73) expression_comp_3 -> . exp expressions_op exp
    (80) exp -> . term g_quad_exp_as
    (81) exp -> . term g_quad_exp_as exp_comp
    (85) term -> . factor g_quad_exp_md
    (86) term -> . factor g_quad_exp_md term_comp
    (91) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (92) factor -> . variable
    (93) factor -> . func_call
    (94) factor -> . CT_INT add_ct_int
    (95) factor -> . CT_FLOAT add_ct_float
    (96) factor -> . CT_CHAR add_ct_char
    (104) variable -> . ID add_id
    (105) variable -> . ID dim
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    COMMA           shift and go to state 120
    CLOSE_PAREN     reduce using rule 108 (empty -> .)
    OPEN_PAREN      shift and go to state 104
    CT_INT          shift and go to state 107
    CT_FLOAT        shift and go to state 108
    CT_CHAR         shift and go to state 109
    ID              shift and go to state 110

    expressions                    shift and go to state 119
    func_call_comp                 shift and go to state 162
    empty                          shift and go to state 121
    expressions_comp               shift and go to state 98
    expression_comp_2              shift and go to state 99
    expression_comp_3              shift and go to state 100
    exp                            shift and go to state 101
    term                           shift and go to state 102
    factor                         shift and go to state 103
    variable                       shift and go to state 105
    func_call                      shift and go to state 106

state 120

    (65) func_call_comp -> COMMA . expressions func_call_comp
    (67) expressions -> . expressions_comp
    (68) expressions_comp -> . expression_comp_2
    (69) expressions_comp -> . expression_comp_2 OR expressions_comp
    (70) expression_comp_2 -> . expression_comp_3
    (71) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (72) expression_comp_3 -> . exp
    (73) expression_comp_3 -> . exp expressions_op exp
    (80) exp -> . term g_quad_exp_as
    (81) exp -> . term g_quad_exp_as exp_comp
    (85) term -> . factor g_quad_exp_md
    (86) term -> . factor g_quad_exp_md term_comp
    (91) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (92) factor -> . variable
    (93) factor -> . func_call
    (94) factor -> . CT_INT add_ct_int
    (95) factor -> . CT_FLOAT add_ct_float
    (96) factor -> . CT_CHAR add_ct_char
    (104) variable -> . ID add_id
    (105) variable -> . ID dim
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 104
    CT_INT          shift and go to state 107
    CT_FLOAT        shift and go to state 108
    CT_CHAR         shift and go to state 109
    ID              shift and go to state 110

    expressions                    shift and go to state 163
    expressions_comp               shift and go to state 98
    expression_comp_2              shift and go to state 99
    expression_comp_3              shift and go to state 100
    exp                            shift and go to state 101
    term                           shift and go to state 102
    factor                         shift and go to state 103
    variable                       shift and go to state 105
    func_call                      shift and go to state 106

state 121

    (66) func_call_comp -> empty .

    CLOSE_PAREN     reduce using rule 66 (func_call_comp -> empty .)


state 122

    (35) ids -> ID OPEN_BRACKETS exp . CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (36) ids -> ID OPEN_BRACKETS exp . CLOSE_BRACKETS

    CLOSE_BRACKETS  shift and go to state 164


state 123

    (5) funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars . block
    (13) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 39

    block                          shift and go to state 165

state 124

    (9) funcs_params -> var_type variable_params funcs_params_comp .

    CLOSE_PAREN     reduce using rule 9 (funcs_params -> var_type variable_params funcs_params_comp .)


state 125

    (11) funcs_params_comp -> COMMA . var_type variable_params funcs_params_comp
    (16) var_type -> . INT
    (17) var_type -> . FLOAT
    (18) var_type -> . CHAR

    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16

    var_type                       shift and go to state 166

state 126

    (12) funcs_params_comp -> empty .

    CLOSE_PAREN     reduce using rule 12 (funcs_params_comp -> empty .)


state 127

    (103) variable_params -> ID dim .

    COMMA           reduce using rule 103 (variable_params -> ID dim .)
    CLOSE_PAREN     reduce using rule 103 (variable_params -> ID dim .)


state 128

    (107) dim -> OPEN_BRACKETS . exp CLOSE_BRACKETS
    (80) exp -> . term g_quad_exp_as
    (81) exp -> . term g_quad_exp_as exp_comp
    (85) term -> . factor g_quad_exp_md
    (86) term -> . factor g_quad_exp_md term_comp
    (91) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (92) factor -> . variable
    (93) factor -> . func_call
    (94) factor -> . CT_INT add_ct_int
    (95) factor -> . CT_FLOAT add_ct_float
    (96) factor -> . CT_CHAR add_ct_char
    (104) variable -> . ID add_id
    (105) variable -> . ID dim
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 104
    CT_INT          shift and go to state 107
    CT_FLOAT        shift and go to state 108
    CT_CHAR         shift and go to state 109
    ID              shift and go to state 110

    exp                            shift and go to state 167
    term                           shift and go to state 102
    factor                         shift and go to state 103
    variable                       shift and go to state 105
    func_call                      shift and go to state 106

state 129

    (8) funcs_comp -> ID add_module . OPEN_PAREN funcs_params CLOSE_PAREN vars block

    OPEN_PAREN      shift and go to state 168


state 130

    (27) var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .

    VOID            reduce using rule 27 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)
    INT             reduce using rule 27 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)
    FLOAT           reduce using rule 27 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)
    CHAR            reduce using rule 27 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)
    MAIN            reduce using rule 27 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)
    OPEN_BRACES     reduce using rule 27 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)


state 131

    (28) var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON . var_comp_recursive
    (29) var_comp_final -> SEMICOLON .
    (31) var_module_trans -> SEMICOLON . var_type MODULE funcs_comp
    (27) var_comp_recursive -> . var_type ids_dec var_comp_2 var_comp_final
    (28) var_comp_recursive -> . var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive
    (16) var_type -> . INT
    (17) var_type -> . FLOAT
    (18) var_type -> . CHAR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
    VOID            reduce using rule 29 (var_comp_final -> SEMICOLON .)
    MAIN            reduce using rule 29 (var_comp_final -> SEMICOLON .)
    OPEN_BRACES     reduce using rule 29 (var_comp_final -> SEMICOLON .)
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16

  ! INT             [ reduce using rule 29 (var_comp_final -> SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 29 (var_comp_final -> SEMICOLON .) ]
  ! CHAR            [ reduce using rule 29 (var_comp_final -> SEMICOLON .) ]

    var_type                       shift and go to state 41
    var_comp_recursive             shift and go to state 169

state 132

    (32) ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS .

    COMMA           reduce using rule 32 (ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS .)
    SEMICOLON       reduce using rule 32 (ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS .)


state 133

    (69) expressions_comp -> expression_comp_2 OR . expressions_comp
    (68) expressions_comp -> . expression_comp_2
    (69) expressions_comp -> . expression_comp_2 OR expressions_comp
    (70) expression_comp_2 -> . expression_comp_3
    (71) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (72) expression_comp_3 -> . exp
    (73) expression_comp_3 -> . exp expressions_op exp
    (80) exp -> . term g_quad_exp_as
    (81) exp -> . term g_quad_exp_as exp_comp
    (85) term -> . factor g_quad_exp_md
    (86) term -> . factor g_quad_exp_md term_comp
    (91) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (92) factor -> . variable
    (93) factor -> . func_call
    (94) factor -> . CT_INT add_ct_int
    (95) factor -> . CT_FLOAT add_ct_float
    (96) factor -> . CT_CHAR add_ct_char
    (104) variable -> . ID add_id
    (105) variable -> . ID dim
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 104
    CT_INT          shift and go to state 107
    CT_FLOAT        shift and go to state 108
    CT_CHAR         shift and go to state 109
    ID              shift and go to state 110

    expression_comp_2              shift and go to state 99
    expressions_comp               shift and go to state 170
    expression_comp_3              shift and go to state 100
    exp                            shift and go to state 101
    term                           shift and go to state 102
    factor                         shift and go to state 103
    variable                       shift and go to state 105
    func_call                      shift and go to state 106

state 134

    (71) expression_comp_2 -> expression_comp_3 AND . expression_comp_2
    (70) expression_comp_2 -> . expression_comp_3
    (71) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (72) expression_comp_3 -> . exp
    (73) expression_comp_3 -> . exp expressions_op exp
    (80) exp -> . term g_quad_exp_as
    (81) exp -> . term g_quad_exp_as exp_comp
    (85) term -> . factor g_quad_exp_md
    (86) term -> . factor g_quad_exp_md term_comp
    (91) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (92) factor -> . variable
    (93) factor -> . func_call
    (94) factor -> . CT_INT add_ct_int
    (95) factor -> . CT_FLOAT add_ct_float
    (96) factor -> . CT_CHAR add_ct_char
    (104) variable -> . ID add_id
    (105) variable -> . ID dim
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 104
    CT_INT          shift and go to state 107
    CT_FLOAT        shift and go to state 108
    CT_CHAR         shift and go to state 109
    ID              shift and go to state 110

    expression_comp_3              shift and go to state 100
    expression_comp_2              shift and go to state 171
    exp                            shift and go to state 101
    term                           shift and go to state 102
    factor                         shift and go to state 103
    variable                       shift and go to state 105
    func_call                      shift and go to state 106

state 135

    (73) expression_comp_3 -> exp expressions_op . exp
    (80) exp -> . term g_quad_exp_as
    (81) exp -> . term g_quad_exp_as exp_comp
    (85) term -> . factor g_quad_exp_md
    (86) term -> . factor g_quad_exp_md term_comp
    (91) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (92) factor -> . variable
    (93) factor -> . func_call
    (94) factor -> . CT_INT add_ct_int
    (95) factor -> . CT_FLOAT add_ct_float
    (96) factor -> . CT_CHAR add_ct_char
    (104) variable -> . ID add_id
    (105) variable -> . ID dim
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 104
    CT_INT          shift and go to state 107
    CT_FLOAT        shift and go to state 108
    CT_CHAR         shift and go to state 109
    ID              shift and go to state 110

    exp                            shift and go to state 172
    term                           shift and go to state 102
    factor                         shift and go to state 103
    variable                       shift and go to state 105
    func_call                      shift and go to state 106

state 136

    (74) expressions_op -> LESS_THAN .

    OPEN_PAREN      reduce using rule 74 (expressions_op -> LESS_THAN .)
    CT_INT          reduce using rule 74 (expressions_op -> LESS_THAN .)
    CT_FLOAT        reduce using rule 74 (expressions_op -> LESS_THAN .)
    CT_CHAR         reduce using rule 74 (expressions_op -> LESS_THAN .)
    ID              reduce using rule 74 (expressions_op -> LESS_THAN .)


state 137

    (75) expressions_op -> LESS_THAN_EQUAL .

    OPEN_PAREN      reduce using rule 75 (expressions_op -> LESS_THAN_EQUAL .)
    CT_INT          reduce using rule 75 (expressions_op -> LESS_THAN_EQUAL .)
    CT_FLOAT        reduce using rule 75 (expressions_op -> LESS_THAN_EQUAL .)
    CT_CHAR         reduce using rule 75 (expressions_op -> LESS_THAN_EQUAL .)
    ID              reduce using rule 75 (expressions_op -> LESS_THAN_EQUAL .)


state 138

    (76) expressions_op -> MORE_THAN .

    OPEN_PAREN      reduce using rule 76 (expressions_op -> MORE_THAN .)
    CT_INT          reduce using rule 76 (expressions_op -> MORE_THAN .)
    CT_FLOAT        reduce using rule 76 (expressions_op -> MORE_THAN .)
    CT_CHAR         reduce using rule 76 (expressions_op -> MORE_THAN .)
    ID              reduce using rule 76 (expressions_op -> MORE_THAN .)


state 139

    (77) expressions_op -> MORE_THAN_EQUAL .

    OPEN_PAREN      reduce using rule 77 (expressions_op -> MORE_THAN_EQUAL .)
    CT_INT          reduce using rule 77 (expressions_op -> MORE_THAN_EQUAL .)
    CT_FLOAT        reduce using rule 77 (expressions_op -> MORE_THAN_EQUAL .)
    CT_CHAR         reduce using rule 77 (expressions_op -> MORE_THAN_EQUAL .)
    ID              reduce using rule 77 (expressions_op -> MORE_THAN_EQUAL .)


state 140

    (78) expressions_op -> EQUALS .

    OPEN_PAREN      reduce using rule 78 (expressions_op -> EQUALS .)
    CT_INT          reduce using rule 78 (expressions_op -> EQUALS .)
    CT_FLOAT        reduce using rule 78 (expressions_op -> EQUALS .)
    CT_CHAR         reduce using rule 78 (expressions_op -> EQUALS .)
    ID              reduce using rule 78 (expressions_op -> EQUALS .)


state 141

    (79) expressions_op -> NOT_EQUALS .

    OPEN_PAREN      reduce using rule 79 (expressions_op -> NOT_EQUALS .)
    CT_INT          reduce using rule 79 (expressions_op -> NOT_EQUALS .)
    CT_FLOAT        reduce using rule 79 (expressions_op -> NOT_EQUALS .)
    CT_CHAR         reduce using rule 79 (expressions_op -> NOT_EQUALS .)
    ID              reduce using rule 79 (expressions_op -> NOT_EQUALS .)


state 142

    (80) exp -> term g_quad_exp_as .
    (81) exp -> term g_quad_exp_as . exp_comp
    (83) exp_comp -> . PLUS add_op exp
    (84) exp_comp -> . MINUS add_op exp

    LESS_THAN       reduce using rule 80 (exp -> term g_quad_exp_as .)
    LESS_THAN_EQUAL reduce using rule 80 (exp -> term g_quad_exp_as .)
    MORE_THAN       reduce using rule 80 (exp -> term g_quad_exp_as .)
    MORE_THAN_EQUAL reduce using rule 80 (exp -> term g_quad_exp_as .)
    EQUALS          reduce using rule 80 (exp -> term g_quad_exp_as .)
    NOT_EQUALS      reduce using rule 80 (exp -> term g_quad_exp_as .)
    AND             reduce using rule 80 (exp -> term g_quad_exp_as .)
    OR              reduce using rule 80 (exp -> term g_quad_exp_as .)
    SEMICOLON       reduce using rule 80 (exp -> term g_quad_exp_as .)
    COMMA           reduce using rule 80 (exp -> term g_quad_exp_as .)
    CLOSE_PAREN     reduce using rule 80 (exp -> term g_quad_exp_as .)
    OPEN_PAREN      reduce using rule 80 (exp -> term g_quad_exp_as .)
    CT_INT          reduce using rule 80 (exp -> term g_quad_exp_as .)
    CT_FLOAT        reduce using rule 80 (exp -> term g_quad_exp_as .)
    CT_CHAR         reduce using rule 80 (exp -> term g_quad_exp_as .)
    ID              reduce using rule 80 (exp -> term g_quad_exp_as .)
    CLOSE_BRACKETS  reduce using rule 80 (exp -> term g_quad_exp_as .)
    TO              reduce using rule 80 (exp -> term g_quad_exp_as .)
    DO              reduce using rule 80 (exp -> term g_quad_exp_as .)
    PLUS            shift and go to state 174
    MINUS           shift and go to state 175

    exp_comp                       shift and go to state 173

state 143

    (85) term -> factor g_quad_exp_md .
    (86) term -> factor g_quad_exp_md . term_comp
    (88) term_comp -> . MULTIPLIES add_op term
    (89) term_comp -> . DIVIDE add_op term

    PLUS            reduce using rule 85 (term -> factor g_quad_exp_md .)
    MINUS           reduce using rule 85 (term -> factor g_quad_exp_md .)
    LESS_THAN       reduce using rule 85 (term -> factor g_quad_exp_md .)
    LESS_THAN_EQUAL reduce using rule 85 (term -> factor g_quad_exp_md .)
    MORE_THAN       reduce using rule 85 (term -> factor g_quad_exp_md .)
    MORE_THAN_EQUAL reduce using rule 85 (term -> factor g_quad_exp_md .)
    EQUALS          reduce using rule 85 (term -> factor g_quad_exp_md .)
    NOT_EQUALS      reduce using rule 85 (term -> factor g_quad_exp_md .)
    AND             reduce using rule 85 (term -> factor g_quad_exp_md .)
    OR              reduce using rule 85 (term -> factor g_quad_exp_md .)
    SEMICOLON       reduce using rule 85 (term -> factor g_quad_exp_md .)
    COMMA           reduce using rule 85 (term -> factor g_quad_exp_md .)
    CLOSE_PAREN     reduce using rule 85 (term -> factor g_quad_exp_md .)
    OPEN_PAREN      reduce using rule 85 (term -> factor g_quad_exp_md .)
    CT_INT          reduce using rule 85 (term -> factor g_quad_exp_md .)
    CT_FLOAT        reduce using rule 85 (term -> factor g_quad_exp_md .)
    CT_CHAR         reduce using rule 85 (term -> factor g_quad_exp_md .)
    ID              reduce using rule 85 (term -> factor g_quad_exp_md .)
    CLOSE_BRACKETS  reduce using rule 85 (term -> factor g_quad_exp_md .)
    TO              reduce using rule 85 (term -> factor g_quad_exp_md .)
    DO              reduce using rule 85 (term -> factor g_quad_exp_md .)
    MULTIPLIES      shift and go to state 177
    DIVIDE          shift and go to state 178

    term_comp                      shift and go to state 176

state 144

    (91) factor -> OPEN_PAREN add_fake . expressions CLOSE_PAREN rem_fake
    (67) expressions -> . expressions_comp
    (68) expressions_comp -> . expression_comp_2
    (69) expressions_comp -> . expression_comp_2 OR expressions_comp
    (70) expression_comp_2 -> . expression_comp_3
    (71) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (72) expression_comp_3 -> . exp
    (73) expression_comp_3 -> . exp expressions_op exp
    (80) exp -> . term g_quad_exp_as
    (81) exp -> . term g_quad_exp_as exp_comp
    (85) term -> . factor g_quad_exp_md
    (86) term -> . factor g_quad_exp_md term_comp
    (91) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (92) factor -> . variable
    (93) factor -> . func_call
    (94) factor -> . CT_INT add_ct_int
    (95) factor -> . CT_FLOAT add_ct_float
    (96) factor -> . CT_CHAR add_ct_char
    (104) variable -> . ID add_id
    (105) variable -> . ID dim
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 104
    CT_INT          shift and go to state 107
    CT_FLOAT        shift and go to state 108
    CT_CHAR         shift and go to state 109
    ID              shift and go to state 110

    expressions                    shift and go to state 179
    expressions_comp               shift and go to state 98
    expression_comp_2              shift and go to state 99
    expression_comp_3              shift and go to state 100
    exp                            shift and go to state 101
    term                           shift and go to state 102
    factor                         shift and go to state 103
    variable                       shift and go to state 105
    func_call                      shift and go to state 106

state 145

    (94) factor -> CT_INT add_ct_int .

    MULTIPLIES      reduce using rule 94 (factor -> CT_INT add_ct_int .)
    DIVIDE          reduce using rule 94 (factor -> CT_INT add_ct_int .)
    PLUS            reduce using rule 94 (factor -> CT_INT add_ct_int .)
    MINUS           reduce using rule 94 (factor -> CT_INT add_ct_int .)
    LESS_THAN       reduce using rule 94 (factor -> CT_INT add_ct_int .)
    LESS_THAN_EQUAL reduce using rule 94 (factor -> CT_INT add_ct_int .)
    MORE_THAN       reduce using rule 94 (factor -> CT_INT add_ct_int .)
    MORE_THAN_EQUAL reduce using rule 94 (factor -> CT_INT add_ct_int .)
    EQUALS          reduce using rule 94 (factor -> CT_INT add_ct_int .)
    NOT_EQUALS      reduce using rule 94 (factor -> CT_INT add_ct_int .)
    AND             reduce using rule 94 (factor -> CT_INT add_ct_int .)
    OR              reduce using rule 94 (factor -> CT_INT add_ct_int .)
    SEMICOLON       reduce using rule 94 (factor -> CT_INT add_ct_int .)
    COMMA           reduce using rule 94 (factor -> CT_INT add_ct_int .)
    CLOSE_PAREN     reduce using rule 94 (factor -> CT_INT add_ct_int .)
    OPEN_PAREN      reduce using rule 94 (factor -> CT_INT add_ct_int .)
    CT_INT          reduce using rule 94 (factor -> CT_INT add_ct_int .)
    CT_FLOAT        reduce using rule 94 (factor -> CT_INT add_ct_int .)
    CT_CHAR         reduce using rule 94 (factor -> CT_INT add_ct_int .)
    ID              reduce using rule 94 (factor -> CT_INT add_ct_int .)
    CLOSE_BRACKETS  reduce using rule 94 (factor -> CT_INT add_ct_int .)
    TO              reduce using rule 94 (factor -> CT_INT add_ct_int .)
    DO              reduce using rule 94 (factor -> CT_INT add_ct_int .)


state 146

    (95) factor -> CT_FLOAT add_ct_float .

    MULTIPLIES      reduce using rule 95 (factor -> CT_FLOAT add_ct_float .)
    DIVIDE          reduce using rule 95 (factor -> CT_FLOAT add_ct_float .)
    PLUS            reduce using rule 95 (factor -> CT_FLOAT add_ct_float .)
    MINUS           reduce using rule 95 (factor -> CT_FLOAT add_ct_float .)
    LESS_THAN       reduce using rule 95 (factor -> CT_FLOAT add_ct_float .)
    LESS_THAN_EQUAL reduce using rule 95 (factor -> CT_FLOAT add_ct_float .)
    MORE_THAN       reduce using rule 95 (factor -> CT_FLOAT add_ct_float .)
    MORE_THAN_EQUAL reduce using rule 95 (factor -> CT_FLOAT add_ct_float .)
    EQUALS          reduce using rule 95 (factor -> CT_FLOAT add_ct_float .)
    NOT_EQUALS      reduce using rule 95 (factor -> CT_FLOAT add_ct_float .)
    AND             reduce using rule 95 (factor -> CT_FLOAT add_ct_float .)
    OR              reduce using rule 95 (factor -> CT_FLOAT add_ct_float .)
    SEMICOLON       reduce using rule 95 (factor -> CT_FLOAT add_ct_float .)
    COMMA           reduce using rule 95 (factor -> CT_FLOAT add_ct_float .)
    CLOSE_PAREN     reduce using rule 95 (factor -> CT_FLOAT add_ct_float .)
    OPEN_PAREN      reduce using rule 95 (factor -> CT_FLOAT add_ct_float .)
    CT_INT          reduce using rule 95 (factor -> CT_FLOAT add_ct_float .)
    CT_FLOAT        reduce using rule 95 (factor -> CT_FLOAT add_ct_float .)
    CT_CHAR         reduce using rule 95 (factor -> CT_FLOAT add_ct_float .)
    ID              reduce using rule 95 (factor -> CT_FLOAT add_ct_float .)
    CLOSE_BRACKETS  reduce using rule 95 (factor -> CT_FLOAT add_ct_float .)
    TO              reduce using rule 95 (factor -> CT_FLOAT add_ct_float .)
    DO              reduce using rule 95 (factor -> CT_FLOAT add_ct_float .)


state 147

    (96) factor -> CT_CHAR add_ct_char .

    MULTIPLIES      reduce using rule 96 (factor -> CT_CHAR add_ct_char .)
    DIVIDE          reduce using rule 96 (factor -> CT_CHAR add_ct_char .)
    PLUS            reduce using rule 96 (factor -> CT_CHAR add_ct_char .)
    MINUS           reduce using rule 96 (factor -> CT_CHAR add_ct_char .)
    LESS_THAN       reduce using rule 96 (factor -> CT_CHAR add_ct_char .)
    LESS_THAN_EQUAL reduce using rule 96 (factor -> CT_CHAR add_ct_char .)
    MORE_THAN       reduce using rule 96 (factor -> CT_CHAR add_ct_char .)
    MORE_THAN_EQUAL reduce using rule 96 (factor -> CT_CHAR add_ct_char .)
    EQUALS          reduce using rule 96 (factor -> CT_CHAR add_ct_char .)
    NOT_EQUALS      reduce using rule 96 (factor -> CT_CHAR add_ct_char .)
    AND             reduce using rule 96 (factor -> CT_CHAR add_ct_char .)
    OR              reduce using rule 96 (factor -> CT_CHAR add_ct_char .)
    SEMICOLON       reduce using rule 96 (factor -> CT_CHAR add_ct_char .)
    COMMA           reduce using rule 96 (factor -> CT_CHAR add_ct_char .)
    CLOSE_PAREN     reduce using rule 96 (factor -> CT_CHAR add_ct_char .)
    OPEN_PAREN      reduce using rule 96 (factor -> CT_CHAR add_ct_char .)
    CT_INT          reduce using rule 96 (factor -> CT_CHAR add_ct_char .)
    CT_FLOAT        reduce using rule 96 (factor -> CT_CHAR add_ct_char .)
    CT_CHAR         reduce using rule 96 (factor -> CT_CHAR add_ct_char .)
    ID              reduce using rule 96 (factor -> CT_CHAR add_ct_char .)
    CLOSE_BRACKETS  reduce using rule 96 (factor -> CT_CHAR add_ct_char .)
    TO              reduce using rule 96 (factor -> CT_CHAR add_ct_char .)
    DO              reduce using rule 96 (factor -> CT_CHAR add_ct_char .)


state 148

    (104) variable -> ID add_id .

    MULTIPLIES      reduce using rule 104 (variable -> ID add_id .)
    DIVIDE          reduce using rule 104 (variable -> ID add_id .)
    PLUS            reduce using rule 104 (variable -> ID add_id .)
    MINUS           reduce using rule 104 (variable -> ID add_id .)
    LESS_THAN       reduce using rule 104 (variable -> ID add_id .)
    LESS_THAN_EQUAL reduce using rule 104 (variable -> ID add_id .)
    MORE_THAN       reduce using rule 104 (variable -> ID add_id .)
    MORE_THAN_EQUAL reduce using rule 104 (variable -> ID add_id .)
    EQUALS          reduce using rule 104 (variable -> ID add_id .)
    NOT_EQUALS      reduce using rule 104 (variable -> ID add_id .)
    AND             reduce using rule 104 (variable -> ID add_id .)
    OR              reduce using rule 104 (variable -> ID add_id .)
    SEMICOLON       reduce using rule 104 (variable -> ID add_id .)
    COMMA           reduce using rule 104 (variable -> ID add_id .)
    CLOSE_PAREN     reduce using rule 104 (variable -> ID add_id .)
    OPEN_PAREN      reduce using rule 104 (variable -> ID add_id .)
    CT_INT          reduce using rule 104 (variable -> ID add_id .)
    CT_FLOAT        reduce using rule 104 (variable -> ID add_id .)
    CT_CHAR         reduce using rule 104 (variable -> ID add_id .)
    ID              reduce using rule 104 (variable -> ID add_id .)
    CLOSE_BRACKETS  reduce using rule 104 (variable -> ID add_id .)
    TO              reduce using rule 104 (variable -> ID add_id .)
    DO              reduce using rule 104 (variable -> ID add_id .)


state 149

    (105) variable -> ID dim .

    MULTIPLIES      reduce using rule 105 (variable -> ID dim .)
    DIVIDE          reduce using rule 105 (variable -> ID dim .)
    PLUS            reduce using rule 105 (variable -> ID dim .)
    MINUS           reduce using rule 105 (variable -> ID dim .)
    LESS_THAN       reduce using rule 105 (variable -> ID dim .)
    LESS_THAN_EQUAL reduce using rule 105 (variable -> ID dim .)
    MORE_THAN       reduce using rule 105 (variable -> ID dim .)
    MORE_THAN_EQUAL reduce using rule 105 (variable -> ID dim .)
    EQUALS          reduce using rule 105 (variable -> ID dim .)
    NOT_EQUALS      reduce using rule 105 (variable -> ID dim .)
    AND             reduce using rule 105 (variable -> ID dim .)
    OR              reduce using rule 105 (variable -> ID dim .)
    SEMICOLON       reduce using rule 105 (variable -> ID dim .)
    COMMA           reduce using rule 105 (variable -> ID dim .)
    CLOSE_PAREN     reduce using rule 105 (variable -> ID dim .)
    OPEN_PAREN      reduce using rule 105 (variable -> ID dim .)
    CT_INT          reduce using rule 105 (variable -> ID dim .)
    CT_FLOAT        reduce using rule 105 (variable -> ID dim .)
    CT_CHAR         reduce using rule 105 (variable -> ID dim .)
    ID              reduce using rule 105 (variable -> ID dim .)
    CLOSE_BRACKETS  reduce using rule 105 (variable -> ID dim .)
    TO              reduce using rule 105 (variable -> ID dim .)
    DO              reduce using rule 105 (variable -> ID dim .)


state 150

    (46) read -> READ OPEN_PAREN ids read_comp . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 180


state 151

    (47) read_comp -> COMMA . ids read_comp
    (35) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (36) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (37) ids -> . ID

    ID              shift and go to state 81

    ids                            shift and go to state 181

state 152

    (48) read_comp -> empty .

    CLOSE_PAREN     reduce using rule 48 (read_comp -> empty .)


state 153

    (49) write -> WRITE OPEN_PAREN CT_STRING write_comp . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 182


state 154

    (51) write_comp -> COMMA . CT_STRING write_comp
    (52) write_comp -> COMMA . expressions write_comp
    (67) expressions -> . expressions_comp
    (68) expressions_comp -> . expression_comp_2
    (69) expressions_comp -> . expression_comp_2 OR expressions_comp
    (70) expression_comp_2 -> . expression_comp_3
    (71) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (72) expression_comp_3 -> . exp
    (73) expression_comp_3 -> . exp expressions_op exp
    (80) exp -> . term g_quad_exp_as
    (81) exp -> . term g_quad_exp_as exp_comp
    (85) term -> . factor g_quad_exp_md
    (86) term -> . factor g_quad_exp_md term_comp
    (91) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (92) factor -> . variable
    (93) factor -> . func_call
    (94) factor -> . CT_INT add_ct_int
    (95) factor -> . CT_FLOAT add_ct_float
    (96) factor -> . CT_CHAR add_ct_char
    (104) variable -> . ID add_id
    (105) variable -> . ID dim
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    CT_STRING       shift and go to state 183
    OPEN_PAREN      shift and go to state 104
    CT_INT          shift and go to state 107
    CT_FLOAT        shift and go to state 108
    CT_CHAR         shift and go to state 109
    ID              shift and go to state 110

    expressions                    shift and go to state 184
    expressions_comp               shift and go to state 98
    expression_comp_2              shift and go to state 99
    expression_comp_3              shift and go to state 100
    exp                            shift and go to state 101
    term                           shift and go to state 102
    factor                         shift and go to state 103
    variable                       shift and go to state 105
    func_call                      shift and go to state 106

state 155

    (53) write_comp -> empty .

    CLOSE_PAREN     reduce using rule 53 (write_comp -> empty .)


state 156

    (50) write -> WRITE OPEN_PAREN expressions write_comp . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 185


state 157

    (55) condition -> IF OPEN_PAREN expressions CLOSE_PAREN . THEN block ELSE g_else_quad block end_if
    (56) condition -> IF OPEN_PAREN expressions CLOSE_PAREN . g_if_quad THEN block end_if
    (59) g_if_quad -> .

  ! shift/reduce conflict for THEN resolved as shift
    THEN            shift and go to state 186

  ! THEN            [ reduce using rule 59 (g_if_quad -> .) ]

    g_if_quad                      shift and go to state 187

state 158

    (57) condition -> WHILE while_jump OPEN_PAREN expressions . CLOSE_PAREN DO block

    CLOSE_PAREN     shift and go to state 188


state 159

    (58) condition -> FOR ids ASSIGN expressions . TO expressions DO block

    TO              shift and go to state 189


state 160

    (62) return -> RETURN OPEN_PAREN exp CLOSE_PAREN .

    SEMICOLON       reduce using rule 62 (return -> RETURN OPEN_PAREN exp CLOSE_PAREN .)


state 161

    (63) func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .

    SEMICOLON       reduce using rule 63 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    MULTIPLIES      reduce using rule 63 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    DIVIDE          reduce using rule 63 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    PLUS            reduce using rule 63 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    MINUS           reduce using rule 63 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    LESS_THAN       reduce using rule 63 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    LESS_THAN_EQUAL reduce using rule 63 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    MORE_THAN       reduce using rule 63 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    MORE_THAN_EQUAL reduce using rule 63 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    EQUALS          reduce using rule 63 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    NOT_EQUALS      reduce using rule 63 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    AND             reduce using rule 63 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    OR              reduce using rule 63 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    COMMA           reduce using rule 63 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    CLOSE_PAREN     reduce using rule 63 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    OPEN_PAREN      reduce using rule 63 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    CT_INT          reduce using rule 63 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    CT_FLOAT        reduce using rule 63 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    CT_CHAR         reduce using rule 63 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    ID              reduce using rule 63 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    CLOSE_BRACKETS  reduce using rule 63 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    TO              reduce using rule 63 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    DO              reduce using rule 63 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)


state 162

    (64) func_call_comp -> expressions func_call_comp .

    CLOSE_PAREN     reduce using rule 64 (func_call_comp -> expressions func_call_comp .)


state 163

    (65) func_call_comp -> COMMA expressions . func_call_comp
    (64) func_call_comp -> . expressions func_call_comp
    (65) func_call_comp -> . COMMA expressions func_call_comp
    (66) func_call_comp -> . empty
    (67) expressions -> . expressions_comp
    (108) empty -> .
    (68) expressions_comp -> . expression_comp_2
    (69) expressions_comp -> . expression_comp_2 OR expressions_comp
    (70) expression_comp_2 -> . expression_comp_3
    (71) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (72) expression_comp_3 -> . exp
    (73) expression_comp_3 -> . exp expressions_op exp
    (80) exp -> . term g_quad_exp_as
    (81) exp -> . term g_quad_exp_as exp_comp
    (85) term -> . factor g_quad_exp_md
    (86) term -> . factor g_quad_exp_md term_comp
    (91) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (92) factor -> . variable
    (93) factor -> . func_call
    (94) factor -> . CT_INT add_ct_int
    (95) factor -> . CT_FLOAT add_ct_float
    (96) factor -> . CT_CHAR add_ct_char
    (104) variable -> . ID add_id
    (105) variable -> . ID dim
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    COMMA           shift and go to state 120
    CLOSE_PAREN     reduce using rule 108 (empty -> .)
    OPEN_PAREN      shift and go to state 104
    CT_INT          shift and go to state 107
    CT_FLOAT        shift and go to state 108
    CT_CHAR         shift and go to state 109
    ID              shift and go to state 110

    expressions                    shift and go to state 119
    func_call_comp                 shift and go to state 190
    empty                          shift and go to state 121
    expressions_comp               shift and go to state 98
    expression_comp_2              shift and go to state 99
    expression_comp_3              shift and go to state 100
    exp                            shift and go to state 101
    term                           shift and go to state 102
    factor                         shift and go to state 103
    variable                       shift and go to state 105
    func_call                      shift and go to state 106

state 164

    (35) ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS . OPEN_BRACKETS exp CLOSE_BRACKETS
    (36) ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS .

    OPEN_BRACKETS   shift and go to state 191
    ASSIGN          reduce using rule 36 (ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS .)
    COMMA           reduce using rule 36 (ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CLOSE_PAREN     reduce using rule 36 (ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS .)


state 165

    (5) funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block .

    MAIN            reduce using rule 5 (funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block .)


state 166

    (11) funcs_params_comp -> COMMA var_type . variable_params funcs_params_comp
    (102) variable_params -> . ID
    (103) variable_params -> . ID dim

    ID              shift and go to state 87

    variable_params                shift and go to state 192

state 167

    (107) dim -> OPEN_BRACKETS exp . CLOSE_BRACKETS

    CLOSE_BRACKETS  shift and go to state 193


state 168

    (8) funcs_comp -> ID add_module OPEN_PAREN . funcs_params CLOSE_PAREN vars block
    (9) funcs_params -> . var_type variable_params funcs_params_comp
    (10) funcs_params -> . empty
    (16) var_type -> . INT
    (17) var_type -> . FLOAT
    (18) var_type -> . CHAR
    (108) empty -> .

    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16
    CLOSE_PAREN     reduce using rule 108 (empty -> .)

    funcs_params                   shift and go to state 194
    var_type                       shift and go to state 63
    empty                          shift and go to state 64

state 169

    (28) var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .

    VOID            reduce using rule 28 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    INT             reduce using rule 28 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    FLOAT           reduce using rule 28 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    CHAR            reduce using rule 28 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    MAIN            reduce using rule 28 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    OPEN_BRACES     reduce using rule 28 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)


state 170

    (69) expressions_comp -> expression_comp_2 OR expressions_comp .

    SEMICOLON       reduce using rule 69 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    COMMA           reduce using rule 69 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    CLOSE_PAREN     reduce using rule 69 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    OPEN_PAREN      reduce using rule 69 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    CT_INT          reduce using rule 69 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    CT_FLOAT        reduce using rule 69 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    CT_CHAR         reduce using rule 69 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    ID              reduce using rule 69 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    TO              reduce using rule 69 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    DO              reduce using rule 69 (expressions_comp -> expression_comp_2 OR expressions_comp .)


state 171

    (71) expression_comp_2 -> expression_comp_3 AND expression_comp_2 .

    OR              reduce using rule 71 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    SEMICOLON       reduce using rule 71 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    COMMA           reduce using rule 71 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    CLOSE_PAREN     reduce using rule 71 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    OPEN_PAREN      reduce using rule 71 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    CT_INT          reduce using rule 71 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    CT_FLOAT        reduce using rule 71 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    CT_CHAR         reduce using rule 71 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    ID              reduce using rule 71 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    TO              reduce using rule 71 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    DO              reduce using rule 71 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)


state 172

    (73) expression_comp_3 -> exp expressions_op exp .

    AND             reduce using rule 73 (expression_comp_3 -> exp expressions_op exp .)
    OR              reduce using rule 73 (expression_comp_3 -> exp expressions_op exp .)
    SEMICOLON       reduce using rule 73 (expression_comp_3 -> exp expressions_op exp .)
    COMMA           reduce using rule 73 (expression_comp_3 -> exp expressions_op exp .)
    CLOSE_PAREN     reduce using rule 73 (expression_comp_3 -> exp expressions_op exp .)
    OPEN_PAREN      reduce using rule 73 (expression_comp_3 -> exp expressions_op exp .)
    CT_INT          reduce using rule 73 (expression_comp_3 -> exp expressions_op exp .)
    CT_FLOAT        reduce using rule 73 (expression_comp_3 -> exp expressions_op exp .)
    CT_CHAR         reduce using rule 73 (expression_comp_3 -> exp expressions_op exp .)
    ID              reduce using rule 73 (expression_comp_3 -> exp expressions_op exp .)
    TO              reduce using rule 73 (expression_comp_3 -> exp expressions_op exp .)
    DO              reduce using rule 73 (expression_comp_3 -> exp expressions_op exp .)


state 173

    (81) exp -> term g_quad_exp_as exp_comp .

    LESS_THAN       reduce using rule 81 (exp -> term g_quad_exp_as exp_comp .)
    LESS_THAN_EQUAL reduce using rule 81 (exp -> term g_quad_exp_as exp_comp .)
    MORE_THAN       reduce using rule 81 (exp -> term g_quad_exp_as exp_comp .)
    MORE_THAN_EQUAL reduce using rule 81 (exp -> term g_quad_exp_as exp_comp .)
    EQUALS          reduce using rule 81 (exp -> term g_quad_exp_as exp_comp .)
    NOT_EQUALS      reduce using rule 81 (exp -> term g_quad_exp_as exp_comp .)
    AND             reduce using rule 81 (exp -> term g_quad_exp_as exp_comp .)
    OR              reduce using rule 81 (exp -> term g_quad_exp_as exp_comp .)
    SEMICOLON       reduce using rule 81 (exp -> term g_quad_exp_as exp_comp .)
    COMMA           reduce using rule 81 (exp -> term g_quad_exp_as exp_comp .)
    CLOSE_PAREN     reduce using rule 81 (exp -> term g_quad_exp_as exp_comp .)
    OPEN_PAREN      reduce using rule 81 (exp -> term g_quad_exp_as exp_comp .)
    CT_INT          reduce using rule 81 (exp -> term g_quad_exp_as exp_comp .)
    CT_FLOAT        reduce using rule 81 (exp -> term g_quad_exp_as exp_comp .)
    CT_CHAR         reduce using rule 81 (exp -> term g_quad_exp_as exp_comp .)
    ID              reduce using rule 81 (exp -> term g_quad_exp_as exp_comp .)
    CLOSE_BRACKETS  reduce using rule 81 (exp -> term g_quad_exp_as exp_comp .)
    TO              reduce using rule 81 (exp -> term g_quad_exp_as exp_comp .)
    DO              reduce using rule 81 (exp -> term g_quad_exp_as exp_comp .)


state 174

    (83) exp_comp -> PLUS . add_op exp
    (90) add_op -> .

    OPEN_PAREN      reduce using rule 90 (add_op -> .)
    CT_INT          reduce using rule 90 (add_op -> .)
    CT_FLOAT        reduce using rule 90 (add_op -> .)
    CT_CHAR         reduce using rule 90 (add_op -> .)
    ID              reduce using rule 90 (add_op -> .)

    add_op                         shift and go to state 195

state 175

    (84) exp_comp -> MINUS . add_op exp
    (90) add_op -> .

    OPEN_PAREN      reduce using rule 90 (add_op -> .)
    CT_INT          reduce using rule 90 (add_op -> .)
    CT_FLOAT        reduce using rule 90 (add_op -> .)
    CT_CHAR         reduce using rule 90 (add_op -> .)
    ID              reduce using rule 90 (add_op -> .)

    add_op                         shift and go to state 196

state 176

    (86) term -> factor g_quad_exp_md term_comp .

    PLUS            reduce using rule 86 (term -> factor g_quad_exp_md term_comp .)
    MINUS           reduce using rule 86 (term -> factor g_quad_exp_md term_comp .)
    LESS_THAN       reduce using rule 86 (term -> factor g_quad_exp_md term_comp .)
    LESS_THAN_EQUAL reduce using rule 86 (term -> factor g_quad_exp_md term_comp .)
    MORE_THAN       reduce using rule 86 (term -> factor g_quad_exp_md term_comp .)
    MORE_THAN_EQUAL reduce using rule 86 (term -> factor g_quad_exp_md term_comp .)
    EQUALS          reduce using rule 86 (term -> factor g_quad_exp_md term_comp .)
    NOT_EQUALS      reduce using rule 86 (term -> factor g_quad_exp_md term_comp .)
    AND             reduce using rule 86 (term -> factor g_quad_exp_md term_comp .)
    OR              reduce using rule 86 (term -> factor g_quad_exp_md term_comp .)
    SEMICOLON       reduce using rule 86 (term -> factor g_quad_exp_md term_comp .)
    COMMA           reduce using rule 86 (term -> factor g_quad_exp_md term_comp .)
    CLOSE_PAREN     reduce using rule 86 (term -> factor g_quad_exp_md term_comp .)
    OPEN_PAREN      reduce using rule 86 (term -> factor g_quad_exp_md term_comp .)
    CT_INT          reduce using rule 86 (term -> factor g_quad_exp_md term_comp .)
    CT_FLOAT        reduce using rule 86 (term -> factor g_quad_exp_md term_comp .)
    CT_CHAR         reduce using rule 86 (term -> factor g_quad_exp_md term_comp .)
    ID              reduce using rule 86 (term -> factor g_quad_exp_md term_comp .)
    CLOSE_BRACKETS  reduce using rule 86 (term -> factor g_quad_exp_md term_comp .)
    TO              reduce using rule 86 (term -> factor g_quad_exp_md term_comp .)
    DO              reduce using rule 86 (term -> factor g_quad_exp_md term_comp .)


state 177

    (88) term_comp -> MULTIPLIES . add_op term
    (90) add_op -> .

    OPEN_PAREN      reduce using rule 90 (add_op -> .)
    CT_INT          reduce using rule 90 (add_op -> .)
    CT_FLOAT        reduce using rule 90 (add_op -> .)
    CT_CHAR         reduce using rule 90 (add_op -> .)
    ID              reduce using rule 90 (add_op -> .)

    add_op                         shift and go to state 197

state 178

    (89) term_comp -> DIVIDE . add_op term
    (90) add_op -> .

    OPEN_PAREN      reduce using rule 90 (add_op -> .)
    CT_INT          reduce using rule 90 (add_op -> .)
    CT_FLOAT        reduce using rule 90 (add_op -> .)
    CT_CHAR         reduce using rule 90 (add_op -> .)
    ID              reduce using rule 90 (add_op -> .)

    add_op                         shift and go to state 198

state 179

    (91) factor -> OPEN_PAREN add_fake expressions . CLOSE_PAREN rem_fake

    CLOSE_PAREN     shift and go to state 199


state 180

    (46) read -> READ OPEN_PAREN ids read_comp CLOSE_PAREN .

    SEMICOLON       reduce using rule 46 (read -> READ OPEN_PAREN ids read_comp CLOSE_PAREN .)


state 181

    (47) read_comp -> COMMA ids . read_comp
    (47) read_comp -> . COMMA ids read_comp
    (48) read_comp -> . empty
    (108) empty -> .

    COMMA           shift and go to state 151
    CLOSE_PAREN     reduce using rule 108 (empty -> .)

    read_comp                      shift and go to state 200
    empty                          shift and go to state 152

state 182

    (49) write -> WRITE OPEN_PAREN CT_STRING write_comp CLOSE_PAREN .

    SEMICOLON       reduce using rule 49 (write -> WRITE OPEN_PAREN CT_STRING write_comp CLOSE_PAREN .)


state 183

    (51) write_comp -> COMMA CT_STRING . write_comp
    (51) write_comp -> . COMMA CT_STRING write_comp
    (52) write_comp -> . COMMA expressions write_comp
    (53) write_comp -> . empty
    (108) empty -> .

    COMMA           shift and go to state 154
    CLOSE_PAREN     reduce using rule 108 (empty -> .)

    write_comp                     shift and go to state 201
    empty                          shift and go to state 155

state 184

    (52) write_comp -> COMMA expressions . write_comp
    (51) write_comp -> . COMMA CT_STRING write_comp
    (52) write_comp -> . COMMA expressions write_comp
    (53) write_comp -> . empty
    (108) empty -> .

    COMMA           shift and go to state 154
    CLOSE_PAREN     reduce using rule 108 (empty -> .)

    write_comp                     shift and go to state 202
    empty                          shift and go to state 155

state 185

    (50) write -> WRITE OPEN_PAREN expressions write_comp CLOSE_PAREN .

    SEMICOLON       reduce using rule 50 (write -> WRITE OPEN_PAREN expressions write_comp CLOSE_PAREN .)


state 186

    (55) condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN . block ELSE g_else_quad block end_if
    (13) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 39

    block                          shift and go to state 203

state 187

    (56) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad . THEN block end_if

    THEN            shift and go to state 204


state 188

    (57) condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN . DO block

    DO              shift and go to state 205


state 189

    (58) condition -> FOR ids ASSIGN expressions TO . expressions DO block
    (67) expressions -> . expressions_comp
    (68) expressions_comp -> . expression_comp_2
    (69) expressions_comp -> . expression_comp_2 OR expressions_comp
    (70) expression_comp_2 -> . expression_comp_3
    (71) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (72) expression_comp_3 -> . exp
    (73) expression_comp_3 -> . exp expressions_op exp
    (80) exp -> . term g_quad_exp_as
    (81) exp -> . term g_quad_exp_as exp_comp
    (85) term -> . factor g_quad_exp_md
    (86) term -> . factor g_quad_exp_md term_comp
    (91) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (92) factor -> . variable
    (93) factor -> . func_call
    (94) factor -> . CT_INT add_ct_int
    (95) factor -> . CT_FLOAT add_ct_float
    (96) factor -> . CT_CHAR add_ct_char
    (104) variable -> . ID add_id
    (105) variable -> . ID dim
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 104
    CT_INT          shift and go to state 107
    CT_FLOAT        shift and go to state 108
    CT_CHAR         shift and go to state 109
    ID              shift and go to state 110

    expressions                    shift and go to state 206
    expressions_comp               shift and go to state 98
    expression_comp_2              shift and go to state 99
    expression_comp_3              shift and go to state 100
    exp                            shift and go to state 101
    term                           shift and go to state 102
    factor                         shift and go to state 103
    variable                       shift and go to state 105
    func_call                      shift and go to state 106

state 190

    (65) func_call_comp -> COMMA expressions func_call_comp .

    CLOSE_PAREN     reduce using rule 65 (func_call_comp -> COMMA expressions func_call_comp .)


state 191

    (35) ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS . exp CLOSE_BRACKETS
    (80) exp -> . term g_quad_exp_as
    (81) exp -> . term g_quad_exp_as exp_comp
    (85) term -> . factor g_quad_exp_md
    (86) term -> . factor g_quad_exp_md term_comp
    (91) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (92) factor -> . variable
    (93) factor -> . func_call
    (94) factor -> . CT_INT add_ct_int
    (95) factor -> . CT_FLOAT add_ct_float
    (96) factor -> . CT_CHAR add_ct_char
    (104) variable -> . ID add_id
    (105) variable -> . ID dim
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 104
    CT_INT          shift and go to state 107
    CT_FLOAT        shift and go to state 108
    CT_CHAR         shift and go to state 109
    ID              shift and go to state 110

    exp                            shift and go to state 207
    term                           shift and go to state 102
    factor                         shift and go to state 103
    variable                       shift and go to state 105
    func_call                      shift and go to state 106

state 192

    (11) funcs_params_comp -> COMMA var_type variable_params . funcs_params_comp
    (11) funcs_params_comp -> . COMMA var_type variable_params funcs_params_comp
    (12) funcs_params_comp -> . empty
    (108) empty -> .

    COMMA           shift and go to state 125
    CLOSE_PAREN     reduce using rule 108 (empty -> .)

    funcs_params_comp              shift and go to state 208
    empty                          shift and go to state 126

state 193

    (107) dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .

    COMMA           reduce using rule 107 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CLOSE_PAREN     reduce using rule 107 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    MULTIPLIES      reduce using rule 107 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    DIVIDE          reduce using rule 107 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    PLUS            reduce using rule 107 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    MINUS           reduce using rule 107 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    LESS_THAN       reduce using rule 107 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    LESS_THAN_EQUAL reduce using rule 107 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    MORE_THAN       reduce using rule 107 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    MORE_THAN_EQUAL reduce using rule 107 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    EQUALS          reduce using rule 107 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    NOT_EQUALS      reduce using rule 107 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    AND             reduce using rule 107 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    OR              reduce using rule 107 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    SEMICOLON       reduce using rule 107 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    OPEN_PAREN      reduce using rule 107 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CT_INT          reduce using rule 107 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CT_FLOAT        reduce using rule 107 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CT_CHAR         reduce using rule 107 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    ID              reduce using rule 107 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CLOSE_BRACKETS  reduce using rule 107 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    TO              reduce using rule 107 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    DO              reduce using rule 107 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)


state 194

    (8) funcs_comp -> ID add_module OPEN_PAREN funcs_params . CLOSE_PAREN vars block

    CLOSE_PAREN     shift and go to state 209


state 195

    (83) exp_comp -> PLUS add_op . exp
    (80) exp -> . term g_quad_exp_as
    (81) exp -> . term g_quad_exp_as exp_comp
    (85) term -> . factor g_quad_exp_md
    (86) term -> . factor g_quad_exp_md term_comp
    (91) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (92) factor -> . variable
    (93) factor -> . func_call
    (94) factor -> . CT_INT add_ct_int
    (95) factor -> . CT_FLOAT add_ct_float
    (96) factor -> . CT_CHAR add_ct_char
    (104) variable -> . ID add_id
    (105) variable -> . ID dim
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 104
    CT_INT          shift and go to state 107
    CT_FLOAT        shift and go to state 108
    CT_CHAR         shift and go to state 109
    ID              shift and go to state 110

    exp                            shift and go to state 210
    term                           shift and go to state 102
    factor                         shift and go to state 103
    variable                       shift and go to state 105
    func_call                      shift and go to state 106

state 196

    (84) exp_comp -> MINUS add_op . exp
    (80) exp -> . term g_quad_exp_as
    (81) exp -> . term g_quad_exp_as exp_comp
    (85) term -> . factor g_quad_exp_md
    (86) term -> . factor g_quad_exp_md term_comp
    (91) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (92) factor -> . variable
    (93) factor -> . func_call
    (94) factor -> . CT_INT add_ct_int
    (95) factor -> . CT_FLOAT add_ct_float
    (96) factor -> . CT_CHAR add_ct_char
    (104) variable -> . ID add_id
    (105) variable -> . ID dim
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 104
    CT_INT          shift and go to state 107
    CT_FLOAT        shift and go to state 108
    CT_CHAR         shift and go to state 109
    ID              shift and go to state 110

    exp                            shift and go to state 211
    term                           shift and go to state 102
    factor                         shift and go to state 103
    variable                       shift and go to state 105
    func_call                      shift and go to state 106

state 197

    (88) term_comp -> MULTIPLIES add_op . term
    (85) term -> . factor g_quad_exp_md
    (86) term -> . factor g_quad_exp_md term_comp
    (91) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (92) factor -> . variable
    (93) factor -> . func_call
    (94) factor -> . CT_INT add_ct_int
    (95) factor -> . CT_FLOAT add_ct_float
    (96) factor -> . CT_CHAR add_ct_char
    (104) variable -> . ID add_id
    (105) variable -> . ID dim
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 104
    CT_INT          shift and go to state 107
    CT_FLOAT        shift and go to state 108
    CT_CHAR         shift and go to state 109
    ID              shift and go to state 110

    term                           shift and go to state 212
    factor                         shift and go to state 103
    variable                       shift and go to state 105
    func_call                      shift and go to state 106

state 198

    (89) term_comp -> DIVIDE add_op . term
    (85) term -> . factor g_quad_exp_md
    (86) term -> . factor g_quad_exp_md term_comp
    (91) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (92) factor -> . variable
    (93) factor -> . func_call
    (94) factor -> . CT_INT add_ct_int
    (95) factor -> . CT_FLOAT add_ct_float
    (96) factor -> . CT_CHAR add_ct_char
    (104) variable -> . ID add_id
    (105) variable -> . ID dim
    (63) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 104
    CT_INT          shift and go to state 107
    CT_FLOAT        shift and go to state 108
    CT_CHAR         shift and go to state 109
    ID              shift and go to state 110

    term                           shift and go to state 213
    factor                         shift and go to state 103
    variable                       shift and go to state 105
    func_call                      shift and go to state 106

state 199

    (91) factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN . rem_fake
    (98) rem_fake -> .

    MULTIPLIES      reduce using rule 98 (rem_fake -> .)
    DIVIDE          reduce using rule 98 (rem_fake -> .)
    PLUS            reduce using rule 98 (rem_fake -> .)
    MINUS           reduce using rule 98 (rem_fake -> .)
    LESS_THAN       reduce using rule 98 (rem_fake -> .)
    LESS_THAN_EQUAL reduce using rule 98 (rem_fake -> .)
    MORE_THAN       reduce using rule 98 (rem_fake -> .)
    MORE_THAN_EQUAL reduce using rule 98 (rem_fake -> .)
    EQUALS          reduce using rule 98 (rem_fake -> .)
    NOT_EQUALS      reduce using rule 98 (rem_fake -> .)
    AND             reduce using rule 98 (rem_fake -> .)
    OR              reduce using rule 98 (rem_fake -> .)
    SEMICOLON       reduce using rule 98 (rem_fake -> .)
    COMMA           reduce using rule 98 (rem_fake -> .)
    CLOSE_PAREN     reduce using rule 98 (rem_fake -> .)
    OPEN_PAREN      reduce using rule 98 (rem_fake -> .)
    CT_INT          reduce using rule 98 (rem_fake -> .)
    CT_FLOAT        reduce using rule 98 (rem_fake -> .)
    CT_CHAR         reduce using rule 98 (rem_fake -> .)
    ID              reduce using rule 98 (rem_fake -> .)
    CLOSE_BRACKETS  reduce using rule 98 (rem_fake -> .)
    TO              reduce using rule 98 (rem_fake -> .)
    DO              reduce using rule 98 (rem_fake -> .)

    rem_fake                       shift and go to state 214

state 200

    (47) read_comp -> COMMA ids read_comp .

    CLOSE_PAREN     reduce using rule 47 (read_comp -> COMMA ids read_comp .)


state 201

    (51) write_comp -> COMMA CT_STRING write_comp .

    CLOSE_PAREN     reduce using rule 51 (write_comp -> COMMA CT_STRING write_comp .)


state 202

    (52) write_comp -> COMMA expressions write_comp .

    CLOSE_PAREN     reduce using rule 52 (write_comp -> COMMA expressions write_comp .)


state 203

    (55) condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block . ELSE g_else_quad block end_if

    ELSE            shift and go to state 215


state 204

    (56) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN . block end_if
    (13) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 39

    block                          shift and go to state 216

state 205

    (57) condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN DO . block
    (13) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 39

    block                          shift and go to state 217

state 206

    (58) condition -> FOR ids ASSIGN expressions TO expressions . DO block

    DO              shift and go to state 218


state 207

    (35) ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp . CLOSE_BRACKETS

    CLOSE_BRACKETS  shift and go to state 219


state 208

    (11) funcs_params_comp -> COMMA var_type variable_params funcs_params_comp .

    CLOSE_PAREN     reduce using rule 11 (funcs_params_comp -> COMMA var_type variable_params funcs_params_comp .)


state 209

    (8) funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN . vars block
    (19) vars -> . VARS var_comp
    (20) vars -> . empty
    (108) empty -> .

    VARS            shift and go to state 7
    OPEN_BRACES     reduce using rule 108 (empty -> .)

    vars                           shift and go to state 220
    empty                          shift and go to state 8

state 210

    (83) exp_comp -> PLUS add_op exp .

    LESS_THAN       reduce using rule 83 (exp_comp -> PLUS add_op exp .)
    LESS_THAN_EQUAL reduce using rule 83 (exp_comp -> PLUS add_op exp .)
    MORE_THAN       reduce using rule 83 (exp_comp -> PLUS add_op exp .)
    MORE_THAN_EQUAL reduce using rule 83 (exp_comp -> PLUS add_op exp .)
    EQUALS          reduce using rule 83 (exp_comp -> PLUS add_op exp .)
    NOT_EQUALS      reduce using rule 83 (exp_comp -> PLUS add_op exp .)
    AND             reduce using rule 83 (exp_comp -> PLUS add_op exp .)
    OR              reduce using rule 83 (exp_comp -> PLUS add_op exp .)
    SEMICOLON       reduce using rule 83 (exp_comp -> PLUS add_op exp .)
    COMMA           reduce using rule 83 (exp_comp -> PLUS add_op exp .)
    CLOSE_PAREN     reduce using rule 83 (exp_comp -> PLUS add_op exp .)
    OPEN_PAREN      reduce using rule 83 (exp_comp -> PLUS add_op exp .)
    CT_INT          reduce using rule 83 (exp_comp -> PLUS add_op exp .)
    CT_FLOAT        reduce using rule 83 (exp_comp -> PLUS add_op exp .)
    CT_CHAR         reduce using rule 83 (exp_comp -> PLUS add_op exp .)
    ID              reduce using rule 83 (exp_comp -> PLUS add_op exp .)
    CLOSE_BRACKETS  reduce using rule 83 (exp_comp -> PLUS add_op exp .)
    TO              reduce using rule 83 (exp_comp -> PLUS add_op exp .)
    DO              reduce using rule 83 (exp_comp -> PLUS add_op exp .)


state 211

    (84) exp_comp -> MINUS add_op exp .

    LESS_THAN       reduce using rule 84 (exp_comp -> MINUS add_op exp .)
    LESS_THAN_EQUAL reduce using rule 84 (exp_comp -> MINUS add_op exp .)
    MORE_THAN       reduce using rule 84 (exp_comp -> MINUS add_op exp .)
    MORE_THAN_EQUAL reduce using rule 84 (exp_comp -> MINUS add_op exp .)
    EQUALS          reduce using rule 84 (exp_comp -> MINUS add_op exp .)
    NOT_EQUALS      reduce using rule 84 (exp_comp -> MINUS add_op exp .)
    AND             reduce using rule 84 (exp_comp -> MINUS add_op exp .)
    OR              reduce using rule 84 (exp_comp -> MINUS add_op exp .)
    SEMICOLON       reduce using rule 84 (exp_comp -> MINUS add_op exp .)
    COMMA           reduce using rule 84 (exp_comp -> MINUS add_op exp .)
    CLOSE_PAREN     reduce using rule 84 (exp_comp -> MINUS add_op exp .)
    OPEN_PAREN      reduce using rule 84 (exp_comp -> MINUS add_op exp .)
    CT_INT          reduce using rule 84 (exp_comp -> MINUS add_op exp .)
    CT_FLOAT        reduce using rule 84 (exp_comp -> MINUS add_op exp .)
    CT_CHAR         reduce using rule 84 (exp_comp -> MINUS add_op exp .)
    ID              reduce using rule 84 (exp_comp -> MINUS add_op exp .)
    CLOSE_BRACKETS  reduce using rule 84 (exp_comp -> MINUS add_op exp .)
    TO              reduce using rule 84 (exp_comp -> MINUS add_op exp .)
    DO              reduce using rule 84 (exp_comp -> MINUS add_op exp .)


state 212

    (88) term_comp -> MULTIPLIES add_op term .

    PLUS            reduce using rule 88 (term_comp -> MULTIPLIES add_op term .)
    MINUS           reduce using rule 88 (term_comp -> MULTIPLIES add_op term .)
    LESS_THAN       reduce using rule 88 (term_comp -> MULTIPLIES add_op term .)
    LESS_THAN_EQUAL reduce using rule 88 (term_comp -> MULTIPLIES add_op term .)
    MORE_THAN       reduce using rule 88 (term_comp -> MULTIPLIES add_op term .)
    MORE_THAN_EQUAL reduce using rule 88 (term_comp -> MULTIPLIES add_op term .)
    EQUALS          reduce using rule 88 (term_comp -> MULTIPLIES add_op term .)
    NOT_EQUALS      reduce using rule 88 (term_comp -> MULTIPLIES add_op term .)
    AND             reduce using rule 88 (term_comp -> MULTIPLIES add_op term .)
    OR              reduce using rule 88 (term_comp -> MULTIPLIES add_op term .)
    SEMICOLON       reduce using rule 88 (term_comp -> MULTIPLIES add_op term .)
    COMMA           reduce using rule 88 (term_comp -> MULTIPLIES add_op term .)
    CLOSE_PAREN     reduce using rule 88 (term_comp -> MULTIPLIES add_op term .)
    OPEN_PAREN      reduce using rule 88 (term_comp -> MULTIPLIES add_op term .)
    CT_INT          reduce using rule 88 (term_comp -> MULTIPLIES add_op term .)
    CT_FLOAT        reduce using rule 88 (term_comp -> MULTIPLIES add_op term .)
    CT_CHAR         reduce using rule 88 (term_comp -> MULTIPLIES add_op term .)
    ID              reduce using rule 88 (term_comp -> MULTIPLIES add_op term .)
    CLOSE_BRACKETS  reduce using rule 88 (term_comp -> MULTIPLIES add_op term .)
    TO              reduce using rule 88 (term_comp -> MULTIPLIES add_op term .)
    DO              reduce using rule 88 (term_comp -> MULTIPLIES add_op term .)


state 213

    (89) term_comp -> DIVIDE add_op term .

    PLUS            reduce using rule 89 (term_comp -> DIVIDE add_op term .)
    MINUS           reduce using rule 89 (term_comp -> DIVIDE add_op term .)
    LESS_THAN       reduce using rule 89 (term_comp -> DIVIDE add_op term .)
    LESS_THAN_EQUAL reduce using rule 89 (term_comp -> DIVIDE add_op term .)
    MORE_THAN       reduce using rule 89 (term_comp -> DIVIDE add_op term .)
    MORE_THAN_EQUAL reduce using rule 89 (term_comp -> DIVIDE add_op term .)
    EQUALS          reduce using rule 89 (term_comp -> DIVIDE add_op term .)
    NOT_EQUALS      reduce using rule 89 (term_comp -> DIVIDE add_op term .)
    AND             reduce using rule 89 (term_comp -> DIVIDE add_op term .)
    OR              reduce using rule 89 (term_comp -> DIVIDE add_op term .)
    SEMICOLON       reduce using rule 89 (term_comp -> DIVIDE add_op term .)
    COMMA           reduce using rule 89 (term_comp -> DIVIDE add_op term .)
    CLOSE_PAREN     reduce using rule 89 (term_comp -> DIVIDE add_op term .)
    OPEN_PAREN      reduce using rule 89 (term_comp -> DIVIDE add_op term .)
    CT_INT          reduce using rule 89 (term_comp -> DIVIDE add_op term .)
    CT_FLOAT        reduce using rule 89 (term_comp -> DIVIDE add_op term .)
    CT_CHAR         reduce using rule 89 (term_comp -> DIVIDE add_op term .)
    ID              reduce using rule 89 (term_comp -> DIVIDE add_op term .)
    CLOSE_BRACKETS  reduce using rule 89 (term_comp -> DIVIDE add_op term .)
    TO              reduce using rule 89 (term_comp -> DIVIDE add_op term .)
    DO              reduce using rule 89 (term_comp -> DIVIDE add_op term .)


state 214

    (91) factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .

    MULTIPLIES      reduce using rule 91 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    DIVIDE          reduce using rule 91 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    PLUS            reduce using rule 91 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    MINUS           reduce using rule 91 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    LESS_THAN       reduce using rule 91 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    LESS_THAN_EQUAL reduce using rule 91 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    MORE_THAN       reduce using rule 91 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    MORE_THAN_EQUAL reduce using rule 91 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    EQUALS          reduce using rule 91 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    NOT_EQUALS      reduce using rule 91 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    AND             reduce using rule 91 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    OR              reduce using rule 91 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    SEMICOLON       reduce using rule 91 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    COMMA           reduce using rule 91 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    CLOSE_PAREN     reduce using rule 91 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    OPEN_PAREN      reduce using rule 91 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    CT_INT          reduce using rule 91 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    CT_FLOAT        reduce using rule 91 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    CT_CHAR         reduce using rule 91 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    ID              reduce using rule 91 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    CLOSE_BRACKETS  reduce using rule 91 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    TO              reduce using rule 91 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    DO              reduce using rule 91 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)


state 215

    (55) condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE . g_else_quad block end_if
    (60) g_else_quad -> .

    OPEN_BRACES     reduce using rule 60 (g_else_quad -> .)

    g_else_quad                    shift and go to state 221

state 216

    (56) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block . end_if
    (54) end_if -> .

    READ            reduce using rule 54 (end_if -> .)
    WRITE           reduce using rule 54 (end_if -> .)
    IF              reduce using rule 54 (end_if -> .)
    WHILE           reduce using rule 54 (end_if -> .)
    FOR             reduce using rule 54 (end_if -> .)
    RETURN          reduce using rule 54 (end_if -> .)
    ID              reduce using rule 54 (end_if -> .)
    CLOSE_BRACES    reduce using rule 54 (end_if -> .)

    end_if                         shift and go to state 222

state 217

    (57) condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN DO block .

    READ            reduce using rule 57 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN DO block .)
    WRITE           reduce using rule 57 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN DO block .)
    IF              reduce using rule 57 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN DO block .)
    WHILE           reduce using rule 57 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN DO block .)
    FOR             reduce using rule 57 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN DO block .)
    RETURN          reduce using rule 57 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN DO block .)
    ID              reduce using rule 57 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN DO block .)
    CLOSE_BRACES    reduce using rule 57 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN DO block .)


state 218

    (58) condition -> FOR ids ASSIGN expressions TO expressions DO . block
    (13) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 39

    block                          shift and go to state 223

state 219

    (35) ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS .

    ASSIGN          reduce using rule 35 (ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS .)
    COMMA           reduce using rule 35 (ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CLOSE_PAREN     reduce using rule 35 (ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS .)


state 220

    (8) funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars . block
    (13) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 39

    block                          shift and go to state 224

state 221

    (55) condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE g_else_quad . block end_if
    (13) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 39

    block                          shift and go to state 225

state 222

    (56) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .

    READ            reduce using rule 56 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    WRITE           reduce using rule 56 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    IF              reduce using rule 56 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    WHILE           reduce using rule 56 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    FOR             reduce using rule 56 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    RETURN          reduce using rule 56 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    ID              reduce using rule 56 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    CLOSE_BRACES    reduce using rule 56 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)


state 223

    (58) condition -> FOR ids ASSIGN expressions TO expressions DO block .

    READ            reduce using rule 58 (condition -> FOR ids ASSIGN expressions TO expressions DO block .)
    WRITE           reduce using rule 58 (condition -> FOR ids ASSIGN expressions TO expressions DO block .)
    IF              reduce using rule 58 (condition -> FOR ids ASSIGN expressions TO expressions DO block .)
    WHILE           reduce using rule 58 (condition -> FOR ids ASSIGN expressions TO expressions DO block .)
    FOR             reduce using rule 58 (condition -> FOR ids ASSIGN expressions TO expressions DO block .)
    RETURN          reduce using rule 58 (condition -> FOR ids ASSIGN expressions TO expressions DO block .)
    ID              reduce using rule 58 (condition -> FOR ids ASSIGN expressions TO expressions DO block .)
    CLOSE_BRACES    reduce using rule 58 (condition -> FOR ids ASSIGN expressions TO expressions DO block .)


state 224

    (8) funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block .

    VOID            reduce using rule 8 (funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block .)
    INT             reduce using rule 8 (funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block .)
    FLOAT           reduce using rule 8 (funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block .)
    CHAR            reduce using rule 8 (funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block .)
    MAIN            reduce using rule 8 (funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block .)
    OPEN_BRACES     reduce using rule 8 (funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block .)


state 225

    (55) condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE g_else_quad block . end_if
    (54) end_if -> .

    READ            reduce using rule 54 (end_if -> .)
    WRITE           reduce using rule 54 (end_if -> .)
    IF              reduce using rule 54 (end_if -> .)
    WHILE           reduce using rule 54 (end_if -> .)
    FOR             reduce using rule 54 (end_if -> .)
    RETURN          reduce using rule 54 (end_if -> .)
    ID              reduce using rule 54 (end_if -> .)
    CLOSE_BRACES    reduce using rule 54 (end_if -> .)

    end_if                         shift and go to state 226

state 226

    (55) condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE g_else_quad block end_if .

    READ            reduce using rule 55 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE g_else_quad block end_if .)
    WRITE           reduce using rule 55 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE g_else_quad block end_if .)
    IF              reduce using rule 55 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE g_else_quad block end_if .)
    WHILE           reduce using rule 55 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE g_else_quad block end_if .)
    FOR             reduce using rule 55 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE g_else_quad block end_if .)
    RETURN          reduce using rule 55 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE g_else_quad block end_if .)
    ID              reduce using rule 55 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE g_else_quad block end_if .)
    CLOSE_BRACES    reduce using rule 55 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE g_else_quad block end_if .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for INT in state 34 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 34 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 34 resolved as shift
WARNING: shift/reduce conflict for OPEN_PAREN in state 110 resolved as shift
WARNING: shift/reduce conflict for INT in state 131 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 131 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 131 resolved as shift
WARNING: shift/reduce conflict for THEN in state 157 resolved as shift
