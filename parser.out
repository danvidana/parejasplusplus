Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID add_program SEMICOLON vars funcs main end_program
Rule 2     add_program -> <empty>
Rule 3     end_program -> <empty>
Rule 4     main -> MAIN main_start OPEN_PAREN CLOSE_PAREN block
Rule 5     main_start -> <empty>
Rule 6     funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block
Rule 7     funcs -> empty
Rule 8     add_module -> <empty>
Rule 9     funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block
Rule 10    funcs_params -> var_type variable_params funcs_params_comp
Rule 11    funcs_params -> empty
Rule 12    funcs_params_comp -> COMMA var_type variable_params funcs_params_comp
Rule 13    funcs_params_comp -> empty
Rule 14    variable_params -> ID
Rule 15    variable_params -> ID dim
Rule 16    block -> OPEN_BRACES statements CLOSE_BRACES
Rule 17    func_type -> var_type
Rule 18    func_type -> VOID
Rule 19    var_type -> INT
Rule 20    var_type -> FLOAT
Rule 21    var_type -> CHAR
Rule 22    vars -> VARS var_comp
Rule 23    vars -> empty
Rule 24    var_comp -> var_type ids_dec var_comp_2 var_comp_final
Rule 25    var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive
Rule 26    var_comp_2 -> COMMA ids_dec var_comp_3
Rule 27    var_comp_2 -> empty
Rule 28    var_comp_3 -> var_comp_2
Rule 29    var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final
Rule 30    var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive
Rule 31    var_comp_final -> SEMICOLON
Rule 32    var_comp_final -> var_module_trans
Rule 33    var_module_trans -> SEMICOLON var_type MODULE funcs_comp
Rule 34    ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
Rule 35    ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS
Rule 36    ids_dec -> ID
Rule 37    ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
Rule 38    ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS
Rule 39    ids -> ID
Rule 40    statements -> assignment SEMICOLON statements
Rule 41    statements -> read SEMICOLON statements
Rule 42    statements -> write SEMICOLON statements
Rule 43    statements -> condition statements
Rule 44    statements -> return SEMICOLON statements
Rule 45    statements -> func_call SEMICOLON statements
Rule 46    statements -> empty
Rule 47    assignment -> ids ASSIGN expressions
Rule 48    read -> READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN
Rule 49    read_comp -> COMMA ids g_quad_read read_comp
Rule 50    read_comp -> empty
Rule 51    g_quad_read -> <empty>
Rule 52    write -> WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
Rule 53    write -> WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN
Rule 54    write_comp -> COMMA CT_STRING g_quad_write_str write_comp
Rule 55    write_comp -> COMMA expressions g_quad_write write_comp
Rule 56    write_comp -> empty
Rule 57    g_quad_write_str -> <empty>
Rule 58    g_quad_write -> <empty>
Rule 59    end_if -> <empty>
Rule 60    condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
Rule 61    condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
Rule 62    condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
Rule 63    condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
Rule 64    g_if_quad -> <empty>
Rule 65    g_else_quad -> <empty>
Rule 66    while_jump -> <empty>
Rule 67    g_while_quad -> <empty>
Rule 68    end_while -> <empty>
Rule 69    validate_for -> <empty>
Rule 70    for_counter_control -> <empty>
Rule 71    for_counter_end -> <empty>
Rule 72    end_for -> <empty>
Rule 73    return -> RETURN OPEN_PAREN exp CLOSE_PAREN
Rule 74    func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN
Rule 75    func_call_comp -> expressions func_call_comp
Rule 76    func_call_comp -> COMMA expressions func_call_comp
Rule 77    func_call_comp -> empty
Rule 78    expressions -> expressions_comp
Rule 79    expressions_comp -> expression_comp_2
Rule 80    expressions_comp -> expression_comp_2 OR expressions_comp
Rule 81    expression_comp_2 -> expression_comp_3
Rule 82    expression_comp_2 -> expression_comp_3 AND expression_comp_2
Rule 83    expression_comp_3 -> exp expressions_op exp g_quad_logic
Rule 84    expression_comp_3 -> exp
Rule 85    g_quad_logic -> <empty>
Rule 86    expressions_op -> LESS_THAN add_op
Rule 87    expressions_op -> LESS_THAN_EQUAL add_op
Rule 88    expressions_op -> MORE_THAN add_op
Rule 89    expressions_op -> MORE_THAN_EQUAL add_op
Rule 90    expressions_op -> EQUALS add_op
Rule 91    expressions_op -> NOT_EQUALS add_op
Rule 92    exp -> term g_quad_exp_as
Rule 93    exp -> term g_quad_exp_as exp_comp
Rule 94    g_quad_exp_as -> <empty>
Rule 95    exp_comp -> PLUS add_op exp
Rule 96    exp_comp -> MINUS add_op exp
Rule 97    term -> factor g_quad_exp_md
Rule 98    term -> factor g_quad_exp_md term_comp
Rule 99    g_quad_exp_md -> <empty>
Rule 100   term_comp -> MULTIPLIES add_op term
Rule 101   term_comp -> DIVIDE add_op term
Rule 102   add_op -> <empty>
Rule 103   factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
Rule 104   factor -> variable
Rule 105   factor -> func_call
Rule 106   factor -> CT_INT add_ct_int
Rule 107   factor -> CT_FLOAT add_ct_float
Rule 108   factor -> CT_CHAR add_ct_char
Rule 109   add_fake -> <empty>
Rule 110   rem_fake -> <empty>
Rule 111   add_ct_int -> <empty>
Rule 112   add_ct_float -> <empty>
Rule 113   add_ct_char -> <empty>
Rule 114   variable -> ID add_id
Rule 115   variable -> ID dim
Rule 116   add_id -> <empty>
Rule 117   dim -> OPEN_BRACKETS exp CLOSE_BRACKETS
Rule 118   empty -> <empty>

Terminals, with rules where they appear

AND                  : 82
ASSIGN               : 47 63
CHAR                 : 21
CLOSE_BRACES         : 16
CLOSE_BRACKETS       : 34 34 35 37 37 38 117
CLOSE_PAREN          : 4 6 9 48 52 53 60 61 62 73 74 103
COMMA                : 12 26 49 54 55 76
CT_CHAR              : 108
CT_FLOAT             : 107
CT_INT               : 34 34 35 106
CT_STRING            : 52 54
DIVIDE               : 101
DO                   : 62 63
ELSE                 : 61
EQUALS               : 90
FLOAT                : 20
FOR                  : 63
ID                   : 1 6 9 14 15 34 35 36 37 38 39 74 114 115
IF                   : 60 61
INT                  : 19
LESS_THAN            : 86
LESS_THAN_EQUAL      : 87
MAIN                 : 4
MINUS                : 96
MODULE               : 6 33
MORE_THAN            : 88
MORE_THAN_EQUAL      : 89
MULTIPLIES           : 100
NOT_EQUALS           : 91
OPEN_BRACES          : 16
OPEN_BRACKETS        : 34 34 35 37 37 38 117
OPEN_PAREN           : 4 6 9 48 52 53 60 61 62 73 74 103
OR                   : 80
PLUS                 : 95
PROGRAM              : 1
READ                 : 48
RETURN               : 73
SEMICOLON            : 1 25 30 31 33 40 41 42 44 45
THEN                 : 60 61
TO                   : 63
VARS                 : 22
VOID                 : 18
WHILE                : 62
WRITE                : 52 53
error                : 

Nonterminals, with rules where they appear

add_ct_char          : 108
add_ct_float         : 107
add_ct_int           : 106
add_fake             : 103
add_id               : 114
add_module           : 6 9
add_op               : 86 87 88 89 90 91 95 96 100 101
add_program          : 1
assignment           : 40
block                : 4 6 9 60 61 61 62 63
condition            : 43
dim                  : 15 115
empty                : 7 11 13 23 27 46 50 56 77
end_for              : 63
end_if               : 60 61
end_program          : 1
end_while            : 62
exp                  : 37 37 38 73 83 83 84 95 96 117
exp_comp             : 93
expression_comp_2    : 79 80 82
expression_comp_3    : 81 82
expressions          : 47 53 55 60 61 62 63 63 75 76 103
expressions_comp     : 78 80
expressions_op       : 83
factor               : 97 98
for_counter_control  : 63
for_counter_end      : 63
func_call            : 45 105
func_call_comp       : 74 75 76
func_type            : 6
funcs                : 1
funcs_comp           : 33
funcs_params         : 6 9
funcs_params_comp    : 10 12
g_else_quad          : 61
g_if_quad            : 60 61
g_quad_exp_as        : 92 93
g_quad_exp_md        : 97 98
g_quad_logic         : 83
g_quad_read          : 48 49
g_quad_write         : 53 55
g_quad_write_str     : 52 54
g_while_quad         : 62
ids                  : 47 48 49 63
ids_dec              : 24 25 26 29 30
main                 : 1
main_start           : 4
program              : 0
read                 : 41
read_comp            : 48 49
rem_fake             : 103
return               : 44
statements           : 16 40 41 42 43 44 45
term                 : 92 93 100 101
term_comp            : 98
validate_for         : 63
var_comp             : 22
var_comp_2           : 24 25 28 29 30
var_comp_3           : 26
var_comp_final       : 24 29
var_comp_recursive   : 25 30
var_module_trans     : 32
var_type             : 10 12 17 24 25 29 30 33
variable             : 104
variable_params      : 10 12
vars                 : 1 6 9
while_jump           : 62
write                : 42
write_comp           : 52 53 54 55

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID add_program SEMICOLON vars funcs main end_program

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID add_program SEMICOLON vars funcs main end_program

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . add_program SEMICOLON vars funcs main end_program
    (2) add_program -> .

    SEMICOLON       reduce using rule 2 (add_program -> .)

    add_program                    shift and go to state 4

state 4

    (1) program -> PROGRAM ID add_program . SEMICOLON vars funcs main end_program

    SEMICOLON       shift and go to state 5


state 5

    (1) program -> PROGRAM ID add_program SEMICOLON . vars funcs main end_program
    (22) vars -> . VARS var_comp
    (23) vars -> . empty
    (118) empty -> .

    VARS            shift and go to state 7
    VOID            reduce using rule 118 (empty -> .)
    INT             reduce using rule 118 (empty -> .)
    FLOAT           reduce using rule 118 (empty -> .)
    CHAR            reduce using rule 118 (empty -> .)
    MAIN            reduce using rule 118 (empty -> .)

    vars                           shift and go to state 6
    empty                          shift and go to state 8

state 6

    (1) program -> PROGRAM ID add_program SEMICOLON vars . funcs main end_program
    (6) funcs -> . func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block
    (7) funcs -> . empty
    (17) func_type -> . var_type
    (18) func_type -> . VOID
    (118) empty -> .
    (19) var_type -> . INT
    (20) var_type -> . FLOAT
    (21) var_type -> . CHAR

    VOID            shift and go to state 13
    MAIN            reduce using rule 118 (empty -> .)
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16

    funcs                          shift and go to state 9
    func_type                      shift and go to state 10
    empty                          shift and go to state 11
    var_type                       shift and go to state 12

state 7

    (22) vars -> VARS . var_comp
    (24) var_comp -> . var_type ids_dec var_comp_2 var_comp_final
    (25) var_comp -> . var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive
    (19) var_type -> . INT
    (20) var_type -> . FLOAT
    (21) var_type -> . CHAR

    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16

    var_comp                       shift and go to state 17
    var_type                       shift and go to state 18

state 8

    (23) vars -> empty .

    VOID            reduce using rule 23 (vars -> empty .)
    INT             reduce using rule 23 (vars -> empty .)
    FLOAT           reduce using rule 23 (vars -> empty .)
    CHAR            reduce using rule 23 (vars -> empty .)
    MAIN            reduce using rule 23 (vars -> empty .)
    OPEN_BRACES     reduce using rule 23 (vars -> empty .)


state 9

    (1) program -> PROGRAM ID add_program SEMICOLON vars funcs . main end_program
    (4) main -> . MAIN main_start OPEN_PAREN CLOSE_PAREN block

    MAIN            shift and go to state 20

    main                           shift and go to state 19

state 10

    (6) funcs -> func_type . MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block

    MODULE          shift and go to state 21


state 11

    (7) funcs -> empty .

    MAIN            reduce using rule 7 (funcs -> empty .)


state 12

    (17) func_type -> var_type .

    MODULE          reduce using rule 17 (func_type -> var_type .)


state 13

    (18) func_type -> VOID .

    MODULE          reduce using rule 18 (func_type -> VOID .)


state 14

    (19) var_type -> INT .

    MODULE          reduce using rule 19 (var_type -> INT .)
    ID              reduce using rule 19 (var_type -> INT .)


state 15

    (20) var_type -> FLOAT .

    MODULE          reduce using rule 20 (var_type -> FLOAT .)
    ID              reduce using rule 20 (var_type -> FLOAT .)


state 16

    (21) var_type -> CHAR .

    MODULE          reduce using rule 21 (var_type -> CHAR .)
    ID              reduce using rule 21 (var_type -> CHAR .)


state 17

    (22) vars -> VARS var_comp .

    VOID            reduce using rule 22 (vars -> VARS var_comp .)
    INT             reduce using rule 22 (vars -> VARS var_comp .)
    FLOAT           reduce using rule 22 (vars -> VARS var_comp .)
    CHAR            reduce using rule 22 (vars -> VARS var_comp .)
    MAIN            reduce using rule 22 (vars -> VARS var_comp .)
    OPEN_BRACES     reduce using rule 22 (vars -> VARS var_comp .)


state 18

    (24) var_comp -> var_type . ids_dec var_comp_2 var_comp_final
    (25) var_comp -> var_type . ids_dec var_comp_2 SEMICOLON var_comp_recursive
    (34) ids_dec -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (35) ids_dec -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (36) ids_dec -> . ID

    ID              shift and go to state 23

    ids_dec                        shift and go to state 22

state 19

    (1) program -> PROGRAM ID add_program SEMICOLON vars funcs main . end_program
    (3) end_program -> .

    $end            reduce using rule 3 (end_program -> .)

    end_program                    shift and go to state 24

state 20

    (4) main -> MAIN . main_start OPEN_PAREN CLOSE_PAREN block
    (5) main_start -> .

    OPEN_PAREN      reduce using rule 5 (main_start -> .)

    main_start                     shift and go to state 25

state 21

    (6) funcs -> func_type MODULE . ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block

    ID              shift and go to state 26


state 22

    (24) var_comp -> var_type ids_dec . var_comp_2 var_comp_final
    (25) var_comp -> var_type ids_dec . var_comp_2 SEMICOLON var_comp_recursive
    (26) var_comp_2 -> . COMMA ids_dec var_comp_3
    (27) var_comp_2 -> . empty
    (118) empty -> .

    COMMA           shift and go to state 28
    SEMICOLON       reduce using rule 118 (empty -> .)

    var_comp_2                     shift and go to state 27
    empty                          shift and go to state 29

state 23

    (34) ids_dec -> ID . OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (35) ids_dec -> ID . OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (36) ids_dec -> ID .

    OPEN_BRACKETS   shift and go to state 30
    COMMA           reduce using rule 36 (ids_dec -> ID .)
    SEMICOLON       reduce using rule 36 (ids_dec -> ID .)


state 24

    (1) program -> PROGRAM ID add_program SEMICOLON vars funcs main end_program .

    $end            reduce using rule 1 (program -> PROGRAM ID add_program SEMICOLON vars funcs main end_program .)


state 25

    (4) main -> MAIN main_start . OPEN_PAREN CLOSE_PAREN block

    OPEN_PAREN      shift and go to state 31


state 26

    (6) funcs -> func_type MODULE ID . add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block
    (8) add_module -> .

    OPEN_PAREN      reduce using rule 8 (add_module -> .)

    add_module                     shift and go to state 32

state 27

    (24) var_comp -> var_type ids_dec var_comp_2 . var_comp_final
    (25) var_comp -> var_type ids_dec var_comp_2 . SEMICOLON var_comp_recursive
    (31) var_comp_final -> . SEMICOLON
    (32) var_comp_final -> . var_module_trans
    (33) var_module_trans -> . SEMICOLON var_type MODULE funcs_comp

    SEMICOLON       shift and go to state 34

    var_comp_final                 shift and go to state 33
    var_module_trans               shift and go to state 35

state 28

    (26) var_comp_2 -> COMMA . ids_dec var_comp_3
    (34) ids_dec -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (35) ids_dec -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (36) ids_dec -> . ID

    ID              shift and go to state 23

    ids_dec                        shift and go to state 36

state 29

    (27) var_comp_2 -> empty .

    SEMICOLON       reduce using rule 27 (var_comp_2 -> empty .)


state 30

    (34) ids_dec -> ID OPEN_BRACKETS . CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (35) ids_dec -> ID OPEN_BRACKETS . CT_INT CLOSE_BRACKETS

    CT_INT          shift and go to state 37


state 31

    (4) main -> MAIN main_start OPEN_PAREN . CLOSE_PAREN block

    CLOSE_PAREN     shift and go to state 38


state 32

    (6) funcs -> func_type MODULE ID add_module . OPEN_PAREN funcs_params CLOSE_PAREN vars block

    OPEN_PAREN      shift and go to state 39


state 33

    (24) var_comp -> var_type ids_dec var_comp_2 var_comp_final .

    VOID            reduce using rule 24 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)
    INT             reduce using rule 24 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)
    FLOAT           reduce using rule 24 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)
    CHAR            reduce using rule 24 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)
    MAIN            reduce using rule 24 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)
    OPEN_BRACES     reduce using rule 24 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)


state 34

    (25) var_comp -> var_type ids_dec var_comp_2 SEMICOLON . var_comp_recursive
    (31) var_comp_final -> SEMICOLON .
    (33) var_module_trans -> SEMICOLON . var_type MODULE funcs_comp
    (29) var_comp_recursive -> . var_type ids_dec var_comp_2 var_comp_final
    (30) var_comp_recursive -> . var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive
    (19) var_type -> . INT
    (20) var_type -> . FLOAT
    (21) var_type -> . CHAR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
    VOID            reduce using rule 31 (var_comp_final -> SEMICOLON .)
    MAIN            reduce using rule 31 (var_comp_final -> SEMICOLON .)
    OPEN_BRACES     reduce using rule 31 (var_comp_final -> SEMICOLON .)
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16

  ! INT             [ reduce using rule 31 (var_comp_final -> SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 31 (var_comp_final -> SEMICOLON .) ]
  ! CHAR            [ reduce using rule 31 (var_comp_final -> SEMICOLON .) ]

    var_type                       shift and go to state 40
    var_comp_recursive             shift and go to state 41

state 35

    (32) var_comp_final -> var_module_trans .

    VOID            reduce using rule 32 (var_comp_final -> var_module_trans .)
    INT             reduce using rule 32 (var_comp_final -> var_module_trans .)
    FLOAT           reduce using rule 32 (var_comp_final -> var_module_trans .)
    CHAR            reduce using rule 32 (var_comp_final -> var_module_trans .)
    MAIN            reduce using rule 32 (var_comp_final -> var_module_trans .)
    OPEN_BRACES     reduce using rule 32 (var_comp_final -> var_module_trans .)


state 36

    (26) var_comp_2 -> COMMA ids_dec . var_comp_3
    (28) var_comp_3 -> . var_comp_2
    (26) var_comp_2 -> . COMMA ids_dec var_comp_3
    (27) var_comp_2 -> . empty
    (118) empty -> .

    COMMA           shift and go to state 28
    SEMICOLON       reduce using rule 118 (empty -> .)

    var_comp_3                     shift and go to state 42
    var_comp_2                     shift and go to state 43
    empty                          shift and go to state 29

state 37

    (34) ids_dec -> ID OPEN_BRACKETS CT_INT . CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (35) ids_dec -> ID OPEN_BRACKETS CT_INT . CLOSE_BRACKETS

    CLOSE_BRACKETS  shift and go to state 44


state 38

    (4) main -> MAIN main_start OPEN_PAREN CLOSE_PAREN . block
    (16) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 46

    block                          shift and go to state 45

state 39

    (6) funcs -> func_type MODULE ID add_module OPEN_PAREN . funcs_params CLOSE_PAREN vars block
    (10) funcs_params -> . var_type variable_params funcs_params_comp
    (11) funcs_params -> . empty
    (19) var_type -> . INT
    (20) var_type -> . FLOAT
    (21) var_type -> . CHAR
    (118) empty -> .

    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16
    CLOSE_PAREN     reduce using rule 118 (empty -> .)

    funcs_params                   shift and go to state 47
    var_type                       shift and go to state 48
    empty                          shift and go to state 49

state 40

    (33) var_module_trans -> SEMICOLON var_type . MODULE funcs_comp
    (29) var_comp_recursive -> var_type . ids_dec var_comp_2 var_comp_final
    (30) var_comp_recursive -> var_type . ids_dec var_comp_2 SEMICOLON var_comp_recursive
    (34) ids_dec -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (35) ids_dec -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (36) ids_dec -> . ID

    MODULE          shift and go to state 50
    ID              shift and go to state 23

    ids_dec                        shift and go to state 51

state 41

    (25) var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .

    VOID            reduce using rule 25 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    INT             reduce using rule 25 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    FLOAT           reduce using rule 25 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    CHAR            reduce using rule 25 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    MAIN            reduce using rule 25 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    OPEN_BRACES     reduce using rule 25 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)


state 42

    (26) var_comp_2 -> COMMA ids_dec var_comp_3 .

    SEMICOLON       reduce using rule 26 (var_comp_2 -> COMMA ids_dec var_comp_3 .)


state 43

    (28) var_comp_3 -> var_comp_2 .

    SEMICOLON       reduce using rule 28 (var_comp_3 -> var_comp_2 .)


state 44

    (34) ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS . OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (35) ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS .

    OPEN_BRACKETS   shift and go to state 52
    COMMA           reduce using rule 35 (ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS .)
    SEMICOLON       reduce using rule 35 (ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS .)


state 45

    (4) main -> MAIN main_start OPEN_PAREN CLOSE_PAREN block .

    $end            reduce using rule 4 (main -> MAIN main_start OPEN_PAREN CLOSE_PAREN block .)


state 46

    (16) block -> OPEN_BRACES . statements CLOSE_BRACES
    (40) statements -> . assignment SEMICOLON statements
    (41) statements -> . read SEMICOLON statements
    (42) statements -> . write SEMICOLON statements
    (43) statements -> . condition statements
    (44) statements -> . return SEMICOLON statements
    (45) statements -> . func_call SEMICOLON statements
    (46) statements -> . empty
    (47) assignment -> . ids ASSIGN expressions
    (48) read -> . READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN
    (52) write -> . WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (53) write -> . WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN
    (60) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (61) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
    (62) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
    (63) condition -> . FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (73) return -> . RETURN OPEN_PAREN exp CLOSE_PAREN
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN
    (118) empty -> .
    (37) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (38) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (39) ids -> . ID

    READ            shift and go to state 62
    WRITE           shift and go to state 63
    IF              shift and go to state 64
    WHILE           shift and go to state 65
    FOR             shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 68
    CLOSE_BRACES    reduce using rule 118 (empty -> .)

    statements                     shift and go to state 53
    assignment                     shift and go to state 54
    read                           shift and go to state 55
    write                          shift and go to state 56
    condition                      shift and go to state 57
    return                         shift and go to state 58
    func_call                      shift and go to state 59
    empty                          shift and go to state 60
    ids                            shift and go to state 61

state 47

    (6) funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params . CLOSE_PAREN vars block

    CLOSE_PAREN     shift and go to state 69


state 48

    (10) funcs_params -> var_type . variable_params funcs_params_comp
    (14) variable_params -> . ID
    (15) variable_params -> . ID dim

    ID              shift and go to state 71

    variable_params                shift and go to state 70

state 49

    (11) funcs_params -> empty .

    CLOSE_PAREN     reduce using rule 11 (funcs_params -> empty .)


state 50

    (33) var_module_trans -> SEMICOLON var_type MODULE . funcs_comp
    (9) funcs_comp -> . ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block

    ID              shift and go to state 73

    funcs_comp                     shift and go to state 72

state 51

    (29) var_comp_recursive -> var_type ids_dec . var_comp_2 var_comp_final
    (30) var_comp_recursive -> var_type ids_dec . var_comp_2 SEMICOLON var_comp_recursive
    (26) var_comp_2 -> . COMMA ids_dec var_comp_3
    (27) var_comp_2 -> . empty
    (118) empty -> .

    COMMA           shift and go to state 28
    SEMICOLON       reduce using rule 118 (empty -> .)

    var_comp_2                     shift and go to state 74
    empty                          shift and go to state 29

state 52

    (34) ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS . CT_INT CLOSE_BRACKETS

    CT_INT          shift and go to state 75


state 53

    (16) block -> OPEN_BRACES statements . CLOSE_BRACES

    CLOSE_BRACES    shift and go to state 76


state 54

    (40) statements -> assignment . SEMICOLON statements

    SEMICOLON       shift and go to state 77


state 55

    (41) statements -> read . SEMICOLON statements

    SEMICOLON       shift and go to state 78


state 56

    (42) statements -> write . SEMICOLON statements

    SEMICOLON       shift and go to state 79


state 57

    (43) statements -> condition . statements
    (40) statements -> . assignment SEMICOLON statements
    (41) statements -> . read SEMICOLON statements
    (42) statements -> . write SEMICOLON statements
    (43) statements -> . condition statements
    (44) statements -> . return SEMICOLON statements
    (45) statements -> . func_call SEMICOLON statements
    (46) statements -> . empty
    (47) assignment -> . ids ASSIGN expressions
    (48) read -> . READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN
    (52) write -> . WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (53) write -> . WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN
    (60) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (61) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
    (62) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
    (63) condition -> . FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (73) return -> . RETURN OPEN_PAREN exp CLOSE_PAREN
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN
    (118) empty -> .
    (37) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (38) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (39) ids -> . ID

    READ            shift and go to state 62
    WRITE           shift and go to state 63
    IF              shift and go to state 64
    WHILE           shift and go to state 65
    FOR             shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 68
    CLOSE_BRACES    reduce using rule 118 (empty -> .)

    condition                      shift and go to state 57
    statements                     shift and go to state 80
    assignment                     shift and go to state 54
    read                           shift and go to state 55
    write                          shift and go to state 56
    return                         shift and go to state 58
    func_call                      shift and go to state 59
    empty                          shift and go to state 60
    ids                            shift and go to state 61

state 58

    (44) statements -> return . SEMICOLON statements

    SEMICOLON       shift and go to state 81


state 59

    (45) statements -> func_call . SEMICOLON statements

    SEMICOLON       shift and go to state 82


state 60

    (46) statements -> empty .

    CLOSE_BRACES    reduce using rule 46 (statements -> empty .)


state 61

    (47) assignment -> ids . ASSIGN expressions

    ASSIGN          shift and go to state 83


state 62

    (48) read -> READ . OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 84


state 63

    (52) write -> WRITE . OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (53) write -> WRITE . OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 85


state 64

    (60) condition -> IF . OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (61) condition -> IF . OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if

    OPEN_PAREN      shift and go to state 86


state 65

    (62) condition -> WHILE . while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
    (66) while_jump -> .

    OPEN_PAREN      reduce using rule 66 (while_jump -> .)

    while_jump                     shift and go to state 87

state 66

    (63) condition -> FOR . ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (37) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (38) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (39) ids -> . ID

    ID              shift and go to state 89

    ids                            shift and go to state 88

state 67

    (73) return -> RETURN . OPEN_PAREN exp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 90


state 68

    (74) func_call -> ID . OPEN_PAREN func_call_comp CLOSE_PAREN
    (37) ids -> ID . OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (38) ids -> ID . OPEN_BRACKETS exp CLOSE_BRACKETS
    (39) ids -> ID .

    OPEN_PAREN      shift and go to state 91
    OPEN_BRACKETS   shift and go to state 92
    ASSIGN          reduce using rule 39 (ids -> ID .)


state 69

    (6) funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN . vars block
    (22) vars -> . VARS var_comp
    (23) vars -> . empty
    (118) empty -> .

    VARS            shift and go to state 7
    OPEN_BRACES     reduce using rule 118 (empty -> .)

    vars                           shift and go to state 93
    empty                          shift and go to state 8

state 70

    (10) funcs_params -> var_type variable_params . funcs_params_comp
    (12) funcs_params_comp -> . COMMA var_type variable_params funcs_params_comp
    (13) funcs_params_comp -> . empty
    (118) empty -> .

    COMMA           shift and go to state 95
    CLOSE_PAREN     reduce using rule 118 (empty -> .)

    funcs_params_comp              shift and go to state 94
    empty                          shift and go to state 96

state 71

    (14) variable_params -> ID .
    (15) variable_params -> ID . dim
    (117) dim -> . OPEN_BRACKETS exp CLOSE_BRACKETS

    COMMA           reduce using rule 14 (variable_params -> ID .)
    CLOSE_PAREN     reduce using rule 14 (variable_params -> ID .)
    OPEN_BRACKETS   shift and go to state 98

    dim                            shift and go to state 97

state 72

    (33) var_module_trans -> SEMICOLON var_type MODULE funcs_comp .

    VOID            reduce using rule 33 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)
    INT             reduce using rule 33 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)
    FLOAT           reduce using rule 33 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)
    CHAR            reduce using rule 33 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)
    MAIN            reduce using rule 33 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)
    OPEN_BRACES     reduce using rule 33 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)


state 73

    (9) funcs_comp -> ID . add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block
    (8) add_module -> .

    OPEN_PAREN      reduce using rule 8 (add_module -> .)

    add_module                     shift and go to state 99

state 74

    (29) var_comp_recursive -> var_type ids_dec var_comp_2 . var_comp_final
    (30) var_comp_recursive -> var_type ids_dec var_comp_2 . SEMICOLON var_comp_recursive
    (31) var_comp_final -> . SEMICOLON
    (32) var_comp_final -> . var_module_trans
    (33) var_module_trans -> . SEMICOLON var_type MODULE funcs_comp

    SEMICOLON       shift and go to state 101

    var_comp_final                 shift and go to state 100
    var_module_trans               shift and go to state 35

state 75

    (34) ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT . CLOSE_BRACKETS

    CLOSE_BRACKETS  shift and go to state 102


state 76

    (16) block -> OPEN_BRACES statements CLOSE_BRACES .

    $end            reduce using rule 16 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    MAIN            reduce using rule 16 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    ELSE            reduce using rule 16 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    READ            reduce using rule 16 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    WRITE           reduce using rule 16 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    IF              reduce using rule 16 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    WHILE           reduce using rule 16 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    FOR             reduce using rule 16 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    RETURN          reduce using rule 16 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    ID              reduce using rule 16 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    CLOSE_BRACES    reduce using rule 16 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    VOID            reduce using rule 16 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    INT             reduce using rule 16 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    FLOAT           reduce using rule 16 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    CHAR            reduce using rule 16 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    OPEN_BRACES     reduce using rule 16 (block -> OPEN_BRACES statements CLOSE_BRACES .)


state 77

    (40) statements -> assignment SEMICOLON . statements
    (40) statements -> . assignment SEMICOLON statements
    (41) statements -> . read SEMICOLON statements
    (42) statements -> . write SEMICOLON statements
    (43) statements -> . condition statements
    (44) statements -> . return SEMICOLON statements
    (45) statements -> . func_call SEMICOLON statements
    (46) statements -> . empty
    (47) assignment -> . ids ASSIGN expressions
    (48) read -> . READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN
    (52) write -> . WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (53) write -> . WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN
    (60) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (61) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
    (62) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
    (63) condition -> . FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (73) return -> . RETURN OPEN_PAREN exp CLOSE_PAREN
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN
    (118) empty -> .
    (37) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (38) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (39) ids -> . ID

    READ            shift and go to state 62
    WRITE           shift and go to state 63
    IF              shift and go to state 64
    WHILE           shift and go to state 65
    FOR             shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 68
    CLOSE_BRACES    reduce using rule 118 (empty -> .)

    assignment                     shift and go to state 54
    statements                     shift and go to state 103
    read                           shift and go to state 55
    write                          shift and go to state 56
    condition                      shift and go to state 57
    return                         shift and go to state 58
    func_call                      shift and go to state 59
    empty                          shift and go to state 60
    ids                            shift and go to state 61

state 78

    (41) statements -> read SEMICOLON . statements
    (40) statements -> . assignment SEMICOLON statements
    (41) statements -> . read SEMICOLON statements
    (42) statements -> . write SEMICOLON statements
    (43) statements -> . condition statements
    (44) statements -> . return SEMICOLON statements
    (45) statements -> . func_call SEMICOLON statements
    (46) statements -> . empty
    (47) assignment -> . ids ASSIGN expressions
    (48) read -> . READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN
    (52) write -> . WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (53) write -> . WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN
    (60) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (61) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
    (62) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
    (63) condition -> . FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (73) return -> . RETURN OPEN_PAREN exp CLOSE_PAREN
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN
    (118) empty -> .
    (37) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (38) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (39) ids -> . ID

    READ            shift and go to state 62
    WRITE           shift and go to state 63
    IF              shift and go to state 64
    WHILE           shift and go to state 65
    FOR             shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 68
    CLOSE_BRACES    reduce using rule 118 (empty -> .)

    read                           shift and go to state 55
    statements                     shift and go to state 104
    assignment                     shift and go to state 54
    write                          shift and go to state 56
    condition                      shift and go to state 57
    return                         shift and go to state 58
    func_call                      shift and go to state 59
    empty                          shift and go to state 60
    ids                            shift and go to state 61

state 79

    (42) statements -> write SEMICOLON . statements
    (40) statements -> . assignment SEMICOLON statements
    (41) statements -> . read SEMICOLON statements
    (42) statements -> . write SEMICOLON statements
    (43) statements -> . condition statements
    (44) statements -> . return SEMICOLON statements
    (45) statements -> . func_call SEMICOLON statements
    (46) statements -> . empty
    (47) assignment -> . ids ASSIGN expressions
    (48) read -> . READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN
    (52) write -> . WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (53) write -> . WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN
    (60) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (61) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
    (62) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
    (63) condition -> . FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (73) return -> . RETURN OPEN_PAREN exp CLOSE_PAREN
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN
    (118) empty -> .
    (37) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (38) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (39) ids -> . ID

    READ            shift and go to state 62
    WRITE           shift and go to state 63
    IF              shift and go to state 64
    WHILE           shift and go to state 65
    FOR             shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 68
    CLOSE_BRACES    reduce using rule 118 (empty -> .)

    write                          shift and go to state 56
    statements                     shift and go to state 105
    assignment                     shift and go to state 54
    read                           shift and go to state 55
    condition                      shift and go to state 57
    return                         shift and go to state 58
    func_call                      shift and go to state 59
    empty                          shift and go to state 60
    ids                            shift and go to state 61

state 80

    (43) statements -> condition statements .

    CLOSE_BRACES    reduce using rule 43 (statements -> condition statements .)


state 81

    (44) statements -> return SEMICOLON . statements
    (40) statements -> . assignment SEMICOLON statements
    (41) statements -> . read SEMICOLON statements
    (42) statements -> . write SEMICOLON statements
    (43) statements -> . condition statements
    (44) statements -> . return SEMICOLON statements
    (45) statements -> . func_call SEMICOLON statements
    (46) statements -> . empty
    (47) assignment -> . ids ASSIGN expressions
    (48) read -> . READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN
    (52) write -> . WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (53) write -> . WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN
    (60) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (61) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
    (62) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
    (63) condition -> . FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (73) return -> . RETURN OPEN_PAREN exp CLOSE_PAREN
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN
    (118) empty -> .
    (37) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (38) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (39) ids -> . ID

    READ            shift and go to state 62
    WRITE           shift and go to state 63
    IF              shift and go to state 64
    WHILE           shift and go to state 65
    FOR             shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 68
    CLOSE_BRACES    reduce using rule 118 (empty -> .)

    return                         shift and go to state 58
    statements                     shift and go to state 106
    assignment                     shift and go to state 54
    read                           shift and go to state 55
    write                          shift and go to state 56
    condition                      shift and go to state 57
    func_call                      shift and go to state 59
    empty                          shift and go to state 60
    ids                            shift and go to state 61

state 82

    (45) statements -> func_call SEMICOLON . statements
    (40) statements -> . assignment SEMICOLON statements
    (41) statements -> . read SEMICOLON statements
    (42) statements -> . write SEMICOLON statements
    (43) statements -> . condition statements
    (44) statements -> . return SEMICOLON statements
    (45) statements -> . func_call SEMICOLON statements
    (46) statements -> . empty
    (47) assignment -> . ids ASSIGN expressions
    (48) read -> . READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN
    (52) write -> . WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (53) write -> . WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN
    (60) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (61) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
    (62) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
    (63) condition -> . FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (73) return -> . RETURN OPEN_PAREN exp CLOSE_PAREN
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN
    (118) empty -> .
    (37) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (38) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (39) ids -> . ID

    READ            shift and go to state 62
    WRITE           shift and go to state 63
    IF              shift and go to state 64
    WHILE           shift and go to state 65
    FOR             shift and go to state 66
    RETURN          shift and go to state 67
    ID              shift and go to state 68
    CLOSE_BRACES    reduce using rule 118 (empty -> .)

    func_call                      shift and go to state 59
    statements                     shift and go to state 107
    assignment                     shift and go to state 54
    read                           shift and go to state 55
    write                          shift and go to state 56
    condition                      shift and go to state 57
    return                         shift and go to state 58
    empty                          shift and go to state 60
    ids                            shift and go to state 61

state 83

    (47) assignment -> ids ASSIGN . expressions
    (78) expressions -> . expressions_comp
    (79) expressions_comp -> . expression_comp_2
    (80) expressions_comp -> . expression_comp_2 OR expressions_comp
    (81) expression_comp_2 -> . expression_comp_3
    (82) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (83) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (84) expression_comp_3 -> . exp
    (92) exp -> . term g_quad_exp_as
    (93) exp -> . term g_quad_exp_as exp_comp
    (97) term -> . factor g_quad_exp_md
    (98) term -> . factor g_quad_exp_md term_comp
    (103) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (104) factor -> . variable
    (105) factor -> . func_call
    (106) factor -> . CT_INT add_ct_int
    (107) factor -> . CT_FLOAT add_ct_float
    (108) factor -> . CT_CHAR add_ct_char
    (114) variable -> . ID add_id
    (115) variable -> . ID dim
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 115
    CT_INT          shift and go to state 118
    CT_FLOAT        shift and go to state 119
    CT_CHAR         shift and go to state 120
    ID              shift and go to state 121

    expressions                    shift and go to state 108
    expressions_comp               shift and go to state 109
    expression_comp_2              shift and go to state 110
    expression_comp_3              shift and go to state 111
    exp                            shift and go to state 112
    term                           shift and go to state 113
    factor                         shift and go to state 114
    variable                       shift and go to state 116
    func_call                      shift and go to state 117

state 84

    (48) read -> READ OPEN_PAREN . ids g_quad_read read_comp CLOSE_PAREN
    (37) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (38) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (39) ids -> . ID

    ID              shift and go to state 89

    ids                            shift and go to state 122

state 85

    (52) write -> WRITE OPEN_PAREN . CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (53) write -> WRITE OPEN_PAREN . expressions g_quad_write write_comp CLOSE_PAREN
    (78) expressions -> . expressions_comp
    (79) expressions_comp -> . expression_comp_2
    (80) expressions_comp -> . expression_comp_2 OR expressions_comp
    (81) expression_comp_2 -> . expression_comp_3
    (82) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (83) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (84) expression_comp_3 -> . exp
    (92) exp -> . term g_quad_exp_as
    (93) exp -> . term g_quad_exp_as exp_comp
    (97) term -> . factor g_quad_exp_md
    (98) term -> . factor g_quad_exp_md term_comp
    (103) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (104) factor -> . variable
    (105) factor -> . func_call
    (106) factor -> . CT_INT add_ct_int
    (107) factor -> . CT_FLOAT add_ct_float
    (108) factor -> . CT_CHAR add_ct_char
    (114) variable -> . ID add_id
    (115) variable -> . ID dim
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    CT_STRING       shift and go to state 123
    OPEN_PAREN      shift and go to state 115
    CT_INT          shift and go to state 118
    CT_FLOAT        shift and go to state 119
    CT_CHAR         shift and go to state 120
    ID              shift and go to state 121

    expressions                    shift and go to state 124
    expressions_comp               shift and go to state 109
    expression_comp_2              shift and go to state 110
    expression_comp_3              shift and go to state 111
    exp                            shift and go to state 112
    term                           shift and go to state 113
    factor                         shift and go to state 114
    variable                       shift and go to state 116
    func_call                      shift and go to state 117

state 86

    (60) condition -> IF OPEN_PAREN . expressions CLOSE_PAREN g_if_quad THEN block end_if
    (61) condition -> IF OPEN_PAREN . expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
    (78) expressions -> . expressions_comp
    (79) expressions_comp -> . expression_comp_2
    (80) expressions_comp -> . expression_comp_2 OR expressions_comp
    (81) expression_comp_2 -> . expression_comp_3
    (82) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (83) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (84) expression_comp_3 -> . exp
    (92) exp -> . term g_quad_exp_as
    (93) exp -> . term g_quad_exp_as exp_comp
    (97) term -> . factor g_quad_exp_md
    (98) term -> . factor g_quad_exp_md term_comp
    (103) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (104) factor -> . variable
    (105) factor -> . func_call
    (106) factor -> . CT_INT add_ct_int
    (107) factor -> . CT_FLOAT add_ct_float
    (108) factor -> . CT_CHAR add_ct_char
    (114) variable -> . ID add_id
    (115) variable -> . ID dim
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 115
    CT_INT          shift and go to state 118
    CT_FLOAT        shift and go to state 119
    CT_CHAR         shift and go to state 120
    ID              shift and go to state 121

    expressions                    shift and go to state 125
    expressions_comp               shift and go to state 109
    expression_comp_2              shift and go to state 110
    expression_comp_3              shift and go to state 111
    exp                            shift and go to state 112
    term                           shift and go to state 113
    factor                         shift and go to state 114
    variable                       shift and go to state 116
    func_call                      shift and go to state 117

state 87

    (62) condition -> WHILE while_jump . OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while

    OPEN_PAREN      shift and go to state 126


state 88

    (63) condition -> FOR ids . validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (69) validate_for -> .

    ASSIGN          reduce using rule 69 (validate_for -> .)

    validate_for                   shift and go to state 127

state 89

    (37) ids -> ID . OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (38) ids -> ID . OPEN_BRACKETS exp CLOSE_BRACKETS
    (39) ids -> ID .

    OPEN_BRACKETS   shift and go to state 92
    ASSIGN          reduce using rule 39 (ids -> ID .)
    COMMA           reduce using rule 39 (ids -> ID .)
    CLOSE_PAREN     reduce using rule 39 (ids -> ID .)


state 90

    (73) return -> RETURN OPEN_PAREN . exp CLOSE_PAREN
    (92) exp -> . term g_quad_exp_as
    (93) exp -> . term g_quad_exp_as exp_comp
    (97) term -> . factor g_quad_exp_md
    (98) term -> . factor g_quad_exp_md term_comp
    (103) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (104) factor -> . variable
    (105) factor -> . func_call
    (106) factor -> . CT_INT add_ct_int
    (107) factor -> . CT_FLOAT add_ct_float
    (108) factor -> . CT_CHAR add_ct_char
    (114) variable -> . ID add_id
    (115) variable -> . ID dim
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 115
    CT_INT          shift and go to state 118
    CT_FLOAT        shift and go to state 119
    CT_CHAR         shift and go to state 120
    ID              shift and go to state 121

    exp                            shift and go to state 128
    term                           shift and go to state 113
    factor                         shift and go to state 114
    variable                       shift and go to state 116
    func_call                      shift and go to state 117

state 91

    (74) func_call -> ID OPEN_PAREN . func_call_comp CLOSE_PAREN
    (75) func_call_comp -> . expressions func_call_comp
    (76) func_call_comp -> . COMMA expressions func_call_comp
    (77) func_call_comp -> . empty
    (78) expressions -> . expressions_comp
    (118) empty -> .
    (79) expressions_comp -> . expression_comp_2
    (80) expressions_comp -> . expression_comp_2 OR expressions_comp
    (81) expression_comp_2 -> . expression_comp_3
    (82) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (83) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (84) expression_comp_3 -> . exp
    (92) exp -> . term g_quad_exp_as
    (93) exp -> . term g_quad_exp_as exp_comp
    (97) term -> . factor g_quad_exp_md
    (98) term -> . factor g_quad_exp_md term_comp
    (103) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (104) factor -> . variable
    (105) factor -> . func_call
    (106) factor -> . CT_INT add_ct_int
    (107) factor -> . CT_FLOAT add_ct_float
    (108) factor -> . CT_CHAR add_ct_char
    (114) variable -> . ID add_id
    (115) variable -> . ID dim
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    COMMA           shift and go to state 131
    CLOSE_PAREN     reduce using rule 118 (empty -> .)
    OPEN_PAREN      shift and go to state 115
    CT_INT          shift and go to state 118
    CT_FLOAT        shift and go to state 119
    CT_CHAR         shift and go to state 120
    ID              shift and go to state 121

    func_call_comp                 shift and go to state 129
    expressions                    shift and go to state 130
    empty                          shift and go to state 132
    expressions_comp               shift and go to state 109
    expression_comp_2              shift and go to state 110
    expression_comp_3              shift and go to state 111
    exp                            shift and go to state 112
    term                           shift and go to state 113
    factor                         shift and go to state 114
    variable                       shift and go to state 116
    func_call                      shift and go to state 117

state 92

    (37) ids -> ID OPEN_BRACKETS . exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (38) ids -> ID OPEN_BRACKETS . exp CLOSE_BRACKETS
    (92) exp -> . term g_quad_exp_as
    (93) exp -> . term g_quad_exp_as exp_comp
    (97) term -> . factor g_quad_exp_md
    (98) term -> . factor g_quad_exp_md term_comp
    (103) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (104) factor -> . variable
    (105) factor -> . func_call
    (106) factor -> . CT_INT add_ct_int
    (107) factor -> . CT_FLOAT add_ct_float
    (108) factor -> . CT_CHAR add_ct_char
    (114) variable -> . ID add_id
    (115) variable -> . ID dim
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 115
    CT_INT          shift and go to state 118
    CT_FLOAT        shift and go to state 119
    CT_CHAR         shift and go to state 120
    ID              shift and go to state 121

    exp                            shift and go to state 133
    term                           shift and go to state 113
    factor                         shift and go to state 114
    variable                       shift and go to state 116
    func_call                      shift and go to state 117

state 93

    (6) funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars . block
    (16) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 46

    block                          shift and go to state 134

state 94

    (10) funcs_params -> var_type variable_params funcs_params_comp .

    CLOSE_PAREN     reduce using rule 10 (funcs_params -> var_type variable_params funcs_params_comp .)


state 95

    (12) funcs_params_comp -> COMMA . var_type variable_params funcs_params_comp
    (19) var_type -> . INT
    (20) var_type -> . FLOAT
    (21) var_type -> . CHAR

    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16

    var_type                       shift and go to state 135

state 96

    (13) funcs_params_comp -> empty .

    CLOSE_PAREN     reduce using rule 13 (funcs_params_comp -> empty .)


state 97

    (15) variable_params -> ID dim .

    COMMA           reduce using rule 15 (variable_params -> ID dim .)
    CLOSE_PAREN     reduce using rule 15 (variable_params -> ID dim .)


state 98

    (117) dim -> OPEN_BRACKETS . exp CLOSE_BRACKETS
    (92) exp -> . term g_quad_exp_as
    (93) exp -> . term g_quad_exp_as exp_comp
    (97) term -> . factor g_quad_exp_md
    (98) term -> . factor g_quad_exp_md term_comp
    (103) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (104) factor -> . variable
    (105) factor -> . func_call
    (106) factor -> . CT_INT add_ct_int
    (107) factor -> . CT_FLOAT add_ct_float
    (108) factor -> . CT_CHAR add_ct_char
    (114) variable -> . ID add_id
    (115) variable -> . ID dim
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 115
    CT_INT          shift and go to state 118
    CT_FLOAT        shift and go to state 119
    CT_CHAR         shift and go to state 120
    ID              shift and go to state 121

    exp                            shift and go to state 136
    term                           shift and go to state 113
    factor                         shift and go to state 114
    variable                       shift and go to state 116
    func_call                      shift and go to state 117

state 99

    (9) funcs_comp -> ID add_module . OPEN_PAREN funcs_params CLOSE_PAREN vars block

    OPEN_PAREN      shift and go to state 137


state 100

    (29) var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .

    VOID            reduce using rule 29 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)
    INT             reduce using rule 29 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)
    FLOAT           reduce using rule 29 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)
    CHAR            reduce using rule 29 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)
    MAIN            reduce using rule 29 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)
    OPEN_BRACES     reduce using rule 29 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)


state 101

    (30) var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON . var_comp_recursive
    (31) var_comp_final -> SEMICOLON .
    (33) var_module_trans -> SEMICOLON . var_type MODULE funcs_comp
    (29) var_comp_recursive -> . var_type ids_dec var_comp_2 var_comp_final
    (30) var_comp_recursive -> . var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive
    (19) var_type -> . INT
    (20) var_type -> . FLOAT
    (21) var_type -> . CHAR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
    VOID            reduce using rule 31 (var_comp_final -> SEMICOLON .)
    MAIN            reduce using rule 31 (var_comp_final -> SEMICOLON .)
    OPEN_BRACES     reduce using rule 31 (var_comp_final -> SEMICOLON .)
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16

  ! INT             [ reduce using rule 31 (var_comp_final -> SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 31 (var_comp_final -> SEMICOLON .) ]
  ! CHAR            [ reduce using rule 31 (var_comp_final -> SEMICOLON .) ]

    var_type                       shift and go to state 40
    var_comp_recursive             shift and go to state 138

state 102

    (34) ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS .

    COMMA           reduce using rule 34 (ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS .)
    SEMICOLON       reduce using rule 34 (ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS .)


state 103

    (40) statements -> assignment SEMICOLON statements .

    CLOSE_BRACES    reduce using rule 40 (statements -> assignment SEMICOLON statements .)


state 104

    (41) statements -> read SEMICOLON statements .

    CLOSE_BRACES    reduce using rule 41 (statements -> read SEMICOLON statements .)


state 105

    (42) statements -> write SEMICOLON statements .

    CLOSE_BRACES    reduce using rule 42 (statements -> write SEMICOLON statements .)


state 106

    (44) statements -> return SEMICOLON statements .

    CLOSE_BRACES    reduce using rule 44 (statements -> return SEMICOLON statements .)


state 107

    (45) statements -> func_call SEMICOLON statements .

    CLOSE_BRACES    reduce using rule 45 (statements -> func_call SEMICOLON statements .)


state 108

    (47) assignment -> ids ASSIGN expressions .

    SEMICOLON       reduce using rule 47 (assignment -> ids ASSIGN expressions .)


state 109

    (78) expressions -> expressions_comp .

    SEMICOLON       reduce using rule 78 (expressions -> expressions_comp .)
    COMMA           reduce using rule 78 (expressions -> expressions_comp .)
    CLOSE_PAREN     reduce using rule 78 (expressions -> expressions_comp .)
    OPEN_PAREN      reduce using rule 78 (expressions -> expressions_comp .)
    CT_INT          reduce using rule 78 (expressions -> expressions_comp .)
    CT_FLOAT        reduce using rule 78 (expressions -> expressions_comp .)
    CT_CHAR         reduce using rule 78 (expressions -> expressions_comp .)
    ID              reduce using rule 78 (expressions -> expressions_comp .)
    TO              reduce using rule 78 (expressions -> expressions_comp .)
    DO              reduce using rule 78 (expressions -> expressions_comp .)


state 110

    (79) expressions_comp -> expression_comp_2 .
    (80) expressions_comp -> expression_comp_2 . OR expressions_comp

    SEMICOLON       reduce using rule 79 (expressions_comp -> expression_comp_2 .)
    COMMA           reduce using rule 79 (expressions_comp -> expression_comp_2 .)
    CLOSE_PAREN     reduce using rule 79 (expressions_comp -> expression_comp_2 .)
    OPEN_PAREN      reduce using rule 79 (expressions_comp -> expression_comp_2 .)
    CT_INT          reduce using rule 79 (expressions_comp -> expression_comp_2 .)
    CT_FLOAT        reduce using rule 79 (expressions_comp -> expression_comp_2 .)
    CT_CHAR         reduce using rule 79 (expressions_comp -> expression_comp_2 .)
    ID              reduce using rule 79 (expressions_comp -> expression_comp_2 .)
    TO              reduce using rule 79 (expressions_comp -> expression_comp_2 .)
    DO              reduce using rule 79 (expressions_comp -> expression_comp_2 .)
    OR              shift and go to state 139


state 111

    (81) expression_comp_2 -> expression_comp_3 .
    (82) expression_comp_2 -> expression_comp_3 . AND expression_comp_2

    OR              reduce using rule 81 (expression_comp_2 -> expression_comp_3 .)
    SEMICOLON       reduce using rule 81 (expression_comp_2 -> expression_comp_3 .)
    COMMA           reduce using rule 81 (expression_comp_2 -> expression_comp_3 .)
    CLOSE_PAREN     reduce using rule 81 (expression_comp_2 -> expression_comp_3 .)
    OPEN_PAREN      reduce using rule 81 (expression_comp_2 -> expression_comp_3 .)
    CT_INT          reduce using rule 81 (expression_comp_2 -> expression_comp_3 .)
    CT_FLOAT        reduce using rule 81 (expression_comp_2 -> expression_comp_3 .)
    CT_CHAR         reduce using rule 81 (expression_comp_2 -> expression_comp_3 .)
    ID              reduce using rule 81 (expression_comp_2 -> expression_comp_3 .)
    TO              reduce using rule 81 (expression_comp_2 -> expression_comp_3 .)
    DO              reduce using rule 81 (expression_comp_2 -> expression_comp_3 .)
    AND             shift and go to state 140


state 112

    (83) expression_comp_3 -> exp . expressions_op exp g_quad_logic
    (84) expression_comp_3 -> exp .
    (86) expressions_op -> . LESS_THAN add_op
    (87) expressions_op -> . LESS_THAN_EQUAL add_op
    (88) expressions_op -> . MORE_THAN add_op
    (89) expressions_op -> . MORE_THAN_EQUAL add_op
    (90) expressions_op -> . EQUALS add_op
    (91) expressions_op -> . NOT_EQUALS add_op

    AND             reduce using rule 84 (expression_comp_3 -> exp .)
    OR              reduce using rule 84 (expression_comp_3 -> exp .)
    SEMICOLON       reduce using rule 84 (expression_comp_3 -> exp .)
    COMMA           reduce using rule 84 (expression_comp_3 -> exp .)
    CLOSE_PAREN     reduce using rule 84 (expression_comp_3 -> exp .)
    OPEN_PAREN      reduce using rule 84 (expression_comp_3 -> exp .)
    CT_INT          reduce using rule 84 (expression_comp_3 -> exp .)
    CT_FLOAT        reduce using rule 84 (expression_comp_3 -> exp .)
    CT_CHAR         reduce using rule 84 (expression_comp_3 -> exp .)
    ID              reduce using rule 84 (expression_comp_3 -> exp .)
    TO              reduce using rule 84 (expression_comp_3 -> exp .)
    DO              reduce using rule 84 (expression_comp_3 -> exp .)
    LESS_THAN       shift and go to state 142
    LESS_THAN_EQUAL shift and go to state 143
    MORE_THAN       shift and go to state 144
    MORE_THAN_EQUAL shift and go to state 145
    EQUALS          shift and go to state 146
    NOT_EQUALS      shift and go to state 147

    expressions_op                 shift and go to state 141

state 113

    (92) exp -> term . g_quad_exp_as
    (93) exp -> term . g_quad_exp_as exp_comp
    (94) g_quad_exp_as -> .

    PLUS            reduce using rule 94 (g_quad_exp_as -> .)
    MINUS           reduce using rule 94 (g_quad_exp_as -> .)
    LESS_THAN       reduce using rule 94 (g_quad_exp_as -> .)
    LESS_THAN_EQUAL reduce using rule 94 (g_quad_exp_as -> .)
    MORE_THAN       reduce using rule 94 (g_quad_exp_as -> .)
    MORE_THAN_EQUAL reduce using rule 94 (g_quad_exp_as -> .)
    EQUALS          reduce using rule 94 (g_quad_exp_as -> .)
    NOT_EQUALS      reduce using rule 94 (g_quad_exp_as -> .)
    AND             reduce using rule 94 (g_quad_exp_as -> .)
    OR              reduce using rule 94 (g_quad_exp_as -> .)
    SEMICOLON       reduce using rule 94 (g_quad_exp_as -> .)
    COMMA           reduce using rule 94 (g_quad_exp_as -> .)
    CLOSE_PAREN     reduce using rule 94 (g_quad_exp_as -> .)
    OPEN_PAREN      reduce using rule 94 (g_quad_exp_as -> .)
    CT_INT          reduce using rule 94 (g_quad_exp_as -> .)
    CT_FLOAT        reduce using rule 94 (g_quad_exp_as -> .)
    CT_CHAR         reduce using rule 94 (g_quad_exp_as -> .)
    ID              reduce using rule 94 (g_quad_exp_as -> .)
    CLOSE_BRACKETS  reduce using rule 94 (g_quad_exp_as -> .)
    TO              reduce using rule 94 (g_quad_exp_as -> .)
    DO              reduce using rule 94 (g_quad_exp_as -> .)

    g_quad_exp_as                  shift and go to state 148

state 114

    (97) term -> factor . g_quad_exp_md
    (98) term -> factor . g_quad_exp_md term_comp
    (99) g_quad_exp_md -> .

    MULTIPLIES      reduce using rule 99 (g_quad_exp_md -> .)
    DIVIDE          reduce using rule 99 (g_quad_exp_md -> .)
    PLUS            reduce using rule 99 (g_quad_exp_md -> .)
    MINUS           reduce using rule 99 (g_quad_exp_md -> .)
    LESS_THAN       reduce using rule 99 (g_quad_exp_md -> .)
    LESS_THAN_EQUAL reduce using rule 99 (g_quad_exp_md -> .)
    MORE_THAN       reduce using rule 99 (g_quad_exp_md -> .)
    MORE_THAN_EQUAL reduce using rule 99 (g_quad_exp_md -> .)
    EQUALS          reduce using rule 99 (g_quad_exp_md -> .)
    NOT_EQUALS      reduce using rule 99 (g_quad_exp_md -> .)
    AND             reduce using rule 99 (g_quad_exp_md -> .)
    OR              reduce using rule 99 (g_quad_exp_md -> .)
    SEMICOLON       reduce using rule 99 (g_quad_exp_md -> .)
    COMMA           reduce using rule 99 (g_quad_exp_md -> .)
    CLOSE_PAREN     reduce using rule 99 (g_quad_exp_md -> .)
    OPEN_PAREN      reduce using rule 99 (g_quad_exp_md -> .)
    CT_INT          reduce using rule 99 (g_quad_exp_md -> .)
    CT_FLOAT        reduce using rule 99 (g_quad_exp_md -> .)
    CT_CHAR         reduce using rule 99 (g_quad_exp_md -> .)
    ID              reduce using rule 99 (g_quad_exp_md -> .)
    CLOSE_BRACKETS  reduce using rule 99 (g_quad_exp_md -> .)
    TO              reduce using rule 99 (g_quad_exp_md -> .)
    DO              reduce using rule 99 (g_quad_exp_md -> .)

    g_quad_exp_md                  shift and go to state 149

state 115

    (103) factor -> OPEN_PAREN . add_fake expressions CLOSE_PAREN rem_fake
    (109) add_fake -> .

    OPEN_PAREN      reduce using rule 109 (add_fake -> .)
    CT_INT          reduce using rule 109 (add_fake -> .)
    CT_FLOAT        reduce using rule 109 (add_fake -> .)
    CT_CHAR         reduce using rule 109 (add_fake -> .)
    ID              reduce using rule 109 (add_fake -> .)

    add_fake                       shift and go to state 150

state 116

    (104) factor -> variable .

    MULTIPLIES      reduce using rule 104 (factor -> variable .)
    DIVIDE          reduce using rule 104 (factor -> variable .)
    PLUS            reduce using rule 104 (factor -> variable .)
    MINUS           reduce using rule 104 (factor -> variable .)
    LESS_THAN       reduce using rule 104 (factor -> variable .)
    LESS_THAN_EQUAL reduce using rule 104 (factor -> variable .)
    MORE_THAN       reduce using rule 104 (factor -> variable .)
    MORE_THAN_EQUAL reduce using rule 104 (factor -> variable .)
    EQUALS          reduce using rule 104 (factor -> variable .)
    NOT_EQUALS      reduce using rule 104 (factor -> variable .)
    AND             reduce using rule 104 (factor -> variable .)
    OR              reduce using rule 104 (factor -> variable .)
    SEMICOLON       reduce using rule 104 (factor -> variable .)
    COMMA           reduce using rule 104 (factor -> variable .)
    CLOSE_PAREN     reduce using rule 104 (factor -> variable .)
    OPEN_PAREN      reduce using rule 104 (factor -> variable .)
    CT_INT          reduce using rule 104 (factor -> variable .)
    CT_FLOAT        reduce using rule 104 (factor -> variable .)
    CT_CHAR         reduce using rule 104 (factor -> variable .)
    ID              reduce using rule 104 (factor -> variable .)
    CLOSE_BRACKETS  reduce using rule 104 (factor -> variable .)
    TO              reduce using rule 104 (factor -> variable .)
    DO              reduce using rule 104 (factor -> variable .)


state 117

    (105) factor -> func_call .

    MULTIPLIES      reduce using rule 105 (factor -> func_call .)
    DIVIDE          reduce using rule 105 (factor -> func_call .)
    PLUS            reduce using rule 105 (factor -> func_call .)
    MINUS           reduce using rule 105 (factor -> func_call .)
    LESS_THAN       reduce using rule 105 (factor -> func_call .)
    LESS_THAN_EQUAL reduce using rule 105 (factor -> func_call .)
    MORE_THAN       reduce using rule 105 (factor -> func_call .)
    MORE_THAN_EQUAL reduce using rule 105 (factor -> func_call .)
    EQUALS          reduce using rule 105 (factor -> func_call .)
    NOT_EQUALS      reduce using rule 105 (factor -> func_call .)
    AND             reduce using rule 105 (factor -> func_call .)
    OR              reduce using rule 105 (factor -> func_call .)
    SEMICOLON       reduce using rule 105 (factor -> func_call .)
    COMMA           reduce using rule 105 (factor -> func_call .)
    CLOSE_PAREN     reduce using rule 105 (factor -> func_call .)
    OPEN_PAREN      reduce using rule 105 (factor -> func_call .)
    CT_INT          reduce using rule 105 (factor -> func_call .)
    CT_FLOAT        reduce using rule 105 (factor -> func_call .)
    CT_CHAR         reduce using rule 105 (factor -> func_call .)
    ID              reduce using rule 105 (factor -> func_call .)
    CLOSE_BRACKETS  reduce using rule 105 (factor -> func_call .)
    TO              reduce using rule 105 (factor -> func_call .)
    DO              reduce using rule 105 (factor -> func_call .)


state 118

    (106) factor -> CT_INT . add_ct_int
    (111) add_ct_int -> .

    MULTIPLIES      reduce using rule 111 (add_ct_int -> .)
    DIVIDE          reduce using rule 111 (add_ct_int -> .)
    PLUS            reduce using rule 111 (add_ct_int -> .)
    MINUS           reduce using rule 111 (add_ct_int -> .)
    LESS_THAN       reduce using rule 111 (add_ct_int -> .)
    LESS_THAN_EQUAL reduce using rule 111 (add_ct_int -> .)
    MORE_THAN       reduce using rule 111 (add_ct_int -> .)
    MORE_THAN_EQUAL reduce using rule 111 (add_ct_int -> .)
    EQUALS          reduce using rule 111 (add_ct_int -> .)
    NOT_EQUALS      reduce using rule 111 (add_ct_int -> .)
    AND             reduce using rule 111 (add_ct_int -> .)
    OR              reduce using rule 111 (add_ct_int -> .)
    SEMICOLON       reduce using rule 111 (add_ct_int -> .)
    COMMA           reduce using rule 111 (add_ct_int -> .)
    CLOSE_PAREN     reduce using rule 111 (add_ct_int -> .)
    OPEN_PAREN      reduce using rule 111 (add_ct_int -> .)
    CT_INT          reduce using rule 111 (add_ct_int -> .)
    CT_FLOAT        reduce using rule 111 (add_ct_int -> .)
    CT_CHAR         reduce using rule 111 (add_ct_int -> .)
    ID              reduce using rule 111 (add_ct_int -> .)
    CLOSE_BRACKETS  reduce using rule 111 (add_ct_int -> .)
    TO              reduce using rule 111 (add_ct_int -> .)
    DO              reduce using rule 111 (add_ct_int -> .)

    add_ct_int                     shift and go to state 151

state 119

    (107) factor -> CT_FLOAT . add_ct_float
    (112) add_ct_float -> .

    MULTIPLIES      reduce using rule 112 (add_ct_float -> .)
    DIVIDE          reduce using rule 112 (add_ct_float -> .)
    PLUS            reduce using rule 112 (add_ct_float -> .)
    MINUS           reduce using rule 112 (add_ct_float -> .)
    LESS_THAN       reduce using rule 112 (add_ct_float -> .)
    LESS_THAN_EQUAL reduce using rule 112 (add_ct_float -> .)
    MORE_THAN       reduce using rule 112 (add_ct_float -> .)
    MORE_THAN_EQUAL reduce using rule 112 (add_ct_float -> .)
    EQUALS          reduce using rule 112 (add_ct_float -> .)
    NOT_EQUALS      reduce using rule 112 (add_ct_float -> .)
    AND             reduce using rule 112 (add_ct_float -> .)
    OR              reduce using rule 112 (add_ct_float -> .)
    SEMICOLON       reduce using rule 112 (add_ct_float -> .)
    COMMA           reduce using rule 112 (add_ct_float -> .)
    CLOSE_PAREN     reduce using rule 112 (add_ct_float -> .)
    OPEN_PAREN      reduce using rule 112 (add_ct_float -> .)
    CT_INT          reduce using rule 112 (add_ct_float -> .)
    CT_FLOAT        reduce using rule 112 (add_ct_float -> .)
    CT_CHAR         reduce using rule 112 (add_ct_float -> .)
    ID              reduce using rule 112 (add_ct_float -> .)
    CLOSE_BRACKETS  reduce using rule 112 (add_ct_float -> .)
    TO              reduce using rule 112 (add_ct_float -> .)
    DO              reduce using rule 112 (add_ct_float -> .)

    add_ct_float                   shift and go to state 152

state 120

    (108) factor -> CT_CHAR . add_ct_char
    (113) add_ct_char -> .

    MULTIPLIES      reduce using rule 113 (add_ct_char -> .)
    DIVIDE          reduce using rule 113 (add_ct_char -> .)
    PLUS            reduce using rule 113 (add_ct_char -> .)
    MINUS           reduce using rule 113 (add_ct_char -> .)
    LESS_THAN       reduce using rule 113 (add_ct_char -> .)
    LESS_THAN_EQUAL reduce using rule 113 (add_ct_char -> .)
    MORE_THAN       reduce using rule 113 (add_ct_char -> .)
    MORE_THAN_EQUAL reduce using rule 113 (add_ct_char -> .)
    EQUALS          reduce using rule 113 (add_ct_char -> .)
    NOT_EQUALS      reduce using rule 113 (add_ct_char -> .)
    AND             reduce using rule 113 (add_ct_char -> .)
    OR              reduce using rule 113 (add_ct_char -> .)
    SEMICOLON       reduce using rule 113 (add_ct_char -> .)
    COMMA           reduce using rule 113 (add_ct_char -> .)
    CLOSE_PAREN     reduce using rule 113 (add_ct_char -> .)
    OPEN_PAREN      reduce using rule 113 (add_ct_char -> .)
    CT_INT          reduce using rule 113 (add_ct_char -> .)
    CT_FLOAT        reduce using rule 113 (add_ct_char -> .)
    CT_CHAR         reduce using rule 113 (add_ct_char -> .)
    ID              reduce using rule 113 (add_ct_char -> .)
    CLOSE_BRACKETS  reduce using rule 113 (add_ct_char -> .)
    TO              reduce using rule 113 (add_ct_char -> .)
    DO              reduce using rule 113 (add_ct_char -> .)

    add_ct_char                    shift and go to state 153

state 121

    (114) variable -> ID . add_id
    (115) variable -> ID . dim
    (74) func_call -> ID . OPEN_PAREN func_call_comp CLOSE_PAREN
    (116) add_id -> .
    (117) dim -> . OPEN_BRACKETS exp CLOSE_BRACKETS

  ! shift/reduce conflict for OPEN_PAREN resolved as shift
    OPEN_PAREN      shift and go to state 91
    MULTIPLIES      reduce using rule 116 (add_id -> .)
    DIVIDE          reduce using rule 116 (add_id -> .)
    PLUS            reduce using rule 116 (add_id -> .)
    MINUS           reduce using rule 116 (add_id -> .)
    LESS_THAN       reduce using rule 116 (add_id -> .)
    LESS_THAN_EQUAL reduce using rule 116 (add_id -> .)
    MORE_THAN       reduce using rule 116 (add_id -> .)
    MORE_THAN_EQUAL reduce using rule 116 (add_id -> .)
    EQUALS          reduce using rule 116 (add_id -> .)
    NOT_EQUALS      reduce using rule 116 (add_id -> .)
    AND             reduce using rule 116 (add_id -> .)
    OR              reduce using rule 116 (add_id -> .)
    SEMICOLON       reduce using rule 116 (add_id -> .)
    COMMA           reduce using rule 116 (add_id -> .)
    CLOSE_PAREN     reduce using rule 116 (add_id -> .)
    CT_INT          reduce using rule 116 (add_id -> .)
    CT_FLOAT        reduce using rule 116 (add_id -> .)
    CT_CHAR         reduce using rule 116 (add_id -> .)
    ID              reduce using rule 116 (add_id -> .)
    CLOSE_BRACKETS  reduce using rule 116 (add_id -> .)
    TO              reduce using rule 116 (add_id -> .)
    DO              reduce using rule 116 (add_id -> .)
    OPEN_BRACKETS   shift and go to state 98

  ! OPEN_PAREN      [ reduce using rule 116 (add_id -> .) ]

    add_id                         shift and go to state 154
    dim                            shift and go to state 155

state 122

    (48) read -> READ OPEN_PAREN ids . g_quad_read read_comp CLOSE_PAREN
    (51) g_quad_read -> .

    COMMA           reduce using rule 51 (g_quad_read -> .)
    CLOSE_PAREN     reduce using rule 51 (g_quad_read -> .)

    g_quad_read                    shift and go to state 156

state 123

    (52) write -> WRITE OPEN_PAREN CT_STRING . g_quad_write_str write_comp CLOSE_PAREN
    (57) g_quad_write_str -> .

    COMMA           reduce using rule 57 (g_quad_write_str -> .)
    CLOSE_PAREN     reduce using rule 57 (g_quad_write_str -> .)

    g_quad_write_str               shift and go to state 157

state 124

    (53) write -> WRITE OPEN_PAREN expressions . g_quad_write write_comp CLOSE_PAREN
    (58) g_quad_write -> .

    COMMA           reduce using rule 58 (g_quad_write -> .)
    CLOSE_PAREN     reduce using rule 58 (g_quad_write -> .)

    g_quad_write                   shift and go to state 158

state 125

    (60) condition -> IF OPEN_PAREN expressions . CLOSE_PAREN g_if_quad THEN block end_if
    (61) condition -> IF OPEN_PAREN expressions . CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if

    CLOSE_PAREN     shift and go to state 159


state 126

    (62) condition -> WHILE while_jump OPEN_PAREN . expressions CLOSE_PAREN g_while_quad DO block end_while
    (78) expressions -> . expressions_comp
    (79) expressions_comp -> . expression_comp_2
    (80) expressions_comp -> . expression_comp_2 OR expressions_comp
    (81) expression_comp_2 -> . expression_comp_3
    (82) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (83) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (84) expression_comp_3 -> . exp
    (92) exp -> . term g_quad_exp_as
    (93) exp -> . term g_quad_exp_as exp_comp
    (97) term -> . factor g_quad_exp_md
    (98) term -> . factor g_quad_exp_md term_comp
    (103) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (104) factor -> . variable
    (105) factor -> . func_call
    (106) factor -> . CT_INT add_ct_int
    (107) factor -> . CT_FLOAT add_ct_float
    (108) factor -> . CT_CHAR add_ct_char
    (114) variable -> . ID add_id
    (115) variable -> . ID dim
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 115
    CT_INT          shift and go to state 118
    CT_FLOAT        shift and go to state 119
    CT_CHAR         shift and go to state 120
    ID              shift and go to state 121

    expressions                    shift and go to state 160
    expressions_comp               shift and go to state 109
    expression_comp_2              shift and go to state 110
    expression_comp_3              shift and go to state 111
    exp                            shift and go to state 112
    term                           shift and go to state 113
    factor                         shift and go to state 114
    variable                       shift and go to state 116
    func_call                      shift and go to state 117

state 127

    (63) condition -> FOR ids validate_for . ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for

    ASSIGN          shift and go to state 161


state 128

    (73) return -> RETURN OPEN_PAREN exp . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 162


state 129

    (74) func_call -> ID OPEN_PAREN func_call_comp . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 163


state 130

    (75) func_call_comp -> expressions . func_call_comp
    (75) func_call_comp -> . expressions func_call_comp
    (76) func_call_comp -> . COMMA expressions func_call_comp
    (77) func_call_comp -> . empty
    (78) expressions -> . expressions_comp
    (118) empty -> .
    (79) expressions_comp -> . expression_comp_2
    (80) expressions_comp -> . expression_comp_2 OR expressions_comp
    (81) expression_comp_2 -> . expression_comp_3
    (82) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (83) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (84) expression_comp_3 -> . exp
    (92) exp -> . term g_quad_exp_as
    (93) exp -> . term g_quad_exp_as exp_comp
    (97) term -> . factor g_quad_exp_md
    (98) term -> . factor g_quad_exp_md term_comp
    (103) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (104) factor -> . variable
    (105) factor -> . func_call
    (106) factor -> . CT_INT add_ct_int
    (107) factor -> . CT_FLOAT add_ct_float
    (108) factor -> . CT_CHAR add_ct_char
    (114) variable -> . ID add_id
    (115) variable -> . ID dim
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    COMMA           shift and go to state 131
    CLOSE_PAREN     reduce using rule 118 (empty -> .)
    OPEN_PAREN      shift and go to state 115
    CT_INT          shift and go to state 118
    CT_FLOAT        shift and go to state 119
    CT_CHAR         shift and go to state 120
    ID              shift and go to state 121

    expressions                    shift and go to state 130
    func_call_comp                 shift and go to state 164
    empty                          shift and go to state 132
    expressions_comp               shift and go to state 109
    expression_comp_2              shift and go to state 110
    expression_comp_3              shift and go to state 111
    exp                            shift and go to state 112
    term                           shift and go to state 113
    factor                         shift and go to state 114
    variable                       shift and go to state 116
    func_call                      shift and go to state 117

state 131

    (76) func_call_comp -> COMMA . expressions func_call_comp
    (78) expressions -> . expressions_comp
    (79) expressions_comp -> . expression_comp_2
    (80) expressions_comp -> . expression_comp_2 OR expressions_comp
    (81) expression_comp_2 -> . expression_comp_3
    (82) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (83) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (84) expression_comp_3 -> . exp
    (92) exp -> . term g_quad_exp_as
    (93) exp -> . term g_quad_exp_as exp_comp
    (97) term -> . factor g_quad_exp_md
    (98) term -> . factor g_quad_exp_md term_comp
    (103) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (104) factor -> . variable
    (105) factor -> . func_call
    (106) factor -> . CT_INT add_ct_int
    (107) factor -> . CT_FLOAT add_ct_float
    (108) factor -> . CT_CHAR add_ct_char
    (114) variable -> . ID add_id
    (115) variable -> . ID dim
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 115
    CT_INT          shift and go to state 118
    CT_FLOAT        shift and go to state 119
    CT_CHAR         shift and go to state 120
    ID              shift and go to state 121

    expressions                    shift and go to state 165
    expressions_comp               shift and go to state 109
    expression_comp_2              shift and go to state 110
    expression_comp_3              shift and go to state 111
    exp                            shift and go to state 112
    term                           shift and go to state 113
    factor                         shift and go to state 114
    variable                       shift and go to state 116
    func_call                      shift and go to state 117

state 132

    (77) func_call_comp -> empty .

    CLOSE_PAREN     reduce using rule 77 (func_call_comp -> empty .)


state 133

    (37) ids -> ID OPEN_BRACKETS exp . CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (38) ids -> ID OPEN_BRACKETS exp . CLOSE_BRACKETS

    CLOSE_BRACKETS  shift and go to state 166


state 134

    (6) funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block .

    MAIN            reduce using rule 6 (funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block .)


state 135

    (12) funcs_params_comp -> COMMA var_type . variable_params funcs_params_comp
    (14) variable_params -> . ID
    (15) variable_params -> . ID dim

    ID              shift and go to state 71

    variable_params                shift and go to state 167

state 136

    (117) dim -> OPEN_BRACKETS exp . CLOSE_BRACKETS

    CLOSE_BRACKETS  shift and go to state 168


state 137

    (9) funcs_comp -> ID add_module OPEN_PAREN . funcs_params CLOSE_PAREN vars block
    (10) funcs_params -> . var_type variable_params funcs_params_comp
    (11) funcs_params -> . empty
    (19) var_type -> . INT
    (20) var_type -> . FLOAT
    (21) var_type -> . CHAR
    (118) empty -> .

    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    CHAR            shift and go to state 16
    CLOSE_PAREN     reduce using rule 118 (empty -> .)

    funcs_params                   shift and go to state 169
    var_type                       shift and go to state 48
    empty                          shift and go to state 49

state 138

    (30) var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .

    VOID            reduce using rule 30 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    INT             reduce using rule 30 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    FLOAT           reduce using rule 30 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    CHAR            reduce using rule 30 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    MAIN            reduce using rule 30 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    OPEN_BRACES     reduce using rule 30 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)


state 139

    (80) expressions_comp -> expression_comp_2 OR . expressions_comp
    (79) expressions_comp -> . expression_comp_2
    (80) expressions_comp -> . expression_comp_2 OR expressions_comp
    (81) expression_comp_2 -> . expression_comp_3
    (82) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (83) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (84) expression_comp_3 -> . exp
    (92) exp -> . term g_quad_exp_as
    (93) exp -> . term g_quad_exp_as exp_comp
    (97) term -> . factor g_quad_exp_md
    (98) term -> . factor g_quad_exp_md term_comp
    (103) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (104) factor -> . variable
    (105) factor -> . func_call
    (106) factor -> . CT_INT add_ct_int
    (107) factor -> . CT_FLOAT add_ct_float
    (108) factor -> . CT_CHAR add_ct_char
    (114) variable -> . ID add_id
    (115) variable -> . ID dim
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 115
    CT_INT          shift and go to state 118
    CT_FLOAT        shift and go to state 119
    CT_CHAR         shift and go to state 120
    ID              shift and go to state 121

    expression_comp_2              shift and go to state 110
    expressions_comp               shift and go to state 170
    expression_comp_3              shift and go to state 111
    exp                            shift and go to state 112
    term                           shift and go to state 113
    factor                         shift and go to state 114
    variable                       shift and go to state 116
    func_call                      shift and go to state 117

state 140

    (82) expression_comp_2 -> expression_comp_3 AND . expression_comp_2
    (81) expression_comp_2 -> . expression_comp_3
    (82) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (83) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (84) expression_comp_3 -> . exp
    (92) exp -> . term g_quad_exp_as
    (93) exp -> . term g_quad_exp_as exp_comp
    (97) term -> . factor g_quad_exp_md
    (98) term -> . factor g_quad_exp_md term_comp
    (103) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (104) factor -> . variable
    (105) factor -> . func_call
    (106) factor -> . CT_INT add_ct_int
    (107) factor -> . CT_FLOAT add_ct_float
    (108) factor -> . CT_CHAR add_ct_char
    (114) variable -> . ID add_id
    (115) variable -> . ID dim
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 115
    CT_INT          shift and go to state 118
    CT_FLOAT        shift and go to state 119
    CT_CHAR         shift and go to state 120
    ID              shift and go to state 121

    expression_comp_3              shift and go to state 111
    expression_comp_2              shift and go to state 171
    exp                            shift and go to state 112
    term                           shift and go to state 113
    factor                         shift and go to state 114
    variable                       shift and go to state 116
    func_call                      shift and go to state 117

state 141

    (83) expression_comp_3 -> exp expressions_op . exp g_quad_logic
    (92) exp -> . term g_quad_exp_as
    (93) exp -> . term g_quad_exp_as exp_comp
    (97) term -> . factor g_quad_exp_md
    (98) term -> . factor g_quad_exp_md term_comp
    (103) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (104) factor -> . variable
    (105) factor -> . func_call
    (106) factor -> . CT_INT add_ct_int
    (107) factor -> . CT_FLOAT add_ct_float
    (108) factor -> . CT_CHAR add_ct_char
    (114) variable -> . ID add_id
    (115) variable -> . ID dim
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 115
    CT_INT          shift and go to state 118
    CT_FLOAT        shift and go to state 119
    CT_CHAR         shift and go to state 120
    ID              shift and go to state 121

    exp                            shift and go to state 172
    term                           shift and go to state 113
    factor                         shift and go to state 114
    variable                       shift and go to state 116
    func_call                      shift and go to state 117

state 142

    (86) expressions_op -> LESS_THAN . add_op
    (102) add_op -> .

    OPEN_PAREN      reduce using rule 102 (add_op -> .)
    CT_INT          reduce using rule 102 (add_op -> .)
    CT_FLOAT        reduce using rule 102 (add_op -> .)
    CT_CHAR         reduce using rule 102 (add_op -> .)
    ID              reduce using rule 102 (add_op -> .)

    add_op                         shift and go to state 173

state 143

    (87) expressions_op -> LESS_THAN_EQUAL . add_op
    (102) add_op -> .

    OPEN_PAREN      reduce using rule 102 (add_op -> .)
    CT_INT          reduce using rule 102 (add_op -> .)
    CT_FLOAT        reduce using rule 102 (add_op -> .)
    CT_CHAR         reduce using rule 102 (add_op -> .)
    ID              reduce using rule 102 (add_op -> .)

    add_op                         shift and go to state 174

state 144

    (88) expressions_op -> MORE_THAN . add_op
    (102) add_op -> .

    OPEN_PAREN      reduce using rule 102 (add_op -> .)
    CT_INT          reduce using rule 102 (add_op -> .)
    CT_FLOAT        reduce using rule 102 (add_op -> .)
    CT_CHAR         reduce using rule 102 (add_op -> .)
    ID              reduce using rule 102 (add_op -> .)

    add_op                         shift and go to state 175

state 145

    (89) expressions_op -> MORE_THAN_EQUAL . add_op
    (102) add_op -> .

    OPEN_PAREN      reduce using rule 102 (add_op -> .)
    CT_INT          reduce using rule 102 (add_op -> .)
    CT_FLOAT        reduce using rule 102 (add_op -> .)
    CT_CHAR         reduce using rule 102 (add_op -> .)
    ID              reduce using rule 102 (add_op -> .)

    add_op                         shift and go to state 176

state 146

    (90) expressions_op -> EQUALS . add_op
    (102) add_op -> .

    OPEN_PAREN      reduce using rule 102 (add_op -> .)
    CT_INT          reduce using rule 102 (add_op -> .)
    CT_FLOAT        reduce using rule 102 (add_op -> .)
    CT_CHAR         reduce using rule 102 (add_op -> .)
    ID              reduce using rule 102 (add_op -> .)

    add_op                         shift and go to state 177

state 147

    (91) expressions_op -> NOT_EQUALS . add_op
    (102) add_op -> .

    OPEN_PAREN      reduce using rule 102 (add_op -> .)
    CT_INT          reduce using rule 102 (add_op -> .)
    CT_FLOAT        reduce using rule 102 (add_op -> .)
    CT_CHAR         reduce using rule 102 (add_op -> .)
    ID              reduce using rule 102 (add_op -> .)

    add_op                         shift and go to state 178

state 148

    (92) exp -> term g_quad_exp_as .
    (93) exp -> term g_quad_exp_as . exp_comp
    (95) exp_comp -> . PLUS add_op exp
    (96) exp_comp -> . MINUS add_op exp

    LESS_THAN       reduce using rule 92 (exp -> term g_quad_exp_as .)
    LESS_THAN_EQUAL reduce using rule 92 (exp -> term g_quad_exp_as .)
    MORE_THAN       reduce using rule 92 (exp -> term g_quad_exp_as .)
    MORE_THAN_EQUAL reduce using rule 92 (exp -> term g_quad_exp_as .)
    EQUALS          reduce using rule 92 (exp -> term g_quad_exp_as .)
    NOT_EQUALS      reduce using rule 92 (exp -> term g_quad_exp_as .)
    AND             reduce using rule 92 (exp -> term g_quad_exp_as .)
    OR              reduce using rule 92 (exp -> term g_quad_exp_as .)
    SEMICOLON       reduce using rule 92 (exp -> term g_quad_exp_as .)
    COMMA           reduce using rule 92 (exp -> term g_quad_exp_as .)
    CLOSE_PAREN     reduce using rule 92 (exp -> term g_quad_exp_as .)
    OPEN_PAREN      reduce using rule 92 (exp -> term g_quad_exp_as .)
    CT_INT          reduce using rule 92 (exp -> term g_quad_exp_as .)
    CT_FLOAT        reduce using rule 92 (exp -> term g_quad_exp_as .)
    CT_CHAR         reduce using rule 92 (exp -> term g_quad_exp_as .)
    ID              reduce using rule 92 (exp -> term g_quad_exp_as .)
    CLOSE_BRACKETS  reduce using rule 92 (exp -> term g_quad_exp_as .)
    TO              reduce using rule 92 (exp -> term g_quad_exp_as .)
    DO              reduce using rule 92 (exp -> term g_quad_exp_as .)
    PLUS            shift and go to state 180
    MINUS           shift and go to state 181

    exp_comp                       shift and go to state 179

state 149

    (97) term -> factor g_quad_exp_md .
    (98) term -> factor g_quad_exp_md . term_comp
    (100) term_comp -> . MULTIPLIES add_op term
    (101) term_comp -> . DIVIDE add_op term

    PLUS            reduce using rule 97 (term -> factor g_quad_exp_md .)
    MINUS           reduce using rule 97 (term -> factor g_quad_exp_md .)
    LESS_THAN       reduce using rule 97 (term -> factor g_quad_exp_md .)
    LESS_THAN_EQUAL reduce using rule 97 (term -> factor g_quad_exp_md .)
    MORE_THAN       reduce using rule 97 (term -> factor g_quad_exp_md .)
    MORE_THAN_EQUAL reduce using rule 97 (term -> factor g_quad_exp_md .)
    EQUALS          reduce using rule 97 (term -> factor g_quad_exp_md .)
    NOT_EQUALS      reduce using rule 97 (term -> factor g_quad_exp_md .)
    AND             reduce using rule 97 (term -> factor g_quad_exp_md .)
    OR              reduce using rule 97 (term -> factor g_quad_exp_md .)
    SEMICOLON       reduce using rule 97 (term -> factor g_quad_exp_md .)
    COMMA           reduce using rule 97 (term -> factor g_quad_exp_md .)
    CLOSE_PAREN     reduce using rule 97 (term -> factor g_quad_exp_md .)
    OPEN_PAREN      reduce using rule 97 (term -> factor g_quad_exp_md .)
    CT_INT          reduce using rule 97 (term -> factor g_quad_exp_md .)
    CT_FLOAT        reduce using rule 97 (term -> factor g_quad_exp_md .)
    CT_CHAR         reduce using rule 97 (term -> factor g_quad_exp_md .)
    ID              reduce using rule 97 (term -> factor g_quad_exp_md .)
    CLOSE_BRACKETS  reduce using rule 97 (term -> factor g_quad_exp_md .)
    TO              reduce using rule 97 (term -> factor g_quad_exp_md .)
    DO              reduce using rule 97 (term -> factor g_quad_exp_md .)
    MULTIPLIES      shift and go to state 183
    DIVIDE          shift and go to state 184

    term_comp                      shift and go to state 182

state 150

    (103) factor -> OPEN_PAREN add_fake . expressions CLOSE_PAREN rem_fake
    (78) expressions -> . expressions_comp
    (79) expressions_comp -> . expression_comp_2
    (80) expressions_comp -> . expression_comp_2 OR expressions_comp
    (81) expression_comp_2 -> . expression_comp_3
    (82) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (83) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (84) expression_comp_3 -> . exp
    (92) exp -> . term g_quad_exp_as
    (93) exp -> . term g_quad_exp_as exp_comp
    (97) term -> . factor g_quad_exp_md
    (98) term -> . factor g_quad_exp_md term_comp
    (103) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (104) factor -> . variable
    (105) factor -> . func_call
    (106) factor -> . CT_INT add_ct_int
    (107) factor -> . CT_FLOAT add_ct_float
    (108) factor -> . CT_CHAR add_ct_char
    (114) variable -> . ID add_id
    (115) variable -> . ID dim
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 115
    CT_INT          shift and go to state 118
    CT_FLOAT        shift and go to state 119
    CT_CHAR         shift and go to state 120
    ID              shift and go to state 121

    expressions                    shift and go to state 185
    expressions_comp               shift and go to state 109
    expression_comp_2              shift and go to state 110
    expression_comp_3              shift and go to state 111
    exp                            shift and go to state 112
    term                           shift and go to state 113
    factor                         shift and go to state 114
    variable                       shift and go to state 116
    func_call                      shift and go to state 117

state 151

    (106) factor -> CT_INT add_ct_int .

    MULTIPLIES      reduce using rule 106 (factor -> CT_INT add_ct_int .)
    DIVIDE          reduce using rule 106 (factor -> CT_INT add_ct_int .)
    PLUS            reduce using rule 106 (factor -> CT_INT add_ct_int .)
    MINUS           reduce using rule 106 (factor -> CT_INT add_ct_int .)
    LESS_THAN       reduce using rule 106 (factor -> CT_INT add_ct_int .)
    LESS_THAN_EQUAL reduce using rule 106 (factor -> CT_INT add_ct_int .)
    MORE_THAN       reduce using rule 106 (factor -> CT_INT add_ct_int .)
    MORE_THAN_EQUAL reduce using rule 106 (factor -> CT_INT add_ct_int .)
    EQUALS          reduce using rule 106 (factor -> CT_INT add_ct_int .)
    NOT_EQUALS      reduce using rule 106 (factor -> CT_INT add_ct_int .)
    AND             reduce using rule 106 (factor -> CT_INT add_ct_int .)
    OR              reduce using rule 106 (factor -> CT_INT add_ct_int .)
    SEMICOLON       reduce using rule 106 (factor -> CT_INT add_ct_int .)
    COMMA           reduce using rule 106 (factor -> CT_INT add_ct_int .)
    CLOSE_PAREN     reduce using rule 106 (factor -> CT_INT add_ct_int .)
    OPEN_PAREN      reduce using rule 106 (factor -> CT_INT add_ct_int .)
    CT_INT          reduce using rule 106 (factor -> CT_INT add_ct_int .)
    CT_FLOAT        reduce using rule 106 (factor -> CT_INT add_ct_int .)
    CT_CHAR         reduce using rule 106 (factor -> CT_INT add_ct_int .)
    ID              reduce using rule 106 (factor -> CT_INT add_ct_int .)
    CLOSE_BRACKETS  reduce using rule 106 (factor -> CT_INT add_ct_int .)
    TO              reduce using rule 106 (factor -> CT_INT add_ct_int .)
    DO              reduce using rule 106 (factor -> CT_INT add_ct_int .)


state 152

    (107) factor -> CT_FLOAT add_ct_float .

    MULTIPLIES      reduce using rule 107 (factor -> CT_FLOAT add_ct_float .)
    DIVIDE          reduce using rule 107 (factor -> CT_FLOAT add_ct_float .)
    PLUS            reduce using rule 107 (factor -> CT_FLOAT add_ct_float .)
    MINUS           reduce using rule 107 (factor -> CT_FLOAT add_ct_float .)
    LESS_THAN       reduce using rule 107 (factor -> CT_FLOAT add_ct_float .)
    LESS_THAN_EQUAL reduce using rule 107 (factor -> CT_FLOAT add_ct_float .)
    MORE_THAN       reduce using rule 107 (factor -> CT_FLOAT add_ct_float .)
    MORE_THAN_EQUAL reduce using rule 107 (factor -> CT_FLOAT add_ct_float .)
    EQUALS          reduce using rule 107 (factor -> CT_FLOAT add_ct_float .)
    NOT_EQUALS      reduce using rule 107 (factor -> CT_FLOAT add_ct_float .)
    AND             reduce using rule 107 (factor -> CT_FLOAT add_ct_float .)
    OR              reduce using rule 107 (factor -> CT_FLOAT add_ct_float .)
    SEMICOLON       reduce using rule 107 (factor -> CT_FLOAT add_ct_float .)
    COMMA           reduce using rule 107 (factor -> CT_FLOAT add_ct_float .)
    CLOSE_PAREN     reduce using rule 107 (factor -> CT_FLOAT add_ct_float .)
    OPEN_PAREN      reduce using rule 107 (factor -> CT_FLOAT add_ct_float .)
    CT_INT          reduce using rule 107 (factor -> CT_FLOAT add_ct_float .)
    CT_FLOAT        reduce using rule 107 (factor -> CT_FLOAT add_ct_float .)
    CT_CHAR         reduce using rule 107 (factor -> CT_FLOAT add_ct_float .)
    ID              reduce using rule 107 (factor -> CT_FLOAT add_ct_float .)
    CLOSE_BRACKETS  reduce using rule 107 (factor -> CT_FLOAT add_ct_float .)
    TO              reduce using rule 107 (factor -> CT_FLOAT add_ct_float .)
    DO              reduce using rule 107 (factor -> CT_FLOAT add_ct_float .)


state 153

    (108) factor -> CT_CHAR add_ct_char .

    MULTIPLIES      reduce using rule 108 (factor -> CT_CHAR add_ct_char .)
    DIVIDE          reduce using rule 108 (factor -> CT_CHAR add_ct_char .)
    PLUS            reduce using rule 108 (factor -> CT_CHAR add_ct_char .)
    MINUS           reduce using rule 108 (factor -> CT_CHAR add_ct_char .)
    LESS_THAN       reduce using rule 108 (factor -> CT_CHAR add_ct_char .)
    LESS_THAN_EQUAL reduce using rule 108 (factor -> CT_CHAR add_ct_char .)
    MORE_THAN       reduce using rule 108 (factor -> CT_CHAR add_ct_char .)
    MORE_THAN_EQUAL reduce using rule 108 (factor -> CT_CHAR add_ct_char .)
    EQUALS          reduce using rule 108 (factor -> CT_CHAR add_ct_char .)
    NOT_EQUALS      reduce using rule 108 (factor -> CT_CHAR add_ct_char .)
    AND             reduce using rule 108 (factor -> CT_CHAR add_ct_char .)
    OR              reduce using rule 108 (factor -> CT_CHAR add_ct_char .)
    SEMICOLON       reduce using rule 108 (factor -> CT_CHAR add_ct_char .)
    COMMA           reduce using rule 108 (factor -> CT_CHAR add_ct_char .)
    CLOSE_PAREN     reduce using rule 108 (factor -> CT_CHAR add_ct_char .)
    OPEN_PAREN      reduce using rule 108 (factor -> CT_CHAR add_ct_char .)
    CT_INT          reduce using rule 108 (factor -> CT_CHAR add_ct_char .)
    CT_FLOAT        reduce using rule 108 (factor -> CT_CHAR add_ct_char .)
    CT_CHAR         reduce using rule 108 (factor -> CT_CHAR add_ct_char .)
    ID              reduce using rule 108 (factor -> CT_CHAR add_ct_char .)
    CLOSE_BRACKETS  reduce using rule 108 (factor -> CT_CHAR add_ct_char .)
    TO              reduce using rule 108 (factor -> CT_CHAR add_ct_char .)
    DO              reduce using rule 108 (factor -> CT_CHAR add_ct_char .)


state 154

    (114) variable -> ID add_id .

    MULTIPLIES      reduce using rule 114 (variable -> ID add_id .)
    DIVIDE          reduce using rule 114 (variable -> ID add_id .)
    PLUS            reduce using rule 114 (variable -> ID add_id .)
    MINUS           reduce using rule 114 (variable -> ID add_id .)
    LESS_THAN       reduce using rule 114 (variable -> ID add_id .)
    LESS_THAN_EQUAL reduce using rule 114 (variable -> ID add_id .)
    MORE_THAN       reduce using rule 114 (variable -> ID add_id .)
    MORE_THAN_EQUAL reduce using rule 114 (variable -> ID add_id .)
    EQUALS          reduce using rule 114 (variable -> ID add_id .)
    NOT_EQUALS      reduce using rule 114 (variable -> ID add_id .)
    AND             reduce using rule 114 (variable -> ID add_id .)
    OR              reduce using rule 114 (variable -> ID add_id .)
    SEMICOLON       reduce using rule 114 (variable -> ID add_id .)
    COMMA           reduce using rule 114 (variable -> ID add_id .)
    CLOSE_PAREN     reduce using rule 114 (variable -> ID add_id .)
    OPEN_PAREN      reduce using rule 114 (variable -> ID add_id .)
    CT_INT          reduce using rule 114 (variable -> ID add_id .)
    CT_FLOAT        reduce using rule 114 (variable -> ID add_id .)
    CT_CHAR         reduce using rule 114 (variable -> ID add_id .)
    ID              reduce using rule 114 (variable -> ID add_id .)
    CLOSE_BRACKETS  reduce using rule 114 (variable -> ID add_id .)
    TO              reduce using rule 114 (variable -> ID add_id .)
    DO              reduce using rule 114 (variable -> ID add_id .)


state 155

    (115) variable -> ID dim .

    MULTIPLIES      reduce using rule 115 (variable -> ID dim .)
    DIVIDE          reduce using rule 115 (variable -> ID dim .)
    PLUS            reduce using rule 115 (variable -> ID dim .)
    MINUS           reduce using rule 115 (variable -> ID dim .)
    LESS_THAN       reduce using rule 115 (variable -> ID dim .)
    LESS_THAN_EQUAL reduce using rule 115 (variable -> ID dim .)
    MORE_THAN       reduce using rule 115 (variable -> ID dim .)
    MORE_THAN_EQUAL reduce using rule 115 (variable -> ID dim .)
    EQUALS          reduce using rule 115 (variable -> ID dim .)
    NOT_EQUALS      reduce using rule 115 (variable -> ID dim .)
    AND             reduce using rule 115 (variable -> ID dim .)
    OR              reduce using rule 115 (variable -> ID dim .)
    SEMICOLON       reduce using rule 115 (variable -> ID dim .)
    COMMA           reduce using rule 115 (variable -> ID dim .)
    CLOSE_PAREN     reduce using rule 115 (variable -> ID dim .)
    OPEN_PAREN      reduce using rule 115 (variable -> ID dim .)
    CT_INT          reduce using rule 115 (variable -> ID dim .)
    CT_FLOAT        reduce using rule 115 (variable -> ID dim .)
    CT_CHAR         reduce using rule 115 (variable -> ID dim .)
    ID              reduce using rule 115 (variable -> ID dim .)
    CLOSE_BRACKETS  reduce using rule 115 (variable -> ID dim .)
    TO              reduce using rule 115 (variable -> ID dim .)
    DO              reduce using rule 115 (variable -> ID dim .)


state 156

    (48) read -> READ OPEN_PAREN ids g_quad_read . read_comp CLOSE_PAREN
    (49) read_comp -> . COMMA ids g_quad_read read_comp
    (50) read_comp -> . empty
    (118) empty -> .

    COMMA           shift and go to state 187
    CLOSE_PAREN     reduce using rule 118 (empty -> .)

    read_comp                      shift and go to state 186
    empty                          shift and go to state 188

state 157

    (52) write -> WRITE OPEN_PAREN CT_STRING g_quad_write_str . write_comp CLOSE_PAREN
    (54) write_comp -> . COMMA CT_STRING g_quad_write_str write_comp
    (55) write_comp -> . COMMA expressions g_quad_write write_comp
    (56) write_comp -> . empty
    (118) empty -> .

    COMMA           shift and go to state 190
    CLOSE_PAREN     reduce using rule 118 (empty -> .)

    write_comp                     shift and go to state 189
    empty                          shift and go to state 191

state 158

    (53) write -> WRITE OPEN_PAREN expressions g_quad_write . write_comp CLOSE_PAREN
    (54) write_comp -> . COMMA CT_STRING g_quad_write_str write_comp
    (55) write_comp -> . COMMA expressions g_quad_write write_comp
    (56) write_comp -> . empty
    (118) empty -> .

    COMMA           shift and go to state 190
    CLOSE_PAREN     reduce using rule 118 (empty -> .)

    write_comp                     shift and go to state 192
    empty                          shift and go to state 191

state 159

    (60) condition -> IF OPEN_PAREN expressions CLOSE_PAREN . g_if_quad THEN block end_if
    (61) condition -> IF OPEN_PAREN expressions CLOSE_PAREN . g_if_quad THEN block ELSE g_else_quad block end_if
    (64) g_if_quad -> .

    THEN            reduce using rule 64 (g_if_quad -> .)

    g_if_quad                      shift and go to state 193

state 160

    (62) condition -> WHILE while_jump OPEN_PAREN expressions . CLOSE_PAREN g_while_quad DO block end_while

    CLOSE_PAREN     shift and go to state 194


state 161

    (63) condition -> FOR ids validate_for ASSIGN . expressions for_counter_control TO expressions for_counter_end DO block end_for
    (78) expressions -> . expressions_comp
    (79) expressions_comp -> . expression_comp_2
    (80) expressions_comp -> . expression_comp_2 OR expressions_comp
    (81) expression_comp_2 -> . expression_comp_3
    (82) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (83) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (84) expression_comp_3 -> . exp
    (92) exp -> . term g_quad_exp_as
    (93) exp -> . term g_quad_exp_as exp_comp
    (97) term -> . factor g_quad_exp_md
    (98) term -> . factor g_quad_exp_md term_comp
    (103) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (104) factor -> . variable
    (105) factor -> . func_call
    (106) factor -> . CT_INT add_ct_int
    (107) factor -> . CT_FLOAT add_ct_float
    (108) factor -> . CT_CHAR add_ct_char
    (114) variable -> . ID add_id
    (115) variable -> . ID dim
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 115
    CT_INT          shift and go to state 118
    CT_FLOAT        shift and go to state 119
    CT_CHAR         shift and go to state 120
    ID              shift and go to state 121

    expressions                    shift and go to state 195
    expressions_comp               shift and go to state 109
    expression_comp_2              shift and go to state 110
    expression_comp_3              shift and go to state 111
    exp                            shift and go to state 112
    term                           shift and go to state 113
    factor                         shift and go to state 114
    variable                       shift and go to state 116
    func_call                      shift and go to state 117

state 162

    (73) return -> RETURN OPEN_PAREN exp CLOSE_PAREN .

    SEMICOLON       reduce using rule 73 (return -> RETURN OPEN_PAREN exp CLOSE_PAREN .)


state 163

    (74) func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .

    SEMICOLON       reduce using rule 74 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    MULTIPLIES      reduce using rule 74 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    DIVIDE          reduce using rule 74 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    PLUS            reduce using rule 74 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    MINUS           reduce using rule 74 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    LESS_THAN       reduce using rule 74 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    LESS_THAN_EQUAL reduce using rule 74 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    MORE_THAN       reduce using rule 74 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    MORE_THAN_EQUAL reduce using rule 74 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    EQUALS          reduce using rule 74 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    NOT_EQUALS      reduce using rule 74 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    AND             reduce using rule 74 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    OR              reduce using rule 74 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    COMMA           reduce using rule 74 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    CLOSE_PAREN     reduce using rule 74 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    OPEN_PAREN      reduce using rule 74 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    CT_INT          reduce using rule 74 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    CT_FLOAT        reduce using rule 74 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    CT_CHAR         reduce using rule 74 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    ID              reduce using rule 74 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    CLOSE_BRACKETS  reduce using rule 74 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    TO              reduce using rule 74 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    DO              reduce using rule 74 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)


state 164

    (75) func_call_comp -> expressions func_call_comp .

    CLOSE_PAREN     reduce using rule 75 (func_call_comp -> expressions func_call_comp .)


state 165

    (76) func_call_comp -> COMMA expressions . func_call_comp
    (75) func_call_comp -> . expressions func_call_comp
    (76) func_call_comp -> . COMMA expressions func_call_comp
    (77) func_call_comp -> . empty
    (78) expressions -> . expressions_comp
    (118) empty -> .
    (79) expressions_comp -> . expression_comp_2
    (80) expressions_comp -> . expression_comp_2 OR expressions_comp
    (81) expression_comp_2 -> . expression_comp_3
    (82) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (83) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (84) expression_comp_3 -> . exp
    (92) exp -> . term g_quad_exp_as
    (93) exp -> . term g_quad_exp_as exp_comp
    (97) term -> . factor g_quad_exp_md
    (98) term -> . factor g_quad_exp_md term_comp
    (103) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (104) factor -> . variable
    (105) factor -> . func_call
    (106) factor -> . CT_INT add_ct_int
    (107) factor -> . CT_FLOAT add_ct_float
    (108) factor -> . CT_CHAR add_ct_char
    (114) variable -> . ID add_id
    (115) variable -> . ID dim
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    COMMA           shift and go to state 131
    CLOSE_PAREN     reduce using rule 118 (empty -> .)
    OPEN_PAREN      shift and go to state 115
    CT_INT          shift and go to state 118
    CT_FLOAT        shift and go to state 119
    CT_CHAR         shift and go to state 120
    ID              shift and go to state 121

    expressions                    shift and go to state 130
    func_call_comp                 shift and go to state 196
    empty                          shift and go to state 132
    expressions_comp               shift and go to state 109
    expression_comp_2              shift and go to state 110
    expression_comp_3              shift and go to state 111
    exp                            shift and go to state 112
    term                           shift and go to state 113
    factor                         shift and go to state 114
    variable                       shift and go to state 116
    func_call                      shift and go to state 117

state 166

    (37) ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS . OPEN_BRACKETS exp CLOSE_BRACKETS
    (38) ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS .

    OPEN_BRACKETS   shift and go to state 197
    ASSIGN          reduce using rule 38 (ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS .)
    COMMA           reduce using rule 38 (ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CLOSE_PAREN     reduce using rule 38 (ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS .)


state 167

    (12) funcs_params_comp -> COMMA var_type variable_params . funcs_params_comp
    (12) funcs_params_comp -> . COMMA var_type variable_params funcs_params_comp
    (13) funcs_params_comp -> . empty
    (118) empty -> .

    COMMA           shift and go to state 95
    CLOSE_PAREN     reduce using rule 118 (empty -> .)

    funcs_params_comp              shift and go to state 198
    empty                          shift and go to state 96

state 168

    (117) dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .

    COMMA           reduce using rule 117 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CLOSE_PAREN     reduce using rule 117 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    MULTIPLIES      reduce using rule 117 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    DIVIDE          reduce using rule 117 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    PLUS            reduce using rule 117 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    MINUS           reduce using rule 117 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    LESS_THAN       reduce using rule 117 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    LESS_THAN_EQUAL reduce using rule 117 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    MORE_THAN       reduce using rule 117 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    MORE_THAN_EQUAL reduce using rule 117 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    EQUALS          reduce using rule 117 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    NOT_EQUALS      reduce using rule 117 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    AND             reduce using rule 117 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    OR              reduce using rule 117 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    SEMICOLON       reduce using rule 117 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    OPEN_PAREN      reduce using rule 117 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CT_INT          reduce using rule 117 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CT_FLOAT        reduce using rule 117 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CT_CHAR         reduce using rule 117 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    ID              reduce using rule 117 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CLOSE_BRACKETS  reduce using rule 117 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    TO              reduce using rule 117 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    DO              reduce using rule 117 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)


state 169

    (9) funcs_comp -> ID add_module OPEN_PAREN funcs_params . CLOSE_PAREN vars block

    CLOSE_PAREN     shift and go to state 199


state 170

    (80) expressions_comp -> expression_comp_2 OR expressions_comp .

    SEMICOLON       reduce using rule 80 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    COMMA           reduce using rule 80 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    CLOSE_PAREN     reduce using rule 80 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    OPEN_PAREN      reduce using rule 80 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    CT_INT          reduce using rule 80 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    CT_FLOAT        reduce using rule 80 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    CT_CHAR         reduce using rule 80 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    ID              reduce using rule 80 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    TO              reduce using rule 80 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    DO              reduce using rule 80 (expressions_comp -> expression_comp_2 OR expressions_comp .)


state 171

    (82) expression_comp_2 -> expression_comp_3 AND expression_comp_2 .

    OR              reduce using rule 82 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    SEMICOLON       reduce using rule 82 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    COMMA           reduce using rule 82 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    CLOSE_PAREN     reduce using rule 82 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    OPEN_PAREN      reduce using rule 82 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    CT_INT          reduce using rule 82 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    CT_FLOAT        reduce using rule 82 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    CT_CHAR         reduce using rule 82 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    ID              reduce using rule 82 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    TO              reduce using rule 82 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    DO              reduce using rule 82 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)


state 172

    (83) expression_comp_3 -> exp expressions_op exp . g_quad_logic
    (85) g_quad_logic -> .

    AND             reduce using rule 85 (g_quad_logic -> .)
    OR              reduce using rule 85 (g_quad_logic -> .)
    SEMICOLON       reduce using rule 85 (g_quad_logic -> .)
    COMMA           reduce using rule 85 (g_quad_logic -> .)
    CLOSE_PAREN     reduce using rule 85 (g_quad_logic -> .)
    OPEN_PAREN      reduce using rule 85 (g_quad_logic -> .)
    CT_INT          reduce using rule 85 (g_quad_logic -> .)
    CT_FLOAT        reduce using rule 85 (g_quad_logic -> .)
    CT_CHAR         reduce using rule 85 (g_quad_logic -> .)
    ID              reduce using rule 85 (g_quad_logic -> .)
    TO              reduce using rule 85 (g_quad_logic -> .)
    DO              reduce using rule 85 (g_quad_logic -> .)

    g_quad_logic                   shift and go to state 200

state 173

    (86) expressions_op -> LESS_THAN add_op .

    OPEN_PAREN      reduce using rule 86 (expressions_op -> LESS_THAN add_op .)
    CT_INT          reduce using rule 86 (expressions_op -> LESS_THAN add_op .)
    CT_FLOAT        reduce using rule 86 (expressions_op -> LESS_THAN add_op .)
    CT_CHAR         reduce using rule 86 (expressions_op -> LESS_THAN add_op .)
    ID              reduce using rule 86 (expressions_op -> LESS_THAN add_op .)


state 174

    (87) expressions_op -> LESS_THAN_EQUAL add_op .

    OPEN_PAREN      reduce using rule 87 (expressions_op -> LESS_THAN_EQUAL add_op .)
    CT_INT          reduce using rule 87 (expressions_op -> LESS_THAN_EQUAL add_op .)
    CT_FLOAT        reduce using rule 87 (expressions_op -> LESS_THAN_EQUAL add_op .)
    CT_CHAR         reduce using rule 87 (expressions_op -> LESS_THAN_EQUAL add_op .)
    ID              reduce using rule 87 (expressions_op -> LESS_THAN_EQUAL add_op .)


state 175

    (88) expressions_op -> MORE_THAN add_op .

    OPEN_PAREN      reduce using rule 88 (expressions_op -> MORE_THAN add_op .)
    CT_INT          reduce using rule 88 (expressions_op -> MORE_THAN add_op .)
    CT_FLOAT        reduce using rule 88 (expressions_op -> MORE_THAN add_op .)
    CT_CHAR         reduce using rule 88 (expressions_op -> MORE_THAN add_op .)
    ID              reduce using rule 88 (expressions_op -> MORE_THAN add_op .)


state 176

    (89) expressions_op -> MORE_THAN_EQUAL add_op .

    OPEN_PAREN      reduce using rule 89 (expressions_op -> MORE_THAN_EQUAL add_op .)
    CT_INT          reduce using rule 89 (expressions_op -> MORE_THAN_EQUAL add_op .)
    CT_FLOAT        reduce using rule 89 (expressions_op -> MORE_THAN_EQUAL add_op .)
    CT_CHAR         reduce using rule 89 (expressions_op -> MORE_THAN_EQUAL add_op .)
    ID              reduce using rule 89 (expressions_op -> MORE_THAN_EQUAL add_op .)


state 177

    (90) expressions_op -> EQUALS add_op .

    OPEN_PAREN      reduce using rule 90 (expressions_op -> EQUALS add_op .)
    CT_INT          reduce using rule 90 (expressions_op -> EQUALS add_op .)
    CT_FLOAT        reduce using rule 90 (expressions_op -> EQUALS add_op .)
    CT_CHAR         reduce using rule 90 (expressions_op -> EQUALS add_op .)
    ID              reduce using rule 90 (expressions_op -> EQUALS add_op .)


state 178

    (91) expressions_op -> NOT_EQUALS add_op .

    OPEN_PAREN      reduce using rule 91 (expressions_op -> NOT_EQUALS add_op .)
    CT_INT          reduce using rule 91 (expressions_op -> NOT_EQUALS add_op .)
    CT_FLOAT        reduce using rule 91 (expressions_op -> NOT_EQUALS add_op .)
    CT_CHAR         reduce using rule 91 (expressions_op -> NOT_EQUALS add_op .)
    ID              reduce using rule 91 (expressions_op -> NOT_EQUALS add_op .)


state 179

    (93) exp -> term g_quad_exp_as exp_comp .

    LESS_THAN       reduce using rule 93 (exp -> term g_quad_exp_as exp_comp .)
    LESS_THAN_EQUAL reduce using rule 93 (exp -> term g_quad_exp_as exp_comp .)
    MORE_THAN       reduce using rule 93 (exp -> term g_quad_exp_as exp_comp .)
    MORE_THAN_EQUAL reduce using rule 93 (exp -> term g_quad_exp_as exp_comp .)
    EQUALS          reduce using rule 93 (exp -> term g_quad_exp_as exp_comp .)
    NOT_EQUALS      reduce using rule 93 (exp -> term g_quad_exp_as exp_comp .)
    AND             reduce using rule 93 (exp -> term g_quad_exp_as exp_comp .)
    OR              reduce using rule 93 (exp -> term g_quad_exp_as exp_comp .)
    SEMICOLON       reduce using rule 93 (exp -> term g_quad_exp_as exp_comp .)
    COMMA           reduce using rule 93 (exp -> term g_quad_exp_as exp_comp .)
    CLOSE_PAREN     reduce using rule 93 (exp -> term g_quad_exp_as exp_comp .)
    OPEN_PAREN      reduce using rule 93 (exp -> term g_quad_exp_as exp_comp .)
    CT_INT          reduce using rule 93 (exp -> term g_quad_exp_as exp_comp .)
    CT_FLOAT        reduce using rule 93 (exp -> term g_quad_exp_as exp_comp .)
    CT_CHAR         reduce using rule 93 (exp -> term g_quad_exp_as exp_comp .)
    ID              reduce using rule 93 (exp -> term g_quad_exp_as exp_comp .)
    CLOSE_BRACKETS  reduce using rule 93 (exp -> term g_quad_exp_as exp_comp .)
    TO              reduce using rule 93 (exp -> term g_quad_exp_as exp_comp .)
    DO              reduce using rule 93 (exp -> term g_quad_exp_as exp_comp .)


state 180

    (95) exp_comp -> PLUS . add_op exp
    (102) add_op -> .

    OPEN_PAREN      reduce using rule 102 (add_op -> .)
    CT_INT          reduce using rule 102 (add_op -> .)
    CT_FLOAT        reduce using rule 102 (add_op -> .)
    CT_CHAR         reduce using rule 102 (add_op -> .)
    ID              reduce using rule 102 (add_op -> .)

    add_op                         shift and go to state 201

state 181

    (96) exp_comp -> MINUS . add_op exp
    (102) add_op -> .

    OPEN_PAREN      reduce using rule 102 (add_op -> .)
    CT_INT          reduce using rule 102 (add_op -> .)
    CT_FLOAT        reduce using rule 102 (add_op -> .)
    CT_CHAR         reduce using rule 102 (add_op -> .)
    ID              reduce using rule 102 (add_op -> .)

    add_op                         shift and go to state 202

state 182

    (98) term -> factor g_quad_exp_md term_comp .

    PLUS            reduce using rule 98 (term -> factor g_quad_exp_md term_comp .)
    MINUS           reduce using rule 98 (term -> factor g_quad_exp_md term_comp .)
    LESS_THAN       reduce using rule 98 (term -> factor g_quad_exp_md term_comp .)
    LESS_THAN_EQUAL reduce using rule 98 (term -> factor g_quad_exp_md term_comp .)
    MORE_THAN       reduce using rule 98 (term -> factor g_quad_exp_md term_comp .)
    MORE_THAN_EQUAL reduce using rule 98 (term -> factor g_quad_exp_md term_comp .)
    EQUALS          reduce using rule 98 (term -> factor g_quad_exp_md term_comp .)
    NOT_EQUALS      reduce using rule 98 (term -> factor g_quad_exp_md term_comp .)
    AND             reduce using rule 98 (term -> factor g_quad_exp_md term_comp .)
    OR              reduce using rule 98 (term -> factor g_quad_exp_md term_comp .)
    SEMICOLON       reduce using rule 98 (term -> factor g_quad_exp_md term_comp .)
    COMMA           reduce using rule 98 (term -> factor g_quad_exp_md term_comp .)
    CLOSE_PAREN     reduce using rule 98 (term -> factor g_quad_exp_md term_comp .)
    OPEN_PAREN      reduce using rule 98 (term -> factor g_quad_exp_md term_comp .)
    CT_INT          reduce using rule 98 (term -> factor g_quad_exp_md term_comp .)
    CT_FLOAT        reduce using rule 98 (term -> factor g_quad_exp_md term_comp .)
    CT_CHAR         reduce using rule 98 (term -> factor g_quad_exp_md term_comp .)
    ID              reduce using rule 98 (term -> factor g_quad_exp_md term_comp .)
    CLOSE_BRACKETS  reduce using rule 98 (term -> factor g_quad_exp_md term_comp .)
    TO              reduce using rule 98 (term -> factor g_quad_exp_md term_comp .)
    DO              reduce using rule 98 (term -> factor g_quad_exp_md term_comp .)


state 183

    (100) term_comp -> MULTIPLIES . add_op term
    (102) add_op -> .

    OPEN_PAREN      reduce using rule 102 (add_op -> .)
    CT_INT          reduce using rule 102 (add_op -> .)
    CT_FLOAT        reduce using rule 102 (add_op -> .)
    CT_CHAR         reduce using rule 102 (add_op -> .)
    ID              reduce using rule 102 (add_op -> .)

    add_op                         shift and go to state 203

state 184

    (101) term_comp -> DIVIDE . add_op term
    (102) add_op -> .

    OPEN_PAREN      reduce using rule 102 (add_op -> .)
    CT_INT          reduce using rule 102 (add_op -> .)
    CT_FLOAT        reduce using rule 102 (add_op -> .)
    CT_CHAR         reduce using rule 102 (add_op -> .)
    ID              reduce using rule 102 (add_op -> .)

    add_op                         shift and go to state 204

state 185

    (103) factor -> OPEN_PAREN add_fake expressions . CLOSE_PAREN rem_fake

    CLOSE_PAREN     shift and go to state 205


state 186

    (48) read -> READ OPEN_PAREN ids g_quad_read read_comp . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 206


state 187

    (49) read_comp -> COMMA . ids g_quad_read read_comp
    (37) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (38) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (39) ids -> . ID

    ID              shift and go to state 89

    ids                            shift and go to state 207

state 188

    (50) read_comp -> empty .

    CLOSE_PAREN     reduce using rule 50 (read_comp -> empty .)


state 189

    (52) write -> WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 208


state 190

    (54) write_comp -> COMMA . CT_STRING g_quad_write_str write_comp
    (55) write_comp -> COMMA . expressions g_quad_write write_comp
    (78) expressions -> . expressions_comp
    (79) expressions_comp -> . expression_comp_2
    (80) expressions_comp -> . expression_comp_2 OR expressions_comp
    (81) expression_comp_2 -> . expression_comp_3
    (82) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (83) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (84) expression_comp_3 -> . exp
    (92) exp -> . term g_quad_exp_as
    (93) exp -> . term g_quad_exp_as exp_comp
    (97) term -> . factor g_quad_exp_md
    (98) term -> . factor g_quad_exp_md term_comp
    (103) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (104) factor -> . variable
    (105) factor -> . func_call
    (106) factor -> . CT_INT add_ct_int
    (107) factor -> . CT_FLOAT add_ct_float
    (108) factor -> . CT_CHAR add_ct_char
    (114) variable -> . ID add_id
    (115) variable -> . ID dim
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    CT_STRING       shift and go to state 209
    OPEN_PAREN      shift and go to state 115
    CT_INT          shift and go to state 118
    CT_FLOAT        shift and go to state 119
    CT_CHAR         shift and go to state 120
    ID              shift and go to state 121

    expressions                    shift and go to state 210
    expressions_comp               shift and go to state 109
    expression_comp_2              shift and go to state 110
    expression_comp_3              shift and go to state 111
    exp                            shift and go to state 112
    term                           shift and go to state 113
    factor                         shift and go to state 114
    variable                       shift and go to state 116
    func_call                      shift and go to state 117

state 191

    (56) write_comp -> empty .

    CLOSE_PAREN     reduce using rule 56 (write_comp -> empty .)


state 192

    (53) write -> WRITE OPEN_PAREN expressions g_quad_write write_comp . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 211


state 193

    (60) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad . THEN block end_if
    (61) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad . THEN block ELSE g_else_quad block end_if

    THEN            shift and go to state 212


state 194

    (62) condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN . g_while_quad DO block end_while
    (67) g_while_quad -> .

    DO              reduce using rule 67 (g_while_quad -> .)

    g_while_quad                   shift and go to state 213

state 195

    (63) condition -> FOR ids validate_for ASSIGN expressions . for_counter_control TO expressions for_counter_end DO block end_for
    (70) for_counter_control -> .

    TO              reduce using rule 70 (for_counter_control -> .)

    for_counter_control            shift and go to state 214

state 196

    (76) func_call_comp -> COMMA expressions func_call_comp .

    CLOSE_PAREN     reduce using rule 76 (func_call_comp -> COMMA expressions func_call_comp .)


state 197

    (37) ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS . exp CLOSE_BRACKETS
    (92) exp -> . term g_quad_exp_as
    (93) exp -> . term g_quad_exp_as exp_comp
    (97) term -> . factor g_quad_exp_md
    (98) term -> . factor g_quad_exp_md term_comp
    (103) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (104) factor -> . variable
    (105) factor -> . func_call
    (106) factor -> . CT_INT add_ct_int
    (107) factor -> . CT_FLOAT add_ct_float
    (108) factor -> . CT_CHAR add_ct_char
    (114) variable -> . ID add_id
    (115) variable -> . ID dim
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 115
    CT_INT          shift and go to state 118
    CT_FLOAT        shift and go to state 119
    CT_CHAR         shift and go to state 120
    ID              shift and go to state 121

    exp                            shift and go to state 215
    term                           shift and go to state 113
    factor                         shift and go to state 114
    variable                       shift and go to state 116
    func_call                      shift and go to state 117

state 198

    (12) funcs_params_comp -> COMMA var_type variable_params funcs_params_comp .

    CLOSE_PAREN     reduce using rule 12 (funcs_params_comp -> COMMA var_type variable_params funcs_params_comp .)


state 199

    (9) funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN . vars block
    (22) vars -> . VARS var_comp
    (23) vars -> . empty
    (118) empty -> .

    VARS            shift and go to state 7
    OPEN_BRACES     reduce using rule 118 (empty -> .)

    vars                           shift and go to state 216
    empty                          shift and go to state 8

state 200

    (83) expression_comp_3 -> exp expressions_op exp g_quad_logic .

    AND             reduce using rule 83 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    OR              reduce using rule 83 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    SEMICOLON       reduce using rule 83 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    COMMA           reduce using rule 83 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    CLOSE_PAREN     reduce using rule 83 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    OPEN_PAREN      reduce using rule 83 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    CT_INT          reduce using rule 83 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    CT_FLOAT        reduce using rule 83 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    CT_CHAR         reduce using rule 83 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    ID              reduce using rule 83 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    TO              reduce using rule 83 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    DO              reduce using rule 83 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)


state 201

    (95) exp_comp -> PLUS add_op . exp
    (92) exp -> . term g_quad_exp_as
    (93) exp -> . term g_quad_exp_as exp_comp
    (97) term -> . factor g_quad_exp_md
    (98) term -> . factor g_quad_exp_md term_comp
    (103) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (104) factor -> . variable
    (105) factor -> . func_call
    (106) factor -> . CT_INT add_ct_int
    (107) factor -> . CT_FLOAT add_ct_float
    (108) factor -> . CT_CHAR add_ct_char
    (114) variable -> . ID add_id
    (115) variable -> . ID dim
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 115
    CT_INT          shift and go to state 118
    CT_FLOAT        shift and go to state 119
    CT_CHAR         shift and go to state 120
    ID              shift and go to state 121

    exp                            shift and go to state 217
    term                           shift and go to state 113
    factor                         shift and go to state 114
    variable                       shift and go to state 116
    func_call                      shift and go to state 117

state 202

    (96) exp_comp -> MINUS add_op . exp
    (92) exp -> . term g_quad_exp_as
    (93) exp -> . term g_quad_exp_as exp_comp
    (97) term -> . factor g_quad_exp_md
    (98) term -> . factor g_quad_exp_md term_comp
    (103) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (104) factor -> . variable
    (105) factor -> . func_call
    (106) factor -> . CT_INT add_ct_int
    (107) factor -> . CT_FLOAT add_ct_float
    (108) factor -> . CT_CHAR add_ct_char
    (114) variable -> . ID add_id
    (115) variable -> . ID dim
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 115
    CT_INT          shift and go to state 118
    CT_FLOAT        shift and go to state 119
    CT_CHAR         shift and go to state 120
    ID              shift and go to state 121

    exp                            shift and go to state 218
    term                           shift and go to state 113
    factor                         shift and go to state 114
    variable                       shift and go to state 116
    func_call                      shift and go to state 117

state 203

    (100) term_comp -> MULTIPLIES add_op . term
    (97) term -> . factor g_quad_exp_md
    (98) term -> . factor g_quad_exp_md term_comp
    (103) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (104) factor -> . variable
    (105) factor -> . func_call
    (106) factor -> . CT_INT add_ct_int
    (107) factor -> . CT_FLOAT add_ct_float
    (108) factor -> . CT_CHAR add_ct_char
    (114) variable -> . ID add_id
    (115) variable -> . ID dim
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 115
    CT_INT          shift and go to state 118
    CT_FLOAT        shift and go to state 119
    CT_CHAR         shift and go to state 120
    ID              shift and go to state 121

    term                           shift and go to state 219
    factor                         shift and go to state 114
    variable                       shift and go to state 116
    func_call                      shift and go to state 117

state 204

    (101) term_comp -> DIVIDE add_op . term
    (97) term -> . factor g_quad_exp_md
    (98) term -> . factor g_quad_exp_md term_comp
    (103) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (104) factor -> . variable
    (105) factor -> . func_call
    (106) factor -> . CT_INT add_ct_int
    (107) factor -> . CT_FLOAT add_ct_float
    (108) factor -> . CT_CHAR add_ct_char
    (114) variable -> . ID add_id
    (115) variable -> . ID dim
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 115
    CT_INT          shift and go to state 118
    CT_FLOAT        shift and go to state 119
    CT_CHAR         shift and go to state 120
    ID              shift and go to state 121

    term                           shift and go to state 220
    factor                         shift and go to state 114
    variable                       shift and go to state 116
    func_call                      shift and go to state 117

state 205

    (103) factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN . rem_fake
    (110) rem_fake -> .

    MULTIPLIES      reduce using rule 110 (rem_fake -> .)
    DIVIDE          reduce using rule 110 (rem_fake -> .)
    PLUS            reduce using rule 110 (rem_fake -> .)
    MINUS           reduce using rule 110 (rem_fake -> .)
    LESS_THAN       reduce using rule 110 (rem_fake -> .)
    LESS_THAN_EQUAL reduce using rule 110 (rem_fake -> .)
    MORE_THAN       reduce using rule 110 (rem_fake -> .)
    MORE_THAN_EQUAL reduce using rule 110 (rem_fake -> .)
    EQUALS          reduce using rule 110 (rem_fake -> .)
    NOT_EQUALS      reduce using rule 110 (rem_fake -> .)
    AND             reduce using rule 110 (rem_fake -> .)
    OR              reduce using rule 110 (rem_fake -> .)
    SEMICOLON       reduce using rule 110 (rem_fake -> .)
    COMMA           reduce using rule 110 (rem_fake -> .)
    CLOSE_PAREN     reduce using rule 110 (rem_fake -> .)
    OPEN_PAREN      reduce using rule 110 (rem_fake -> .)
    CT_INT          reduce using rule 110 (rem_fake -> .)
    CT_FLOAT        reduce using rule 110 (rem_fake -> .)
    CT_CHAR         reduce using rule 110 (rem_fake -> .)
    ID              reduce using rule 110 (rem_fake -> .)
    CLOSE_BRACKETS  reduce using rule 110 (rem_fake -> .)
    TO              reduce using rule 110 (rem_fake -> .)
    DO              reduce using rule 110 (rem_fake -> .)

    rem_fake                       shift and go to state 221

state 206

    (48) read -> READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN .

    SEMICOLON       reduce using rule 48 (read -> READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN .)


state 207

    (49) read_comp -> COMMA ids . g_quad_read read_comp
    (51) g_quad_read -> .

    COMMA           reduce using rule 51 (g_quad_read -> .)
    CLOSE_PAREN     reduce using rule 51 (g_quad_read -> .)

    g_quad_read                    shift and go to state 222

state 208

    (52) write -> WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN .

    SEMICOLON       reduce using rule 52 (write -> WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN .)


state 209

    (54) write_comp -> COMMA CT_STRING . g_quad_write_str write_comp
    (57) g_quad_write_str -> .

    COMMA           reduce using rule 57 (g_quad_write_str -> .)
    CLOSE_PAREN     reduce using rule 57 (g_quad_write_str -> .)

    g_quad_write_str               shift and go to state 223

state 210

    (55) write_comp -> COMMA expressions . g_quad_write write_comp
    (58) g_quad_write -> .

    COMMA           reduce using rule 58 (g_quad_write -> .)
    CLOSE_PAREN     reduce using rule 58 (g_quad_write -> .)

    g_quad_write                   shift and go to state 224

state 211

    (53) write -> WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN .

    SEMICOLON       reduce using rule 53 (write -> WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN .)


state 212

    (60) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN . block end_if
    (61) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN . block ELSE g_else_quad block end_if
    (16) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 46

    block                          shift and go to state 225

state 213

    (62) condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad . DO block end_while

    DO              shift and go to state 226


state 214

    (63) condition -> FOR ids validate_for ASSIGN expressions for_counter_control . TO expressions for_counter_end DO block end_for

    TO              shift and go to state 227


state 215

    (37) ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp . CLOSE_BRACKETS

    CLOSE_BRACKETS  shift and go to state 228


state 216

    (9) funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars . block
    (16) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 46

    block                          shift and go to state 229

state 217

    (95) exp_comp -> PLUS add_op exp .

    LESS_THAN       reduce using rule 95 (exp_comp -> PLUS add_op exp .)
    LESS_THAN_EQUAL reduce using rule 95 (exp_comp -> PLUS add_op exp .)
    MORE_THAN       reduce using rule 95 (exp_comp -> PLUS add_op exp .)
    MORE_THAN_EQUAL reduce using rule 95 (exp_comp -> PLUS add_op exp .)
    EQUALS          reduce using rule 95 (exp_comp -> PLUS add_op exp .)
    NOT_EQUALS      reduce using rule 95 (exp_comp -> PLUS add_op exp .)
    AND             reduce using rule 95 (exp_comp -> PLUS add_op exp .)
    OR              reduce using rule 95 (exp_comp -> PLUS add_op exp .)
    SEMICOLON       reduce using rule 95 (exp_comp -> PLUS add_op exp .)
    COMMA           reduce using rule 95 (exp_comp -> PLUS add_op exp .)
    CLOSE_PAREN     reduce using rule 95 (exp_comp -> PLUS add_op exp .)
    OPEN_PAREN      reduce using rule 95 (exp_comp -> PLUS add_op exp .)
    CT_INT          reduce using rule 95 (exp_comp -> PLUS add_op exp .)
    CT_FLOAT        reduce using rule 95 (exp_comp -> PLUS add_op exp .)
    CT_CHAR         reduce using rule 95 (exp_comp -> PLUS add_op exp .)
    ID              reduce using rule 95 (exp_comp -> PLUS add_op exp .)
    CLOSE_BRACKETS  reduce using rule 95 (exp_comp -> PLUS add_op exp .)
    TO              reduce using rule 95 (exp_comp -> PLUS add_op exp .)
    DO              reduce using rule 95 (exp_comp -> PLUS add_op exp .)


state 218

    (96) exp_comp -> MINUS add_op exp .

    LESS_THAN       reduce using rule 96 (exp_comp -> MINUS add_op exp .)
    LESS_THAN_EQUAL reduce using rule 96 (exp_comp -> MINUS add_op exp .)
    MORE_THAN       reduce using rule 96 (exp_comp -> MINUS add_op exp .)
    MORE_THAN_EQUAL reduce using rule 96 (exp_comp -> MINUS add_op exp .)
    EQUALS          reduce using rule 96 (exp_comp -> MINUS add_op exp .)
    NOT_EQUALS      reduce using rule 96 (exp_comp -> MINUS add_op exp .)
    AND             reduce using rule 96 (exp_comp -> MINUS add_op exp .)
    OR              reduce using rule 96 (exp_comp -> MINUS add_op exp .)
    SEMICOLON       reduce using rule 96 (exp_comp -> MINUS add_op exp .)
    COMMA           reduce using rule 96 (exp_comp -> MINUS add_op exp .)
    CLOSE_PAREN     reduce using rule 96 (exp_comp -> MINUS add_op exp .)
    OPEN_PAREN      reduce using rule 96 (exp_comp -> MINUS add_op exp .)
    CT_INT          reduce using rule 96 (exp_comp -> MINUS add_op exp .)
    CT_FLOAT        reduce using rule 96 (exp_comp -> MINUS add_op exp .)
    CT_CHAR         reduce using rule 96 (exp_comp -> MINUS add_op exp .)
    ID              reduce using rule 96 (exp_comp -> MINUS add_op exp .)
    CLOSE_BRACKETS  reduce using rule 96 (exp_comp -> MINUS add_op exp .)
    TO              reduce using rule 96 (exp_comp -> MINUS add_op exp .)
    DO              reduce using rule 96 (exp_comp -> MINUS add_op exp .)


state 219

    (100) term_comp -> MULTIPLIES add_op term .

    PLUS            reduce using rule 100 (term_comp -> MULTIPLIES add_op term .)
    MINUS           reduce using rule 100 (term_comp -> MULTIPLIES add_op term .)
    LESS_THAN       reduce using rule 100 (term_comp -> MULTIPLIES add_op term .)
    LESS_THAN_EQUAL reduce using rule 100 (term_comp -> MULTIPLIES add_op term .)
    MORE_THAN       reduce using rule 100 (term_comp -> MULTIPLIES add_op term .)
    MORE_THAN_EQUAL reduce using rule 100 (term_comp -> MULTIPLIES add_op term .)
    EQUALS          reduce using rule 100 (term_comp -> MULTIPLIES add_op term .)
    NOT_EQUALS      reduce using rule 100 (term_comp -> MULTIPLIES add_op term .)
    AND             reduce using rule 100 (term_comp -> MULTIPLIES add_op term .)
    OR              reduce using rule 100 (term_comp -> MULTIPLIES add_op term .)
    SEMICOLON       reduce using rule 100 (term_comp -> MULTIPLIES add_op term .)
    COMMA           reduce using rule 100 (term_comp -> MULTIPLIES add_op term .)
    CLOSE_PAREN     reduce using rule 100 (term_comp -> MULTIPLIES add_op term .)
    OPEN_PAREN      reduce using rule 100 (term_comp -> MULTIPLIES add_op term .)
    CT_INT          reduce using rule 100 (term_comp -> MULTIPLIES add_op term .)
    CT_FLOAT        reduce using rule 100 (term_comp -> MULTIPLIES add_op term .)
    CT_CHAR         reduce using rule 100 (term_comp -> MULTIPLIES add_op term .)
    ID              reduce using rule 100 (term_comp -> MULTIPLIES add_op term .)
    CLOSE_BRACKETS  reduce using rule 100 (term_comp -> MULTIPLIES add_op term .)
    TO              reduce using rule 100 (term_comp -> MULTIPLIES add_op term .)
    DO              reduce using rule 100 (term_comp -> MULTIPLIES add_op term .)


state 220

    (101) term_comp -> DIVIDE add_op term .

    PLUS            reduce using rule 101 (term_comp -> DIVIDE add_op term .)
    MINUS           reduce using rule 101 (term_comp -> DIVIDE add_op term .)
    LESS_THAN       reduce using rule 101 (term_comp -> DIVIDE add_op term .)
    LESS_THAN_EQUAL reduce using rule 101 (term_comp -> DIVIDE add_op term .)
    MORE_THAN       reduce using rule 101 (term_comp -> DIVIDE add_op term .)
    MORE_THAN_EQUAL reduce using rule 101 (term_comp -> DIVIDE add_op term .)
    EQUALS          reduce using rule 101 (term_comp -> DIVIDE add_op term .)
    NOT_EQUALS      reduce using rule 101 (term_comp -> DIVIDE add_op term .)
    AND             reduce using rule 101 (term_comp -> DIVIDE add_op term .)
    OR              reduce using rule 101 (term_comp -> DIVIDE add_op term .)
    SEMICOLON       reduce using rule 101 (term_comp -> DIVIDE add_op term .)
    COMMA           reduce using rule 101 (term_comp -> DIVIDE add_op term .)
    CLOSE_PAREN     reduce using rule 101 (term_comp -> DIVIDE add_op term .)
    OPEN_PAREN      reduce using rule 101 (term_comp -> DIVIDE add_op term .)
    CT_INT          reduce using rule 101 (term_comp -> DIVIDE add_op term .)
    CT_FLOAT        reduce using rule 101 (term_comp -> DIVIDE add_op term .)
    CT_CHAR         reduce using rule 101 (term_comp -> DIVIDE add_op term .)
    ID              reduce using rule 101 (term_comp -> DIVIDE add_op term .)
    CLOSE_BRACKETS  reduce using rule 101 (term_comp -> DIVIDE add_op term .)
    TO              reduce using rule 101 (term_comp -> DIVIDE add_op term .)
    DO              reduce using rule 101 (term_comp -> DIVIDE add_op term .)


state 221

    (103) factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .

    MULTIPLIES      reduce using rule 103 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    DIVIDE          reduce using rule 103 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    PLUS            reduce using rule 103 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    MINUS           reduce using rule 103 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    LESS_THAN       reduce using rule 103 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    LESS_THAN_EQUAL reduce using rule 103 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    MORE_THAN       reduce using rule 103 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    MORE_THAN_EQUAL reduce using rule 103 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    EQUALS          reduce using rule 103 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    NOT_EQUALS      reduce using rule 103 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    AND             reduce using rule 103 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    OR              reduce using rule 103 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    SEMICOLON       reduce using rule 103 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    COMMA           reduce using rule 103 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    CLOSE_PAREN     reduce using rule 103 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    OPEN_PAREN      reduce using rule 103 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    CT_INT          reduce using rule 103 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    CT_FLOAT        reduce using rule 103 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    CT_CHAR         reduce using rule 103 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    ID              reduce using rule 103 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    CLOSE_BRACKETS  reduce using rule 103 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    TO              reduce using rule 103 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    DO              reduce using rule 103 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)


state 222

    (49) read_comp -> COMMA ids g_quad_read . read_comp
    (49) read_comp -> . COMMA ids g_quad_read read_comp
    (50) read_comp -> . empty
    (118) empty -> .

    COMMA           shift and go to state 187
    CLOSE_PAREN     reduce using rule 118 (empty -> .)

    read_comp                      shift and go to state 230
    empty                          shift and go to state 188

state 223

    (54) write_comp -> COMMA CT_STRING g_quad_write_str . write_comp
    (54) write_comp -> . COMMA CT_STRING g_quad_write_str write_comp
    (55) write_comp -> . COMMA expressions g_quad_write write_comp
    (56) write_comp -> . empty
    (118) empty -> .

    COMMA           shift and go to state 190
    CLOSE_PAREN     reduce using rule 118 (empty -> .)

    write_comp                     shift and go to state 231
    empty                          shift and go to state 191

state 224

    (55) write_comp -> COMMA expressions g_quad_write . write_comp
    (54) write_comp -> . COMMA CT_STRING g_quad_write_str write_comp
    (55) write_comp -> . COMMA expressions g_quad_write write_comp
    (56) write_comp -> . empty
    (118) empty -> .

    COMMA           shift and go to state 190
    CLOSE_PAREN     reduce using rule 118 (empty -> .)

    write_comp                     shift and go to state 232
    empty                          shift and go to state 191

state 225

    (60) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block . end_if
    (61) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block . ELSE g_else_quad block end_if
    (59) end_if -> .

    ELSE            shift and go to state 234
    READ            reduce using rule 59 (end_if -> .)
    WRITE           reduce using rule 59 (end_if -> .)
    IF              reduce using rule 59 (end_if -> .)
    WHILE           reduce using rule 59 (end_if -> .)
    FOR             reduce using rule 59 (end_if -> .)
    RETURN          reduce using rule 59 (end_if -> .)
    ID              reduce using rule 59 (end_if -> .)
    CLOSE_BRACES    reduce using rule 59 (end_if -> .)

    end_if                         shift and go to state 233

state 226

    (62) condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO . block end_while
    (16) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 46

    block                          shift and go to state 235

state 227

    (63) condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO . expressions for_counter_end DO block end_for
    (78) expressions -> . expressions_comp
    (79) expressions_comp -> . expression_comp_2
    (80) expressions_comp -> . expression_comp_2 OR expressions_comp
    (81) expression_comp_2 -> . expression_comp_3
    (82) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (83) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (84) expression_comp_3 -> . exp
    (92) exp -> . term g_quad_exp_as
    (93) exp -> . term g_quad_exp_as exp_comp
    (97) term -> . factor g_quad_exp_md
    (98) term -> . factor g_quad_exp_md term_comp
    (103) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (104) factor -> . variable
    (105) factor -> . func_call
    (106) factor -> . CT_INT add_ct_int
    (107) factor -> . CT_FLOAT add_ct_float
    (108) factor -> . CT_CHAR add_ct_char
    (114) variable -> . ID add_id
    (115) variable -> . ID dim
    (74) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 115
    CT_INT          shift and go to state 118
    CT_FLOAT        shift and go to state 119
    CT_CHAR         shift and go to state 120
    ID              shift and go to state 121

    expressions                    shift and go to state 236
    expressions_comp               shift and go to state 109
    expression_comp_2              shift and go to state 110
    expression_comp_3              shift and go to state 111
    exp                            shift and go to state 112
    term                           shift and go to state 113
    factor                         shift and go to state 114
    variable                       shift and go to state 116
    func_call                      shift and go to state 117

state 228

    (37) ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS .

    ASSIGN          reduce using rule 37 (ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS .)
    COMMA           reduce using rule 37 (ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CLOSE_PAREN     reduce using rule 37 (ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS .)


state 229

    (9) funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block .

    VOID            reduce using rule 9 (funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block .)
    INT             reduce using rule 9 (funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block .)
    FLOAT           reduce using rule 9 (funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block .)
    CHAR            reduce using rule 9 (funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block .)
    MAIN            reduce using rule 9 (funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block .)
    OPEN_BRACES     reduce using rule 9 (funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN vars block .)


state 230

    (49) read_comp -> COMMA ids g_quad_read read_comp .

    CLOSE_PAREN     reduce using rule 49 (read_comp -> COMMA ids g_quad_read read_comp .)


state 231

    (54) write_comp -> COMMA CT_STRING g_quad_write_str write_comp .

    CLOSE_PAREN     reduce using rule 54 (write_comp -> COMMA CT_STRING g_quad_write_str write_comp .)


state 232

    (55) write_comp -> COMMA expressions g_quad_write write_comp .

    CLOSE_PAREN     reduce using rule 55 (write_comp -> COMMA expressions g_quad_write write_comp .)


state 233

    (60) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .

    READ            reduce using rule 60 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    WRITE           reduce using rule 60 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    IF              reduce using rule 60 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    WHILE           reduce using rule 60 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    FOR             reduce using rule 60 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    RETURN          reduce using rule 60 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    ID              reduce using rule 60 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    CLOSE_BRACES    reduce using rule 60 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)


state 234

    (61) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE . g_else_quad block end_if
    (65) g_else_quad -> .

    OPEN_BRACES     reduce using rule 65 (g_else_quad -> .)

    g_else_quad                    shift and go to state 237

state 235

    (62) condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block . end_while
    (68) end_while -> .

    READ            reduce using rule 68 (end_while -> .)
    WRITE           reduce using rule 68 (end_while -> .)
    IF              reduce using rule 68 (end_while -> .)
    WHILE           reduce using rule 68 (end_while -> .)
    FOR             reduce using rule 68 (end_while -> .)
    RETURN          reduce using rule 68 (end_while -> .)
    ID              reduce using rule 68 (end_while -> .)
    CLOSE_BRACES    reduce using rule 68 (end_while -> .)

    end_while                      shift and go to state 238

state 236

    (63) condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions . for_counter_end DO block end_for
    (71) for_counter_end -> .

    DO              reduce using rule 71 (for_counter_end -> .)

    for_counter_end                shift and go to state 239

state 237

    (61) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad . block end_if
    (16) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 46

    block                          shift and go to state 240

state 238

    (62) condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .

    READ            reduce using rule 62 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .)
    WRITE           reduce using rule 62 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .)
    IF              reduce using rule 62 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .)
    WHILE           reduce using rule 62 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .)
    FOR             reduce using rule 62 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .)
    RETURN          reduce using rule 62 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .)
    ID              reduce using rule 62 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .)
    CLOSE_BRACES    reduce using rule 62 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .)


state 239

    (63) condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end . DO block end_for

    DO              shift and go to state 241


state 240

    (61) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block . end_if
    (59) end_if -> .

    READ            reduce using rule 59 (end_if -> .)
    WRITE           reduce using rule 59 (end_if -> .)
    IF              reduce using rule 59 (end_if -> .)
    WHILE           reduce using rule 59 (end_if -> .)
    FOR             reduce using rule 59 (end_if -> .)
    RETURN          reduce using rule 59 (end_if -> .)
    ID              reduce using rule 59 (end_if -> .)
    CLOSE_BRACES    reduce using rule 59 (end_if -> .)

    end_if                         shift and go to state 242

state 241

    (63) condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO . block end_for
    (16) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 46

    block                          shift and go to state 243

state 242

    (61) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .

    READ            reduce using rule 61 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .)
    WRITE           reduce using rule 61 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .)
    IF              reduce using rule 61 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .)
    WHILE           reduce using rule 61 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .)
    FOR             reduce using rule 61 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .)
    RETURN          reduce using rule 61 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .)
    ID              reduce using rule 61 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .)
    CLOSE_BRACES    reduce using rule 61 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .)


state 243

    (63) condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block . end_for
    (72) end_for -> .

    READ            reduce using rule 72 (end_for -> .)
    WRITE           reduce using rule 72 (end_for -> .)
    IF              reduce using rule 72 (end_for -> .)
    WHILE           reduce using rule 72 (end_for -> .)
    FOR             reduce using rule 72 (end_for -> .)
    RETURN          reduce using rule 72 (end_for -> .)
    ID              reduce using rule 72 (end_for -> .)
    CLOSE_BRACES    reduce using rule 72 (end_for -> .)

    end_for                        shift and go to state 244

state 244

    (63) condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .

    READ            reduce using rule 63 (condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .)
    WRITE           reduce using rule 63 (condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .)
    IF              reduce using rule 63 (condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .)
    WHILE           reduce using rule 63 (condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .)
    FOR             reduce using rule 63 (condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .)
    RETURN          reduce using rule 63 (condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .)
    ID              reduce using rule 63 (condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .)
    CLOSE_BRACES    reduce using rule 63 (condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for INT in state 34 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 34 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 34 resolved as shift
WARNING: shift/reduce conflict for INT in state 101 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 101 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 101 resolved as shift
WARNING: shift/reduce conflict for OPEN_PAREN in state 121 resolved as shift
