Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMICOLON vars funcs main
Rule 2     main -> MAIN OPEN_PAREN CLOSE_PAREN block
Rule 3     funcs -> func_type MODULE ID OPEN_PAREN funcs_params CLOSE_PAREN vars block
Rule 4     funcs -> empty
Rule 5     funcs_comp -> ID OPEN_PAREN funcs_params CLOSE_PAREN vars block
Rule 6     funcs_params -> var_type variable funcs_params_comp
Rule 7     funcs_params -> empty
Rule 8     funcs_params_comp -> COMMA var_type ID funcs_params_comp
Rule 9     funcs_params_comp -> empty
Rule 10    block -> OPEN_BRACES statements CLOSE_BRACES
Rule 11    func_type -> var_type
Rule 12    func_type -> VOID
Rule 13    var_type -> INT
Rule 14    var_type -> FLOAT
Rule 15    var_type -> CHAR
Rule 16    vars -> VARS create_var_table var_comp
Rule 17    vars -> empty
Rule 18    create_var_table -> <empty>
Rule 19    var_comp -> var_type ids_dec var_comp_2 var_comp_final
Rule 20    var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive
Rule 21    var_comp_2 -> COMMA ids_dec var_comp_3
Rule 22    var_comp_2 -> empty
Rule 23    var_comp_3 -> var_comp_2
Rule 24    var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final
Rule 25    var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive
Rule 26    var_comp_final -> SEMICOLON
Rule 27    var_comp_final -> var_module_trans
Rule 28    var_module_trans -> SEMICOLON var_type MODULE funcs_comp
Rule 29    ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
Rule 30    ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS
Rule 31    ids_dec -> ID
Rule 32    ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
Rule 33    ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS
Rule 34    ids -> ID
Rule 35    statements -> assignment SEMICOLON statements
Rule 36    statements -> read SEMICOLON statements
Rule 37    statements -> write SEMICOLON statements
Rule 38    statements -> condition statements
Rule 39    statements -> return SEMICOLON statements
Rule 40    statements -> func_call SEMICOLON statements
Rule 41    statements -> empty
Rule 42    assignment -> ids ASSIGN expressions
Rule 43    read -> READ OPEN_PAREN ids read_comp CLOSE_PAREN
Rule 44    read_comp -> COMMA ids read_comp
Rule 45    read_comp -> empty
Rule 46    write -> WRITE OPEN_PAREN CT_STRING write_comp CLOSE_PAREN
Rule 47    write -> WRITE OPEN_PAREN expressions write_comp CLOSE_PAREN
Rule 48    write_comp -> COMMA CT_STRING write_comp
Rule 49    write_comp -> COMMA expressions write_comp
Rule 50    write_comp -> empty
Rule 51    condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE block
Rule 52    condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block
Rule 53    condition -> WHILE OPEN_PAREN expressions CLOSE_PAREN DO block
Rule 54    condition -> FOR ids_dec ASSIGN expressions TO expressions DO block
Rule 55    return -> RETURN OPEN_PAREN exp CLOSE_PAREN
Rule 56    func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN
Rule 57    func_call_comp -> expressions func_call_comp
Rule 58    func_call_comp -> COMMA expressions func_call_comp
Rule 59    func_call_comp -> empty
Rule 60    expressions -> expressions_comp
Rule 61    expressions_comp -> expression_comp_2
Rule 62    expressions_comp -> expression_comp_2 OR expressions_comp
Rule 63    expression_comp_2 -> expression_comp_3
Rule 64    expression_comp_2 -> expression_comp_3 AND expression_comp_2
Rule 65    expression_comp_3 -> exp
Rule 66    expression_comp_3 -> exp expressions_op exp
Rule 67    expressions_op -> LESS_THAN
Rule 68    expressions_op -> LESS_THAN_EQUAL
Rule 69    expressions_op -> MORE_THAN
Rule 70    expressions_op -> MORE_THAN_EQUAL
Rule 71    expressions_op -> EQUALS
Rule 72    expressions_op -> NOT_EQUALS
Rule 73    exp -> term
Rule 74    exp -> term exp_comp
Rule 75    exp_comp -> PLUS exp
Rule 76    exp_comp -> MINUS exp
Rule 77    term -> factor
Rule 78    term -> factor term_comp
Rule 79    term_comp -> MULTIPLIES term
Rule 80    term_comp -> DIVIDE term
Rule 81    factor -> OPEN_PAREN expressions CLOSE_PAREN
Rule 82    factor -> variable
Rule 83    factor -> func_call
Rule 84    factor -> CT_INT
Rule 85    factor -> CT_FLOAT
Rule 86    factor -> CT_CHAR
Rule 87    variable -> ID
Rule 88    variable -> ID dim
Rule 89    dim -> OPEN_BRACKETS exp CLOSE_BRACKETS
Rule 90    empty -> <empty>

Terminals, with rules where they appear

AND                  : 64
ASSIGN               : 42 54
CHAR                 : 15
CLOSE_BRACES         : 10
CLOSE_BRACKETS       : 29 29 30 32 32 33 89
CLOSE_PAREN          : 2 3 5 43 46 47 51 52 53 55 56 81
COMMA                : 8 21 44 48 49 58
CT_CHAR              : 86
CT_FLOAT             : 85
CT_INT               : 29 29 30 84
CT_STRING            : 46 48
DIVIDE               : 80
DO                   : 53 54
ELSE                 : 51
EQUALS               : 71
FLOAT                : 14
FOR                  : 54
ID                   : 1 3 5 8 29 30 31 32 33 34 56 87 88
IF                   : 51 52
INT                  : 13
LESS_THAN            : 67
LESS_THAN_EQUAL      : 68
MAIN                 : 2
MINUS                : 76
MODULE               : 3 28
MORE_THAN            : 69
MORE_THAN_EQUAL      : 70
MULTIPLIES           : 79
NOT_EQUALS           : 72
OPEN_BRACES          : 10
OPEN_BRACKETS        : 29 29 30 32 32 33 89
OPEN_PAREN           : 2 3 5 43 46 47 51 52 53 55 56 81
OR                   : 62
PLUS                 : 75
PROGRAM              : 1
READ                 : 43
RETURN               : 55
SEMICOLON            : 1 20 25 26 28 35 36 37 39 40
THEN                 : 51 52
TO                   : 54
VARS                 : 16
VOID                 : 12
WHILE                : 53
WRITE                : 46 47
error                : 

Nonterminals, with rules where they appear

assignment           : 35
block                : 2 3 5 51 51 52 53 54
condition            : 38
create_var_table     : 16
dim                  : 88
empty                : 4 7 9 17 22 41 45 50 59
exp                  : 32 32 33 55 65 66 66 75 76 89
exp_comp             : 74
expression_comp_2    : 61 62 64
expression_comp_3    : 63 64
expressions          : 42 47 49 51 52 53 54 54 57 58 81
expressions_comp     : 60 62
expressions_op       : 66
factor               : 77 78
func_call            : 40 83
func_call_comp       : 56 57 58
func_type            : 3
funcs                : 1
funcs_comp           : 28
funcs_params         : 3 5
funcs_params_comp    : 6 8
ids                  : 42 43 44
ids_dec              : 19 20 21 24 25 54
main                 : 1
program              : 0
read                 : 36
read_comp            : 43 44
return               : 39
statements           : 10 35 36 37 38 39 40
term                 : 73 74 79 80
term_comp            : 78
var_comp             : 16
var_comp_2           : 19 20 23 24 25
var_comp_3           : 21
var_comp_final       : 19 24
var_comp_recursive   : 20 25
var_module_trans     : 27
var_type             : 6 8 11 19 20 24 25 28
variable             : 6 82
vars                 : 1 3 5
write                : 37
write_comp           : 46 47 48 49

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMICOLON vars funcs main

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMICOLON vars funcs main

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMICOLON vars funcs main

    SEMICOLON       shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMICOLON . vars funcs main
    (16) vars -> . VARS create_var_table var_comp
    (17) vars -> . empty
    (90) empty -> .

    VARS            shift and go to state 6
    VOID            reduce using rule 90 (empty -> .)
    INT             reduce using rule 90 (empty -> .)
    FLOAT           reduce using rule 90 (empty -> .)
    CHAR            reduce using rule 90 (empty -> .)
    MAIN            reduce using rule 90 (empty -> .)

    vars                           shift and go to state 5
    empty                          shift and go to state 7

state 5

    (1) program -> PROGRAM ID SEMICOLON vars . funcs main
    (3) funcs -> . func_type MODULE ID OPEN_PAREN funcs_params CLOSE_PAREN vars block
    (4) funcs -> . empty
    (11) func_type -> . var_type
    (12) func_type -> . VOID
    (90) empty -> .
    (13) var_type -> . INT
    (14) var_type -> . FLOAT
    (15) var_type -> . CHAR

    VOID            shift and go to state 12
    MAIN            reduce using rule 90 (empty -> .)
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 15

    funcs                          shift and go to state 8
    func_type                      shift and go to state 9
    empty                          shift and go to state 10
    var_type                       shift and go to state 11

state 6

    (16) vars -> VARS . create_var_table var_comp
    (18) create_var_table -> .

    INT             reduce using rule 18 (create_var_table -> .)
    FLOAT           reduce using rule 18 (create_var_table -> .)
    CHAR            reduce using rule 18 (create_var_table -> .)

    create_var_table               shift and go to state 16

state 7

    (17) vars -> empty .

    VOID            reduce using rule 17 (vars -> empty .)
    INT             reduce using rule 17 (vars -> empty .)
    FLOAT           reduce using rule 17 (vars -> empty .)
    CHAR            reduce using rule 17 (vars -> empty .)
    MAIN            reduce using rule 17 (vars -> empty .)
    OPEN_BRACES     reduce using rule 17 (vars -> empty .)


state 8

    (1) program -> PROGRAM ID SEMICOLON vars funcs . main
    (2) main -> . MAIN OPEN_PAREN CLOSE_PAREN block

    MAIN            shift and go to state 18

    main                           shift and go to state 17

state 9

    (3) funcs -> func_type . MODULE ID OPEN_PAREN funcs_params CLOSE_PAREN vars block

    MODULE          shift and go to state 19


state 10

    (4) funcs -> empty .

    MAIN            reduce using rule 4 (funcs -> empty .)


state 11

    (11) func_type -> var_type .

    MODULE          reduce using rule 11 (func_type -> var_type .)


state 12

    (12) func_type -> VOID .

    MODULE          reduce using rule 12 (func_type -> VOID .)


state 13

    (13) var_type -> INT .

    MODULE          reduce using rule 13 (var_type -> INT .)
    ID              reduce using rule 13 (var_type -> INT .)


state 14

    (14) var_type -> FLOAT .

    MODULE          reduce using rule 14 (var_type -> FLOAT .)
    ID              reduce using rule 14 (var_type -> FLOAT .)


state 15

    (15) var_type -> CHAR .

    MODULE          reduce using rule 15 (var_type -> CHAR .)
    ID              reduce using rule 15 (var_type -> CHAR .)


state 16

    (16) vars -> VARS create_var_table . var_comp
    (19) var_comp -> . var_type ids_dec var_comp_2 var_comp_final
    (20) var_comp -> . var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive
    (13) var_type -> . INT
    (14) var_type -> . FLOAT
    (15) var_type -> . CHAR

    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 15

    var_comp                       shift and go to state 20
    var_type                       shift and go to state 21

state 17

    (1) program -> PROGRAM ID SEMICOLON vars funcs main .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMICOLON vars funcs main .)


state 18

    (2) main -> MAIN . OPEN_PAREN CLOSE_PAREN block

    OPEN_PAREN      shift and go to state 22


state 19

    (3) funcs -> func_type MODULE . ID OPEN_PAREN funcs_params CLOSE_PAREN vars block

    ID              shift and go to state 23


state 20

    (16) vars -> VARS create_var_table var_comp .

    VOID            reduce using rule 16 (vars -> VARS create_var_table var_comp .)
    INT             reduce using rule 16 (vars -> VARS create_var_table var_comp .)
    FLOAT           reduce using rule 16 (vars -> VARS create_var_table var_comp .)
    CHAR            reduce using rule 16 (vars -> VARS create_var_table var_comp .)
    MAIN            reduce using rule 16 (vars -> VARS create_var_table var_comp .)
    OPEN_BRACES     reduce using rule 16 (vars -> VARS create_var_table var_comp .)


state 21

    (19) var_comp -> var_type . ids_dec var_comp_2 var_comp_final
    (20) var_comp -> var_type . ids_dec var_comp_2 SEMICOLON var_comp_recursive
    (29) ids_dec -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (30) ids_dec -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (31) ids_dec -> . ID

    ID              shift and go to state 25

    ids_dec                        shift and go to state 24

state 22

    (2) main -> MAIN OPEN_PAREN . CLOSE_PAREN block

    CLOSE_PAREN     shift and go to state 26


state 23

    (3) funcs -> func_type MODULE ID . OPEN_PAREN funcs_params CLOSE_PAREN vars block

    OPEN_PAREN      shift and go to state 27


state 24

    (19) var_comp -> var_type ids_dec . var_comp_2 var_comp_final
    (20) var_comp -> var_type ids_dec . var_comp_2 SEMICOLON var_comp_recursive
    (21) var_comp_2 -> . COMMA ids_dec var_comp_3
    (22) var_comp_2 -> . empty
    (90) empty -> .

    COMMA           shift and go to state 29
    SEMICOLON       reduce using rule 90 (empty -> .)

    var_comp_2                     shift and go to state 28
    empty                          shift and go to state 30

state 25

    (29) ids_dec -> ID . OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (30) ids_dec -> ID . OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (31) ids_dec -> ID .

    OPEN_BRACKETS   shift and go to state 31
    COMMA           reduce using rule 31 (ids_dec -> ID .)
    SEMICOLON       reduce using rule 31 (ids_dec -> ID .)
    ASSIGN          reduce using rule 31 (ids_dec -> ID .)


state 26

    (2) main -> MAIN OPEN_PAREN CLOSE_PAREN . block
    (10) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 33

    block                          shift and go to state 32

state 27

    (3) funcs -> func_type MODULE ID OPEN_PAREN . funcs_params CLOSE_PAREN vars block
    (6) funcs_params -> . var_type variable funcs_params_comp
    (7) funcs_params -> . empty
    (13) var_type -> . INT
    (14) var_type -> . FLOAT
    (15) var_type -> . CHAR
    (90) empty -> .

    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 15
    CLOSE_PAREN     reduce using rule 90 (empty -> .)

    funcs_params                   shift and go to state 34
    var_type                       shift and go to state 35
    empty                          shift and go to state 36

state 28

    (19) var_comp -> var_type ids_dec var_comp_2 . var_comp_final
    (20) var_comp -> var_type ids_dec var_comp_2 . SEMICOLON var_comp_recursive
    (26) var_comp_final -> . SEMICOLON
    (27) var_comp_final -> . var_module_trans
    (28) var_module_trans -> . SEMICOLON var_type MODULE funcs_comp

    SEMICOLON       shift and go to state 38

    var_comp_final                 shift and go to state 37
    var_module_trans               shift and go to state 39

state 29

    (21) var_comp_2 -> COMMA . ids_dec var_comp_3
    (29) ids_dec -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (30) ids_dec -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (31) ids_dec -> . ID

    ID              shift and go to state 25

    ids_dec                        shift and go to state 40

state 30

    (22) var_comp_2 -> empty .

    SEMICOLON       reduce using rule 22 (var_comp_2 -> empty .)


state 31

    (29) ids_dec -> ID OPEN_BRACKETS . CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (30) ids_dec -> ID OPEN_BRACKETS . CT_INT CLOSE_BRACKETS

    CT_INT          shift and go to state 41


state 32

    (2) main -> MAIN OPEN_PAREN CLOSE_PAREN block .

    $end            reduce using rule 2 (main -> MAIN OPEN_PAREN CLOSE_PAREN block .)


state 33

    (10) block -> OPEN_BRACES . statements CLOSE_BRACES
    (35) statements -> . assignment SEMICOLON statements
    (36) statements -> . read SEMICOLON statements
    (37) statements -> . write SEMICOLON statements
    (38) statements -> . condition statements
    (39) statements -> . return SEMICOLON statements
    (40) statements -> . func_call SEMICOLON statements
    (41) statements -> . empty
    (42) assignment -> . ids ASSIGN expressions
    (43) read -> . READ OPEN_PAREN ids read_comp CLOSE_PAREN
    (46) write -> . WRITE OPEN_PAREN CT_STRING write_comp CLOSE_PAREN
    (47) write -> . WRITE OPEN_PAREN expressions write_comp CLOSE_PAREN
    (51) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE block
    (52) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN THEN block
    (53) condition -> . WHILE OPEN_PAREN expressions CLOSE_PAREN DO block
    (54) condition -> . FOR ids_dec ASSIGN expressions TO expressions DO block
    (55) return -> . RETURN OPEN_PAREN exp CLOSE_PAREN
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN
    (90) empty -> .
    (32) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (33) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (34) ids -> . ID

    READ            shift and go to state 51
    WRITE           shift and go to state 52
    IF              shift and go to state 53
    WHILE           shift and go to state 54
    FOR             shift and go to state 55
    RETURN          shift and go to state 56
    ID              shift and go to state 57
    CLOSE_BRACES    reduce using rule 90 (empty -> .)

    statements                     shift and go to state 42
    assignment                     shift and go to state 43
    read                           shift and go to state 44
    write                          shift and go to state 45
    condition                      shift and go to state 46
    return                         shift and go to state 47
    func_call                      shift and go to state 48
    empty                          shift and go to state 49
    ids                            shift and go to state 50

state 34

    (3) funcs -> func_type MODULE ID OPEN_PAREN funcs_params . CLOSE_PAREN vars block

    CLOSE_PAREN     shift and go to state 58


state 35

    (6) funcs_params -> var_type . variable funcs_params_comp
    (87) variable -> . ID
    (88) variable -> . ID dim

    ID              shift and go to state 60

    variable                       shift and go to state 59

state 36

    (7) funcs_params -> empty .

    CLOSE_PAREN     reduce using rule 7 (funcs_params -> empty .)


state 37

    (19) var_comp -> var_type ids_dec var_comp_2 var_comp_final .

    VOID            reduce using rule 19 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)
    INT             reduce using rule 19 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)
    FLOAT           reduce using rule 19 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)
    CHAR            reduce using rule 19 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)
    MAIN            reduce using rule 19 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)
    OPEN_BRACES     reduce using rule 19 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)


state 38

    (20) var_comp -> var_type ids_dec var_comp_2 SEMICOLON . var_comp_recursive
    (26) var_comp_final -> SEMICOLON .
    (28) var_module_trans -> SEMICOLON . var_type MODULE funcs_comp
    (24) var_comp_recursive -> . var_type ids_dec var_comp_2 var_comp_final
    (25) var_comp_recursive -> . var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive
    (13) var_type -> . INT
    (14) var_type -> . FLOAT
    (15) var_type -> . CHAR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
    VOID            reduce using rule 26 (var_comp_final -> SEMICOLON .)
    MAIN            reduce using rule 26 (var_comp_final -> SEMICOLON .)
    OPEN_BRACES     reduce using rule 26 (var_comp_final -> SEMICOLON .)
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 15

  ! INT             [ reduce using rule 26 (var_comp_final -> SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 26 (var_comp_final -> SEMICOLON .) ]
  ! CHAR            [ reduce using rule 26 (var_comp_final -> SEMICOLON .) ]

    var_type                       shift and go to state 61
    var_comp_recursive             shift and go to state 62

state 39

    (27) var_comp_final -> var_module_trans .

    VOID            reduce using rule 27 (var_comp_final -> var_module_trans .)
    INT             reduce using rule 27 (var_comp_final -> var_module_trans .)
    FLOAT           reduce using rule 27 (var_comp_final -> var_module_trans .)
    CHAR            reduce using rule 27 (var_comp_final -> var_module_trans .)
    MAIN            reduce using rule 27 (var_comp_final -> var_module_trans .)
    OPEN_BRACES     reduce using rule 27 (var_comp_final -> var_module_trans .)


state 40

    (21) var_comp_2 -> COMMA ids_dec . var_comp_3
    (23) var_comp_3 -> . var_comp_2
    (21) var_comp_2 -> . COMMA ids_dec var_comp_3
    (22) var_comp_2 -> . empty
    (90) empty -> .

    COMMA           shift and go to state 29
    SEMICOLON       reduce using rule 90 (empty -> .)

    var_comp_3                     shift and go to state 63
    var_comp_2                     shift and go to state 64
    empty                          shift and go to state 30

state 41

    (29) ids_dec -> ID OPEN_BRACKETS CT_INT . CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (30) ids_dec -> ID OPEN_BRACKETS CT_INT . CLOSE_BRACKETS

    CLOSE_BRACKETS  shift and go to state 65


state 42

    (10) block -> OPEN_BRACES statements . CLOSE_BRACES

    CLOSE_BRACES    shift and go to state 66


state 43

    (35) statements -> assignment . SEMICOLON statements

    SEMICOLON       shift and go to state 67


state 44

    (36) statements -> read . SEMICOLON statements

    SEMICOLON       shift and go to state 68


state 45

    (37) statements -> write . SEMICOLON statements

    SEMICOLON       shift and go to state 69


state 46

    (38) statements -> condition . statements
    (35) statements -> . assignment SEMICOLON statements
    (36) statements -> . read SEMICOLON statements
    (37) statements -> . write SEMICOLON statements
    (38) statements -> . condition statements
    (39) statements -> . return SEMICOLON statements
    (40) statements -> . func_call SEMICOLON statements
    (41) statements -> . empty
    (42) assignment -> . ids ASSIGN expressions
    (43) read -> . READ OPEN_PAREN ids read_comp CLOSE_PAREN
    (46) write -> . WRITE OPEN_PAREN CT_STRING write_comp CLOSE_PAREN
    (47) write -> . WRITE OPEN_PAREN expressions write_comp CLOSE_PAREN
    (51) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE block
    (52) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN THEN block
    (53) condition -> . WHILE OPEN_PAREN expressions CLOSE_PAREN DO block
    (54) condition -> . FOR ids_dec ASSIGN expressions TO expressions DO block
    (55) return -> . RETURN OPEN_PAREN exp CLOSE_PAREN
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN
    (90) empty -> .
    (32) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (33) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (34) ids -> . ID

    READ            shift and go to state 51
    WRITE           shift and go to state 52
    IF              shift and go to state 53
    WHILE           shift and go to state 54
    FOR             shift and go to state 55
    RETURN          shift and go to state 56
    ID              shift and go to state 57
    CLOSE_BRACES    reduce using rule 90 (empty -> .)

    condition                      shift and go to state 46
    statements                     shift and go to state 70
    assignment                     shift and go to state 43
    read                           shift and go to state 44
    write                          shift and go to state 45
    return                         shift and go to state 47
    func_call                      shift and go to state 48
    empty                          shift and go to state 49
    ids                            shift and go to state 50

state 47

    (39) statements -> return . SEMICOLON statements

    SEMICOLON       shift and go to state 71


state 48

    (40) statements -> func_call . SEMICOLON statements

    SEMICOLON       shift and go to state 72


state 49

    (41) statements -> empty .

    CLOSE_BRACES    reduce using rule 41 (statements -> empty .)


state 50

    (42) assignment -> ids . ASSIGN expressions

    ASSIGN          shift and go to state 73


state 51

    (43) read -> READ . OPEN_PAREN ids read_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 74


state 52

    (46) write -> WRITE . OPEN_PAREN CT_STRING write_comp CLOSE_PAREN
    (47) write -> WRITE . OPEN_PAREN expressions write_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 75


state 53

    (51) condition -> IF . OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE block
    (52) condition -> IF . OPEN_PAREN expressions CLOSE_PAREN THEN block

    OPEN_PAREN      shift and go to state 76


state 54

    (53) condition -> WHILE . OPEN_PAREN expressions CLOSE_PAREN DO block

    OPEN_PAREN      shift and go to state 77


state 55

    (54) condition -> FOR . ids_dec ASSIGN expressions TO expressions DO block
    (29) ids_dec -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (30) ids_dec -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (31) ids_dec -> . ID

    ID              shift and go to state 25

    ids_dec                        shift and go to state 78

state 56

    (55) return -> RETURN . OPEN_PAREN exp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 79


state 57

    (56) func_call -> ID . OPEN_PAREN func_call_comp CLOSE_PAREN
    (32) ids -> ID . OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (33) ids -> ID . OPEN_BRACKETS exp CLOSE_BRACKETS
    (34) ids -> ID .

    OPEN_PAREN      shift and go to state 80
    OPEN_BRACKETS   shift and go to state 81
    ASSIGN          reduce using rule 34 (ids -> ID .)


state 58

    (3) funcs -> func_type MODULE ID OPEN_PAREN funcs_params CLOSE_PAREN . vars block
    (16) vars -> . VARS create_var_table var_comp
    (17) vars -> . empty
    (90) empty -> .

    VARS            shift and go to state 6
    OPEN_BRACES     reduce using rule 90 (empty -> .)

    vars                           shift and go to state 82
    empty                          shift and go to state 7

state 59

    (6) funcs_params -> var_type variable . funcs_params_comp
    (8) funcs_params_comp -> . COMMA var_type ID funcs_params_comp
    (9) funcs_params_comp -> . empty
    (90) empty -> .

    COMMA           shift and go to state 84
    CLOSE_PAREN     reduce using rule 90 (empty -> .)

    funcs_params_comp              shift and go to state 83
    empty                          shift and go to state 85

state 60

    (87) variable -> ID .
    (88) variable -> ID . dim
    (89) dim -> . OPEN_BRACKETS exp CLOSE_BRACKETS

    COMMA           reduce using rule 87 (variable -> ID .)
    CLOSE_PAREN     reduce using rule 87 (variable -> ID .)
    OPEN_BRACKETS   shift and go to state 87

    dim                            shift and go to state 86

state 61

    (28) var_module_trans -> SEMICOLON var_type . MODULE funcs_comp
    (24) var_comp_recursive -> var_type . ids_dec var_comp_2 var_comp_final
    (25) var_comp_recursive -> var_type . ids_dec var_comp_2 SEMICOLON var_comp_recursive
    (29) ids_dec -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (30) ids_dec -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (31) ids_dec -> . ID

    MODULE          shift and go to state 88
    ID              shift and go to state 25

    ids_dec                        shift and go to state 89

state 62

    (20) var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .

    VOID            reduce using rule 20 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    INT             reduce using rule 20 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    FLOAT           reduce using rule 20 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    CHAR            reduce using rule 20 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    MAIN            reduce using rule 20 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    OPEN_BRACES     reduce using rule 20 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)


state 63

    (21) var_comp_2 -> COMMA ids_dec var_comp_3 .

    SEMICOLON       reduce using rule 21 (var_comp_2 -> COMMA ids_dec var_comp_3 .)


state 64

    (23) var_comp_3 -> var_comp_2 .

    SEMICOLON       reduce using rule 23 (var_comp_3 -> var_comp_2 .)


state 65

    (29) ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS . OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (30) ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS .

    OPEN_BRACKETS   shift and go to state 90
    COMMA           reduce using rule 30 (ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS .)
    SEMICOLON       reduce using rule 30 (ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS .)
    ASSIGN          reduce using rule 30 (ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS .)


state 66

    (10) block -> OPEN_BRACES statements CLOSE_BRACES .

    $end            reduce using rule 10 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    MAIN            reduce using rule 10 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    ELSE            reduce using rule 10 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    READ            reduce using rule 10 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    WRITE           reduce using rule 10 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    IF              reduce using rule 10 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    WHILE           reduce using rule 10 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    FOR             reduce using rule 10 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    RETURN          reduce using rule 10 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    ID              reduce using rule 10 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    CLOSE_BRACES    reduce using rule 10 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    VOID            reduce using rule 10 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    INT             reduce using rule 10 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    FLOAT           reduce using rule 10 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    CHAR            reduce using rule 10 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    OPEN_BRACES     reduce using rule 10 (block -> OPEN_BRACES statements CLOSE_BRACES .)


state 67

    (35) statements -> assignment SEMICOLON . statements
    (35) statements -> . assignment SEMICOLON statements
    (36) statements -> . read SEMICOLON statements
    (37) statements -> . write SEMICOLON statements
    (38) statements -> . condition statements
    (39) statements -> . return SEMICOLON statements
    (40) statements -> . func_call SEMICOLON statements
    (41) statements -> . empty
    (42) assignment -> . ids ASSIGN expressions
    (43) read -> . READ OPEN_PAREN ids read_comp CLOSE_PAREN
    (46) write -> . WRITE OPEN_PAREN CT_STRING write_comp CLOSE_PAREN
    (47) write -> . WRITE OPEN_PAREN expressions write_comp CLOSE_PAREN
    (51) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE block
    (52) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN THEN block
    (53) condition -> . WHILE OPEN_PAREN expressions CLOSE_PAREN DO block
    (54) condition -> . FOR ids_dec ASSIGN expressions TO expressions DO block
    (55) return -> . RETURN OPEN_PAREN exp CLOSE_PAREN
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN
    (90) empty -> .
    (32) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (33) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (34) ids -> . ID

    READ            shift and go to state 51
    WRITE           shift and go to state 52
    IF              shift and go to state 53
    WHILE           shift and go to state 54
    FOR             shift and go to state 55
    RETURN          shift and go to state 56
    ID              shift and go to state 57
    CLOSE_BRACES    reduce using rule 90 (empty -> .)

    assignment                     shift and go to state 43
    statements                     shift and go to state 91
    read                           shift and go to state 44
    write                          shift and go to state 45
    condition                      shift and go to state 46
    return                         shift and go to state 47
    func_call                      shift and go to state 48
    empty                          shift and go to state 49
    ids                            shift and go to state 50

state 68

    (36) statements -> read SEMICOLON . statements
    (35) statements -> . assignment SEMICOLON statements
    (36) statements -> . read SEMICOLON statements
    (37) statements -> . write SEMICOLON statements
    (38) statements -> . condition statements
    (39) statements -> . return SEMICOLON statements
    (40) statements -> . func_call SEMICOLON statements
    (41) statements -> . empty
    (42) assignment -> . ids ASSIGN expressions
    (43) read -> . READ OPEN_PAREN ids read_comp CLOSE_PAREN
    (46) write -> . WRITE OPEN_PAREN CT_STRING write_comp CLOSE_PAREN
    (47) write -> . WRITE OPEN_PAREN expressions write_comp CLOSE_PAREN
    (51) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE block
    (52) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN THEN block
    (53) condition -> . WHILE OPEN_PAREN expressions CLOSE_PAREN DO block
    (54) condition -> . FOR ids_dec ASSIGN expressions TO expressions DO block
    (55) return -> . RETURN OPEN_PAREN exp CLOSE_PAREN
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN
    (90) empty -> .
    (32) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (33) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (34) ids -> . ID

    READ            shift and go to state 51
    WRITE           shift and go to state 52
    IF              shift and go to state 53
    WHILE           shift and go to state 54
    FOR             shift and go to state 55
    RETURN          shift and go to state 56
    ID              shift and go to state 57
    CLOSE_BRACES    reduce using rule 90 (empty -> .)

    read                           shift and go to state 44
    statements                     shift and go to state 92
    assignment                     shift and go to state 43
    write                          shift and go to state 45
    condition                      shift and go to state 46
    return                         shift and go to state 47
    func_call                      shift and go to state 48
    empty                          shift and go to state 49
    ids                            shift and go to state 50

state 69

    (37) statements -> write SEMICOLON . statements
    (35) statements -> . assignment SEMICOLON statements
    (36) statements -> . read SEMICOLON statements
    (37) statements -> . write SEMICOLON statements
    (38) statements -> . condition statements
    (39) statements -> . return SEMICOLON statements
    (40) statements -> . func_call SEMICOLON statements
    (41) statements -> . empty
    (42) assignment -> . ids ASSIGN expressions
    (43) read -> . READ OPEN_PAREN ids read_comp CLOSE_PAREN
    (46) write -> . WRITE OPEN_PAREN CT_STRING write_comp CLOSE_PAREN
    (47) write -> . WRITE OPEN_PAREN expressions write_comp CLOSE_PAREN
    (51) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE block
    (52) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN THEN block
    (53) condition -> . WHILE OPEN_PAREN expressions CLOSE_PAREN DO block
    (54) condition -> . FOR ids_dec ASSIGN expressions TO expressions DO block
    (55) return -> . RETURN OPEN_PAREN exp CLOSE_PAREN
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN
    (90) empty -> .
    (32) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (33) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (34) ids -> . ID

    READ            shift and go to state 51
    WRITE           shift and go to state 52
    IF              shift and go to state 53
    WHILE           shift and go to state 54
    FOR             shift and go to state 55
    RETURN          shift and go to state 56
    ID              shift and go to state 57
    CLOSE_BRACES    reduce using rule 90 (empty -> .)

    write                          shift and go to state 45
    statements                     shift and go to state 93
    assignment                     shift and go to state 43
    read                           shift and go to state 44
    condition                      shift and go to state 46
    return                         shift and go to state 47
    func_call                      shift and go to state 48
    empty                          shift and go to state 49
    ids                            shift and go to state 50

state 70

    (38) statements -> condition statements .

    CLOSE_BRACES    reduce using rule 38 (statements -> condition statements .)


state 71

    (39) statements -> return SEMICOLON . statements
    (35) statements -> . assignment SEMICOLON statements
    (36) statements -> . read SEMICOLON statements
    (37) statements -> . write SEMICOLON statements
    (38) statements -> . condition statements
    (39) statements -> . return SEMICOLON statements
    (40) statements -> . func_call SEMICOLON statements
    (41) statements -> . empty
    (42) assignment -> . ids ASSIGN expressions
    (43) read -> . READ OPEN_PAREN ids read_comp CLOSE_PAREN
    (46) write -> . WRITE OPEN_PAREN CT_STRING write_comp CLOSE_PAREN
    (47) write -> . WRITE OPEN_PAREN expressions write_comp CLOSE_PAREN
    (51) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE block
    (52) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN THEN block
    (53) condition -> . WHILE OPEN_PAREN expressions CLOSE_PAREN DO block
    (54) condition -> . FOR ids_dec ASSIGN expressions TO expressions DO block
    (55) return -> . RETURN OPEN_PAREN exp CLOSE_PAREN
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN
    (90) empty -> .
    (32) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (33) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (34) ids -> . ID

    READ            shift and go to state 51
    WRITE           shift and go to state 52
    IF              shift and go to state 53
    WHILE           shift and go to state 54
    FOR             shift and go to state 55
    RETURN          shift and go to state 56
    ID              shift and go to state 57
    CLOSE_BRACES    reduce using rule 90 (empty -> .)

    return                         shift and go to state 47
    statements                     shift and go to state 94
    assignment                     shift and go to state 43
    read                           shift and go to state 44
    write                          shift and go to state 45
    condition                      shift and go to state 46
    func_call                      shift and go to state 48
    empty                          shift and go to state 49
    ids                            shift and go to state 50

state 72

    (40) statements -> func_call SEMICOLON . statements
    (35) statements -> . assignment SEMICOLON statements
    (36) statements -> . read SEMICOLON statements
    (37) statements -> . write SEMICOLON statements
    (38) statements -> . condition statements
    (39) statements -> . return SEMICOLON statements
    (40) statements -> . func_call SEMICOLON statements
    (41) statements -> . empty
    (42) assignment -> . ids ASSIGN expressions
    (43) read -> . READ OPEN_PAREN ids read_comp CLOSE_PAREN
    (46) write -> . WRITE OPEN_PAREN CT_STRING write_comp CLOSE_PAREN
    (47) write -> . WRITE OPEN_PAREN expressions write_comp CLOSE_PAREN
    (51) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE block
    (52) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN THEN block
    (53) condition -> . WHILE OPEN_PAREN expressions CLOSE_PAREN DO block
    (54) condition -> . FOR ids_dec ASSIGN expressions TO expressions DO block
    (55) return -> . RETURN OPEN_PAREN exp CLOSE_PAREN
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN
    (90) empty -> .
    (32) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (33) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (34) ids -> . ID

    READ            shift and go to state 51
    WRITE           shift and go to state 52
    IF              shift and go to state 53
    WHILE           shift and go to state 54
    FOR             shift and go to state 55
    RETURN          shift and go to state 56
    ID              shift and go to state 57
    CLOSE_BRACES    reduce using rule 90 (empty -> .)

    func_call                      shift and go to state 48
    statements                     shift and go to state 95
    assignment                     shift and go to state 43
    read                           shift and go to state 44
    write                          shift and go to state 45
    condition                      shift and go to state 46
    return                         shift and go to state 47
    empty                          shift and go to state 49
    ids                            shift and go to state 50

state 73

    (42) assignment -> ids ASSIGN . expressions
    (60) expressions -> . expressions_comp
    (61) expressions_comp -> . expression_comp_2
    (62) expressions_comp -> . expression_comp_2 OR expressions_comp
    (63) expression_comp_2 -> . expression_comp_3
    (64) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (65) expression_comp_3 -> . exp
    (66) expression_comp_3 -> . exp expressions_op exp
    (73) exp -> . term
    (74) exp -> . term exp_comp
    (77) term -> . factor
    (78) term -> . factor term_comp
    (81) factor -> . OPEN_PAREN expressions CLOSE_PAREN
    (82) factor -> . variable
    (83) factor -> . func_call
    (84) factor -> . CT_INT
    (85) factor -> . CT_FLOAT
    (86) factor -> . CT_CHAR
    (87) variable -> . ID
    (88) variable -> . ID dim
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 103
    CT_INT          shift and go to state 106
    CT_FLOAT        shift and go to state 107
    CT_CHAR         shift and go to state 108
    ID              shift and go to state 109

    expressions                    shift and go to state 96
    expressions_comp               shift and go to state 97
    expression_comp_2              shift and go to state 98
    expression_comp_3              shift and go to state 99
    exp                            shift and go to state 100
    term                           shift and go to state 101
    factor                         shift and go to state 102
    variable                       shift and go to state 104
    func_call                      shift and go to state 105

state 74

    (43) read -> READ OPEN_PAREN . ids read_comp CLOSE_PAREN
    (32) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (33) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (34) ids -> . ID

    ID              shift and go to state 111

    ids                            shift and go to state 110

state 75

    (46) write -> WRITE OPEN_PAREN . CT_STRING write_comp CLOSE_PAREN
    (47) write -> WRITE OPEN_PAREN . expressions write_comp CLOSE_PAREN
    (60) expressions -> . expressions_comp
    (61) expressions_comp -> . expression_comp_2
    (62) expressions_comp -> . expression_comp_2 OR expressions_comp
    (63) expression_comp_2 -> . expression_comp_3
    (64) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (65) expression_comp_3 -> . exp
    (66) expression_comp_3 -> . exp expressions_op exp
    (73) exp -> . term
    (74) exp -> . term exp_comp
    (77) term -> . factor
    (78) term -> . factor term_comp
    (81) factor -> . OPEN_PAREN expressions CLOSE_PAREN
    (82) factor -> . variable
    (83) factor -> . func_call
    (84) factor -> . CT_INT
    (85) factor -> . CT_FLOAT
    (86) factor -> . CT_CHAR
    (87) variable -> . ID
    (88) variable -> . ID dim
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    CT_STRING       shift and go to state 112
    OPEN_PAREN      shift and go to state 103
    CT_INT          shift and go to state 106
    CT_FLOAT        shift and go to state 107
    CT_CHAR         shift and go to state 108
    ID              shift and go to state 109

    expressions                    shift and go to state 113
    expressions_comp               shift and go to state 97
    expression_comp_2              shift and go to state 98
    expression_comp_3              shift and go to state 99
    exp                            shift and go to state 100
    term                           shift and go to state 101
    factor                         shift and go to state 102
    variable                       shift and go to state 104
    func_call                      shift and go to state 105

state 76

    (51) condition -> IF OPEN_PAREN . expressions CLOSE_PAREN THEN block ELSE block
    (52) condition -> IF OPEN_PAREN . expressions CLOSE_PAREN THEN block
    (60) expressions -> . expressions_comp
    (61) expressions_comp -> . expression_comp_2
    (62) expressions_comp -> . expression_comp_2 OR expressions_comp
    (63) expression_comp_2 -> . expression_comp_3
    (64) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (65) expression_comp_3 -> . exp
    (66) expression_comp_3 -> . exp expressions_op exp
    (73) exp -> . term
    (74) exp -> . term exp_comp
    (77) term -> . factor
    (78) term -> . factor term_comp
    (81) factor -> . OPEN_PAREN expressions CLOSE_PAREN
    (82) factor -> . variable
    (83) factor -> . func_call
    (84) factor -> . CT_INT
    (85) factor -> . CT_FLOAT
    (86) factor -> . CT_CHAR
    (87) variable -> . ID
    (88) variable -> . ID dim
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 103
    CT_INT          shift and go to state 106
    CT_FLOAT        shift and go to state 107
    CT_CHAR         shift and go to state 108
    ID              shift and go to state 109

    expressions                    shift and go to state 114
    expressions_comp               shift and go to state 97
    expression_comp_2              shift and go to state 98
    expression_comp_3              shift and go to state 99
    exp                            shift and go to state 100
    term                           shift and go to state 101
    factor                         shift and go to state 102
    variable                       shift and go to state 104
    func_call                      shift and go to state 105

state 77

    (53) condition -> WHILE OPEN_PAREN . expressions CLOSE_PAREN DO block
    (60) expressions -> . expressions_comp
    (61) expressions_comp -> . expression_comp_2
    (62) expressions_comp -> . expression_comp_2 OR expressions_comp
    (63) expression_comp_2 -> . expression_comp_3
    (64) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (65) expression_comp_3 -> . exp
    (66) expression_comp_3 -> . exp expressions_op exp
    (73) exp -> . term
    (74) exp -> . term exp_comp
    (77) term -> . factor
    (78) term -> . factor term_comp
    (81) factor -> . OPEN_PAREN expressions CLOSE_PAREN
    (82) factor -> . variable
    (83) factor -> . func_call
    (84) factor -> . CT_INT
    (85) factor -> . CT_FLOAT
    (86) factor -> . CT_CHAR
    (87) variable -> . ID
    (88) variable -> . ID dim
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 103
    CT_INT          shift and go to state 106
    CT_FLOAT        shift and go to state 107
    CT_CHAR         shift and go to state 108
    ID              shift and go to state 109

    expressions                    shift and go to state 115
    expressions_comp               shift and go to state 97
    expression_comp_2              shift and go to state 98
    expression_comp_3              shift and go to state 99
    exp                            shift and go to state 100
    term                           shift and go to state 101
    factor                         shift and go to state 102
    variable                       shift and go to state 104
    func_call                      shift and go to state 105

state 78

    (54) condition -> FOR ids_dec . ASSIGN expressions TO expressions DO block

    ASSIGN          shift and go to state 116


state 79

    (55) return -> RETURN OPEN_PAREN . exp CLOSE_PAREN
    (73) exp -> . term
    (74) exp -> . term exp_comp
    (77) term -> . factor
    (78) term -> . factor term_comp
    (81) factor -> . OPEN_PAREN expressions CLOSE_PAREN
    (82) factor -> . variable
    (83) factor -> . func_call
    (84) factor -> . CT_INT
    (85) factor -> . CT_FLOAT
    (86) factor -> . CT_CHAR
    (87) variable -> . ID
    (88) variable -> . ID dim
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 103
    CT_INT          shift and go to state 106
    CT_FLOAT        shift and go to state 107
    CT_CHAR         shift and go to state 108
    ID              shift and go to state 109

    exp                            shift and go to state 117
    term                           shift and go to state 101
    factor                         shift and go to state 102
    variable                       shift and go to state 104
    func_call                      shift and go to state 105

state 80

    (56) func_call -> ID OPEN_PAREN . func_call_comp CLOSE_PAREN
    (57) func_call_comp -> . expressions func_call_comp
    (58) func_call_comp -> . COMMA expressions func_call_comp
    (59) func_call_comp -> . empty
    (60) expressions -> . expressions_comp
    (90) empty -> .
    (61) expressions_comp -> . expression_comp_2
    (62) expressions_comp -> . expression_comp_2 OR expressions_comp
    (63) expression_comp_2 -> . expression_comp_3
    (64) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (65) expression_comp_3 -> . exp
    (66) expression_comp_3 -> . exp expressions_op exp
    (73) exp -> . term
    (74) exp -> . term exp_comp
    (77) term -> . factor
    (78) term -> . factor term_comp
    (81) factor -> . OPEN_PAREN expressions CLOSE_PAREN
    (82) factor -> . variable
    (83) factor -> . func_call
    (84) factor -> . CT_INT
    (85) factor -> . CT_FLOAT
    (86) factor -> . CT_CHAR
    (87) variable -> . ID
    (88) variable -> . ID dim
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    COMMA           shift and go to state 120
    CLOSE_PAREN     reduce using rule 90 (empty -> .)
    OPEN_PAREN      shift and go to state 103
    CT_INT          shift and go to state 106
    CT_FLOAT        shift and go to state 107
    CT_CHAR         shift and go to state 108
    ID              shift and go to state 109

    func_call_comp                 shift and go to state 118
    expressions                    shift and go to state 119
    empty                          shift and go to state 121
    expressions_comp               shift and go to state 97
    expression_comp_2              shift and go to state 98
    expression_comp_3              shift and go to state 99
    exp                            shift and go to state 100
    term                           shift and go to state 101
    factor                         shift and go to state 102
    variable                       shift and go to state 104
    func_call                      shift and go to state 105

state 81

    (32) ids -> ID OPEN_BRACKETS . exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (33) ids -> ID OPEN_BRACKETS . exp CLOSE_BRACKETS
    (73) exp -> . term
    (74) exp -> . term exp_comp
    (77) term -> . factor
    (78) term -> . factor term_comp
    (81) factor -> . OPEN_PAREN expressions CLOSE_PAREN
    (82) factor -> . variable
    (83) factor -> . func_call
    (84) factor -> . CT_INT
    (85) factor -> . CT_FLOAT
    (86) factor -> . CT_CHAR
    (87) variable -> . ID
    (88) variable -> . ID dim
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 103
    CT_INT          shift and go to state 106
    CT_FLOAT        shift and go to state 107
    CT_CHAR         shift and go to state 108
    ID              shift and go to state 109

    exp                            shift and go to state 122
    term                           shift and go to state 101
    factor                         shift and go to state 102
    variable                       shift and go to state 104
    func_call                      shift and go to state 105

state 82

    (3) funcs -> func_type MODULE ID OPEN_PAREN funcs_params CLOSE_PAREN vars . block
    (10) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 33

    block                          shift and go to state 123

state 83

    (6) funcs_params -> var_type variable funcs_params_comp .

    CLOSE_PAREN     reduce using rule 6 (funcs_params -> var_type variable funcs_params_comp .)


state 84

    (8) funcs_params_comp -> COMMA . var_type ID funcs_params_comp
    (13) var_type -> . INT
    (14) var_type -> . FLOAT
    (15) var_type -> . CHAR

    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 15

    var_type                       shift and go to state 124

state 85

    (9) funcs_params_comp -> empty .

    CLOSE_PAREN     reduce using rule 9 (funcs_params_comp -> empty .)


state 86

    (88) variable -> ID dim .

    COMMA           reduce using rule 88 (variable -> ID dim .)
    CLOSE_PAREN     reduce using rule 88 (variable -> ID dim .)
    MULTIPLIES      reduce using rule 88 (variable -> ID dim .)
    DIVIDE          reduce using rule 88 (variable -> ID dim .)
    PLUS            reduce using rule 88 (variable -> ID dim .)
    MINUS           reduce using rule 88 (variable -> ID dim .)
    LESS_THAN       reduce using rule 88 (variable -> ID dim .)
    LESS_THAN_EQUAL reduce using rule 88 (variable -> ID dim .)
    MORE_THAN       reduce using rule 88 (variable -> ID dim .)
    MORE_THAN_EQUAL reduce using rule 88 (variable -> ID dim .)
    EQUALS          reduce using rule 88 (variable -> ID dim .)
    NOT_EQUALS      reduce using rule 88 (variable -> ID dim .)
    AND             reduce using rule 88 (variable -> ID dim .)
    OR              reduce using rule 88 (variable -> ID dim .)
    SEMICOLON       reduce using rule 88 (variable -> ID dim .)
    OPEN_PAREN      reduce using rule 88 (variable -> ID dim .)
    CT_INT          reduce using rule 88 (variable -> ID dim .)
    CT_FLOAT        reduce using rule 88 (variable -> ID dim .)
    CT_CHAR         reduce using rule 88 (variable -> ID dim .)
    ID              reduce using rule 88 (variable -> ID dim .)
    CLOSE_BRACKETS  reduce using rule 88 (variable -> ID dim .)
    TO              reduce using rule 88 (variable -> ID dim .)
    DO              reduce using rule 88 (variable -> ID dim .)


state 87

    (89) dim -> OPEN_BRACKETS . exp CLOSE_BRACKETS
    (73) exp -> . term
    (74) exp -> . term exp_comp
    (77) term -> . factor
    (78) term -> . factor term_comp
    (81) factor -> . OPEN_PAREN expressions CLOSE_PAREN
    (82) factor -> . variable
    (83) factor -> . func_call
    (84) factor -> . CT_INT
    (85) factor -> . CT_FLOAT
    (86) factor -> . CT_CHAR
    (87) variable -> . ID
    (88) variable -> . ID dim
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 103
    CT_INT          shift and go to state 106
    CT_FLOAT        shift and go to state 107
    CT_CHAR         shift and go to state 108
    ID              shift and go to state 109

    exp                            shift and go to state 125
    term                           shift and go to state 101
    factor                         shift and go to state 102
    variable                       shift and go to state 104
    func_call                      shift and go to state 105

state 88

    (28) var_module_trans -> SEMICOLON var_type MODULE . funcs_comp
    (5) funcs_comp -> . ID OPEN_PAREN funcs_params CLOSE_PAREN vars block

    ID              shift and go to state 127

    funcs_comp                     shift and go to state 126

state 89

    (24) var_comp_recursive -> var_type ids_dec . var_comp_2 var_comp_final
    (25) var_comp_recursive -> var_type ids_dec . var_comp_2 SEMICOLON var_comp_recursive
    (21) var_comp_2 -> . COMMA ids_dec var_comp_3
    (22) var_comp_2 -> . empty
    (90) empty -> .

    COMMA           shift and go to state 29
    SEMICOLON       reduce using rule 90 (empty -> .)

    var_comp_2                     shift and go to state 128
    empty                          shift and go to state 30

state 90

    (29) ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS . CT_INT CLOSE_BRACKETS

    CT_INT          shift and go to state 129


state 91

    (35) statements -> assignment SEMICOLON statements .

    CLOSE_BRACES    reduce using rule 35 (statements -> assignment SEMICOLON statements .)


state 92

    (36) statements -> read SEMICOLON statements .

    CLOSE_BRACES    reduce using rule 36 (statements -> read SEMICOLON statements .)


state 93

    (37) statements -> write SEMICOLON statements .

    CLOSE_BRACES    reduce using rule 37 (statements -> write SEMICOLON statements .)


state 94

    (39) statements -> return SEMICOLON statements .

    CLOSE_BRACES    reduce using rule 39 (statements -> return SEMICOLON statements .)


state 95

    (40) statements -> func_call SEMICOLON statements .

    CLOSE_BRACES    reduce using rule 40 (statements -> func_call SEMICOLON statements .)


state 96

    (42) assignment -> ids ASSIGN expressions .

    SEMICOLON       reduce using rule 42 (assignment -> ids ASSIGN expressions .)


state 97

    (60) expressions -> expressions_comp .

    SEMICOLON       reduce using rule 60 (expressions -> expressions_comp .)
    COMMA           reduce using rule 60 (expressions -> expressions_comp .)
    CLOSE_PAREN     reduce using rule 60 (expressions -> expressions_comp .)
    OPEN_PAREN      reduce using rule 60 (expressions -> expressions_comp .)
    CT_INT          reduce using rule 60 (expressions -> expressions_comp .)
    CT_FLOAT        reduce using rule 60 (expressions -> expressions_comp .)
    CT_CHAR         reduce using rule 60 (expressions -> expressions_comp .)
    ID              reduce using rule 60 (expressions -> expressions_comp .)
    TO              reduce using rule 60 (expressions -> expressions_comp .)
    DO              reduce using rule 60 (expressions -> expressions_comp .)


state 98

    (61) expressions_comp -> expression_comp_2 .
    (62) expressions_comp -> expression_comp_2 . OR expressions_comp

    SEMICOLON       reduce using rule 61 (expressions_comp -> expression_comp_2 .)
    COMMA           reduce using rule 61 (expressions_comp -> expression_comp_2 .)
    CLOSE_PAREN     reduce using rule 61 (expressions_comp -> expression_comp_2 .)
    OPEN_PAREN      reduce using rule 61 (expressions_comp -> expression_comp_2 .)
    CT_INT          reduce using rule 61 (expressions_comp -> expression_comp_2 .)
    CT_FLOAT        reduce using rule 61 (expressions_comp -> expression_comp_2 .)
    CT_CHAR         reduce using rule 61 (expressions_comp -> expression_comp_2 .)
    ID              reduce using rule 61 (expressions_comp -> expression_comp_2 .)
    TO              reduce using rule 61 (expressions_comp -> expression_comp_2 .)
    DO              reduce using rule 61 (expressions_comp -> expression_comp_2 .)
    OR              shift and go to state 130


state 99

    (63) expression_comp_2 -> expression_comp_3 .
    (64) expression_comp_2 -> expression_comp_3 . AND expression_comp_2

    OR              reduce using rule 63 (expression_comp_2 -> expression_comp_3 .)
    SEMICOLON       reduce using rule 63 (expression_comp_2 -> expression_comp_3 .)
    COMMA           reduce using rule 63 (expression_comp_2 -> expression_comp_3 .)
    CLOSE_PAREN     reduce using rule 63 (expression_comp_2 -> expression_comp_3 .)
    OPEN_PAREN      reduce using rule 63 (expression_comp_2 -> expression_comp_3 .)
    CT_INT          reduce using rule 63 (expression_comp_2 -> expression_comp_3 .)
    CT_FLOAT        reduce using rule 63 (expression_comp_2 -> expression_comp_3 .)
    CT_CHAR         reduce using rule 63 (expression_comp_2 -> expression_comp_3 .)
    ID              reduce using rule 63 (expression_comp_2 -> expression_comp_3 .)
    TO              reduce using rule 63 (expression_comp_2 -> expression_comp_3 .)
    DO              reduce using rule 63 (expression_comp_2 -> expression_comp_3 .)
    AND             shift and go to state 131


state 100

    (65) expression_comp_3 -> exp .
    (66) expression_comp_3 -> exp . expressions_op exp
    (67) expressions_op -> . LESS_THAN
    (68) expressions_op -> . LESS_THAN_EQUAL
    (69) expressions_op -> . MORE_THAN
    (70) expressions_op -> . MORE_THAN_EQUAL
    (71) expressions_op -> . EQUALS
    (72) expressions_op -> . NOT_EQUALS

    AND             reduce using rule 65 (expression_comp_3 -> exp .)
    OR              reduce using rule 65 (expression_comp_3 -> exp .)
    SEMICOLON       reduce using rule 65 (expression_comp_3 -> exp .)
    COMMA           reduce using rule 65 (expression_comp_3 -> exp .)
    CLOSE_PAREN     reduce using rule 65 (expression_comp_3 -> exp .)
    OPEN_PAREN      reduce using rule 65 (expression_comp_3 -> exp .)
    CT_INT          reduce using rule 65 (expression_comp_3 -> exp .)
    CT_FLOAT        reduce using rule 65 (expression_comp_3 -> exp .)
    CT_CHAR         reduce using rule 65 (expression_comp_3 -> exp .)
    ID              reduce using rule 65 (expression_comp_3 -> exp .)
    TO              reduce using rule 65 (expression_comp_3 -> exp .)
    DO              reduce using rule 65 (expression_comp_3 -> exp .)
    LESS_THAN       shift and go to state 133
    LESS_THAN_EQUAL shift and go to state 134
    MORE_THAN       shift and go to state 135
    MORE_THAN_EQUAL shift and go to state 136
    EQUALS          shift and go to state 137
    NOT_EQUALS      shift and go to state 138

    expressions_op                 shift and go to state 132

state 101

    (73) exp -> term .
    (74) exp -> term . exp_comp
    (75) exp_comp -> . PLUS exp
    (76) exp_comp -> . MINUS exp

    LESS_THAN       reduce using rule 73 (exp -> term .)
    LESS_THAN_EQUAL reduce using rule 73 (exp -> term .)
    MORE_THAN       reduce using rule 73 (exp -> term .)
    MORE_THAN_EQUAL reduce using rule 73 (exp -> term .)
    EQUALS          reduce using rule 73 (exp -> term .)
    NOT_EQUALS      reduce using rule 73 (exp -> term .)
    AND             reduce using rule 73 (exp -> term .)
    OR              reduce using rule 73 (exp -> term .)
    SEMICOLON       reduce using rule 73 (exp -> term .)
    COMMA           reduce using rule 73 (exp -> term .)
    CLOSE_PAREN     reduce using rule 73 (exp -> term .)
    OPEN_PAREN      reduce using rule 73 (exp -> term .)
    CT_INT          reduce using rule 73 (exp -> term .)
    CT_FLOAT        reduce using rule 73 (exp -> term .)
    CT_CHAR         reduce using rule 73 (exp -> term .)
    ID              reduce using rule 73 (exp -> term .)
    CLOSE_BRACKETS  reduce using rule 73 (exp -> term .)
    TO              reduce using rule 73 (exp -> term .)
    DO              reduce using rule 73 (exp -> term .)
    PLUS            shift and go to state 140
    MINUS           shift and go to state 141

    exp_comp                       shift and go to state 139

state 102

    (77) term -> factor .
    (78) term -> factor . term_comp
    (79) term_comp -> . MULTIPLIES term
    (80) term_comp -> . DIVIDE term

    PLUS            reduce using rule 77 (term -> factor .)
    MINUS           reduce using rule 77 (term -> factor .)
    LESS_THAN       reduce using rule 77 (term -> factor .)
    LESS_THAN_EQUAL reduce using rule 77 (term -> factor .)
    MORE_THAN       reduce using rule 77 (term -> factor .)
    MORE_THAN_EQUAL reduce using rule 77 (term -> factor .)
    EQUALS          reduce using rule 77 (term -> factor .)
    NOT_EQUALS      reduce using rule 77 (term -> factor .)
    AND             reduce using rule 77 (term -> factor .)
    OR              reduce using rule 77 (term -> factor .)
    SEMICOLON       reduce using rule 77 (term -> factor .)
    COMMA           reduce using rule 77 (term -> factor .)
    CLOSE_PAREN     reduce using rule 77 (term -> factor .)
    OPEN_PAREN      reduce using rule 77 (term -> factor .)
    CT_INT          reduce using rule 77 (term -> factor .)
    CT_FLOAT        reduce using rule 77 (term -> factor .)
    CT_CHAR         reduce using rule 77 (term -> factor .)
    ID              reduce using rule 77 (term -> factor .)
    CLOSE_BRACKETS  reduce using rule 77 (term -> factor .)
    TO              reduce using rule 77 (term -> factor .)
    DO              reduce using rule 77 (term -> factor .)
    MULTIPLIES      shift and go to state 143
    DIVIDE          shift and go to state 144

    term_comp                      shift and go to state 142

state 103

    (81) factor -> OPEN_PAREN . expressions CLOSE_PAREN
    (60) expressions -> . expressions_comp
    (61) expressions_comp -> . expression_comp_2
    (62) expressions_comp -> . expression_comp_2 OR expressions_comp
    (63) expression_comp_2 -> . expression_comp_3
    (64) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (65) expression_comp_3 -> . exp
    (66) expression_comp_3 -> . exp expressions_op exp
    (73) exp -> . term
    (74) exp -> . term exp_comp
    (77) term -> . factor
    (78) term -> . factor term_comp
    (81) factor -> . OPEN_PAREN expressions CLOSE_PAREN
    (82) factor -> . variable
    (83) factor -> . func_call
    (84) factor -> . CT_INT
    (85) factor -> . CT_FLOAT
    (86) factor -> . CT_CHAR
    (87) variable -> . ID
    (88) variable -> . ID dim
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 103
    CT_INT          shift and go to state 106
    CT_FLOAT        shift and go to state 107
    CT_CHAR         shift and go to state 108
    ID              shift and go to state 109

    expressions                    shift and go to state 145
    expressions_comp               shift and go to state 97
    expression_comp_2              shift and go to state 98
    expression_comp_3              shift and go to state 99
    exp                            shift and go to state 100
    term                           shift and go to state 101
    factor                         shift and go to state 102
    variable                       shift and go to state 104
    func_call                      shift and go to state 105

state 104

    (82) factor -> variable .

    MULTIPLIES      reduce using rule 82 (factor -> variable .)
    DIVIDE          reduce using rule 82 (factor -> variable .)
    PLUS            reduce using rule 82 (factor -> variable .)
    MINUS           reduce using rule 82 (factor -> variable .)
    LESS_THAN       reduce using rule 82 (factor -> variable .)
    LESS_THAN_EQUAL reduce using rule 82 (factor -> variable .)
    MORE_THAN       reduce using rule 82 (factor -> variable .)
    MORE_THAN_EQUAL reduce using rule 82 (factor -> variable .)
    EQUALS          reduce using rule 82 (factor -> variable .)
    NOT_EQUALS      reduce using rule 82 (factor -> variable .)
    AND             reduce using rule 82 (factor -> variable .)
    OR              reduce using rule 82 (factor -> variable .)
    SEMICOLON       reduce using rule 82 (factor -> variable .)
    COMMA           reduce using rule 82 (factor -> variable .)
    CLOSE_PAREN     reduce using rule 82 (factor -> variable .)
    OPEN_PAREN      reduce using rule 82 (factor -> variable .)
    CT_INT          reduce using rule 82 (factor -> variable .)
    CT_FLOAT        reduce using rule 82 (factor -> variable .)
    CT_CHAR         reduce using rule 82 (factor -> variable .)
    ID              reduce using rule 82 (factor -> variable .)
    CLOSE_BRACKETS  reduce using rule 82 (factor -> variable .)
    TO              reduce using rule 82 (factor -> variable .)
    DO              reduce using rule 82 (factor -> variable .)


state 105

    (83) factor -> func_call .

    MULTIPLIES      reduce using rule 83 (factor -> func_call .)
    DIVIDE          reduce using rule 83 (factor -> func_call .)
    PLUS            reduce using rule 83 (factor -> func_call .)
    MINUS           reduce using rule 83 (factor -> func_call .)
    LESS_THAN       reduce using rule 83 (factor -> func_call .)
    LESS_THAN_EQUAL reduce using rule 83 (factor -> func_call .)
    MORE_THAN       reduce using rule 83 (factor -> func_call .)
    MORE_THAN_EQUAL reduce using rule 83 (factor -> func_call .)
    EQUALS          reduce using rule 83 (factor -> func_call .)
    NOT_EQUALS      reduce using rule 83 (factor -> func_call .)
    AND             reduce using rule 83 (factor -> func_call .)
    OR              reduce using rule 83 (factor -> func_call .)
    SEMICOLON       reduce using rule 83 (factor -> func_call .)
    COMMA           reduce using rule 83 (factor -> func_call .)
    CLOSE_PAREN     reduce using rule 83 (factor -> func_call .)
    OPEN_PAREN      reduce using rule 83 (factor -> func_call .)
    CT_INT          reduce using rule 83 (factor -> func_call .)
    CT_FLOAT        reduce using rule 83 (factor -> func_call .)
    CT_CHAR         reduce using rule 83 (factor -> func_call .)
    ID              reduce using rule 83 (factor -> func_call .)
    CLOSE_BRACKETS  reduce using rule 83 (factor -> func_call .)
    TO              reduce using rule 83 (factor -> func_call .)
    DO              reduce using rule 83 (factor -> func_call .)


state 106

    (84) factor -> CT_INT .

    MULTIPLIES      reduce using rule 84 (factor -> CT_INT .)
    DIVIDE          reduce using rule 84 (factor -> CT_INT .)
    PLUS            reduce using rule 84 (factor -> CT_INT .)
    MINUS           reduce using rule 84 (factor -> CT_INT .)
    LESS_THAN       reduce using rule 84 (factor -> CT_INT .)
    LESS_THAN_EQUAL reduce using rule 84 (factor -> CT_INT .)
    MORE_THAN       reduce using rule 84 (factor -> CT_INT .)
    MORE_THAN_EQUAL reduce using rule 84 (factor -> CT_INT .)
    EQUALS          reduce using rule 84 (factor -> CT_INT .)
    NOT_EQUALS      reduce using rule 84 (factor -> CT_INT .)
    AND             reduce using rule 84 (factor -> CT_INT .)
    OR              reduce using rule 84 (factor -> CT_INT .)
    SEMICOLON       reduce using rule 84 (factor -> CT_INT .)
    COMMA           reduce using rule 84 (factor -> CT_INT .)
    CLOSE_PAREN     reduce using rule 84 (factor -> CT_INT .)
    OPEN_PAREN      reduce using rule 84 (factor -> CT_INT .)
    CT_INT          reduce using rule 84 (factor -> CT_INT .)
    CT_FLOAT        reduce using rule 84 (factor -> CT_INT .)
    CT_CHAR         reduce using rule 84 (factor -> CT_INT .)
    ID              reduce using rule 84 (factor -> CT_INT .)
    CLOSE_BRACKETS  reduce using rule 84 (factor -> CT_INT .)
    TO              reduce using rule 84 (factor -> CT_INT .)
    DO              reduce using rule 84 (factor -> CT_INT .)


state 107

    (85) factor -> CT_FLOAT .

    MULTIPLIES      reduce using rule 85 (factor -> CT_FLOAT .)
    DIVIDE          reduce using rule 85 (factor -> CT_FLOAT .)
    PLUS            reduce using rule 85 (factor -> CT_FLOAT .)
    MINUS           reduce using rule 85 (factor -> CT_FLOAT .)
    LESS_THAN       reduce using rule 85 (factor -> CT_FLOAT .)
    LESS_THAN_EQUAL reduce using rule 85 (factor -> CT_FLOAT .)
    MORE_THAN       reduce using rule 85 (factor -> CT_FLOAT .)
    MORE_THAN_EQUAL reduce using rule 85 (factor -> CT_FLOAT .)
    EQUALS          reduce using rule 85 (factor -> CT_FLOAT .)
    NOT_EQUALS      reduce using rule 85 (factor -> CT_FLOAT .)
    AND             reduce using rule 85 (factor -> CT_FLOAT .)
    OR              reduce using rule 85 (factor -> CT_FLOAT .)
    SEMICOLON       reduce using rule 85 (factor -> CT_FLOAT .)
    COMMA           reduce using rule 85 (factor -> CT_FLOAT .)
    CLOSE_PAREN     reduce using rule 85 (factor -> CT_FLOAT .)
    OPEN_PAREN      reduce using rule 85 (factor -> CT_FLOAT .)
    CT_INT          reduce using rule 85 (factor -> CT_FLOAT .)
    CT_FLOAT        reduce using rule 85 (factor -> CT_FLOAT .)
    CT_CHAR         reduce using rule 85 (factor -> CT_FLOAT .)
    ID              reduce using rule 85 (factor -> CT_FLOAT .)
    CLOSE_BRACKETS  reduce using rule 85 (factor -> CT_FLOAT .)
    TO              reduce using rule 85 (factor -> CT_FLOAT .)
    DO              reduce using rule 85 (factor -> CT_FLOAT .)


state 108

    (86) factor -> CT_CHAR .

    MULTIPLIES      reduce using rule 86 (factor -> CT_CHAR .)
    DIVIDE          reduce using rule 86 (factor -> CT_CHAR .)
    PLUS            reduce using rule 86 (factor -> CT_CHAR .)
    MINUS           reduce using rule 86 (factor -> CT_CHAR .)
    LESS_THAN       reduce using rule 86 (factor -> CT_CHAR .)
    LESS_THAN_EQUAL reduce using rule 86 (factor -> CT_CHAR .)
    MORE_THAN       reduce using rule 86 (factor -> CT_CHAR .)
    MORE_THAN_EQUAL reduce using rule 86 (factor -> CT_CHAR .)
    EQUALS          reduce using rule 86 (factor -> CT_CHAR .)
    NOT_EQUALS      reduce using rule 86 (factor -> CT_CHAR .)
    AND             reduce using rule 86 (factor -> CT_CHAR .)
    OR              reduce using rule 86 (factor -> CT_CHAR .)
    SEMICOLON       reduce using rule 86 (factor -> CT_CHAR .)
    COMMA           reduce using rule 86 (factor -> CT_CHAR .)
    CLOSE_PAREN     reduce using rule 86 (factor -> CT_CHAR .)
    OPEN_PAREN      reduce using rule 86 (factor -> CT_CHAR .)
    CT_INT          reduce using rule 86 (factor -> CT_CHAR .)
    CT_FLOAT        reduce using rule 86 (factor -> CT_CHAR .)
    CT_CHAR         reduce using rule 86 (factor -> CT_CHAR .)
    ID              reduce using rule 86 (factor -> CT_CHAR .)
    CLOSE_BRACKETS  reduce using rule 86 (factor -> CT_CHAR .)
    TO              reduce using rule 86 (factor -> CT_CHAR .)
    DO              reduce using rule 86 (factor -> CT_CHAR .)


state 109

    (87) variable -> ID .
    (88) variable -> ID . dim
    (56) func_call -> ID . OPEN_PAREN func_call_comp CLOSE_PAREN
    (89) dim -> . OPEN_BRACKETS exp CLOSE_BRACKETS

  ! shift/reduce conflict for OPEN_PAREN resolved as shift
    MULTIPLIES      reduce using rule 87 (variable -> ID .)
    DIVIDE          reduce using rule 87 (variable -> ID .)
    PLUS            reduce using rule 87 (variable -> ID .)
    MINUS           reduce using rule 87 (variable -> ID .)
    LESS_THAN       reduce using rule 87 (variable -> ID .)
    LESS_THAN_EQUAL reduce using rule 87 (variable -> ID .)
    MORE_THAN       reduce using rule 87 (variable -> ID .)
    MORE_THAN_EQUAL reduce using rule 87 (variable -> ID .)
    EQUALS          reduce using rule 87 (variable -> ID .)
    NOT_EQUALS      reduce using rule 87 (variable -> ID .)
    AND             reduce using rule 87 (variable -> ID .)
    OR              reduce using rule 87 (variable -> ID .)
    SEMICOLON       reduce using rule 87 (variable -> ID .)
    COMMA           reduce using rule 87 (variable -> ID .)
    CLOSE_PAREN     reduce using rule 87 (variable -> ID .)
    CT_INT          reduce using rule 87 (variable -> ID .)
    CT_FLOAT        reduce using rule 87 (variable -> ID .)
    CT_CHAR         reduce using rule 87 (variable -> ID .)
    ID              reduce using rule 87 (variable -> ID .)
    CLOSE_BRACKETS  reduce using rule 87 (variable -> ID .)
    TO              reduce using rule 87 (variable -> ID .)
    DO              reduce using rule 87 (variable -> ID .)
    OPEN_PAREN      shift and go to state 80
    OPEN_BRACKETS   shift and go to state 87

  ! OPEN_PAREN      [ reduce using rule 87 (variable -> ID .) ]

    dim                            shift and go to state 86

state 110

    (43) read -> READ OPEN_PAREN ids . read_comp CLOSE_PAREN
    (44) read_comp -> . COMMA ids read_comp
    (45) read_comp -> . empty
    (90) empty -> .

    COMMA           shift and go to state 147
    CLOSE_PAREN     reduce using rule 90 (empty -> .)

    read_comp                      shift and go to state 146
    empty                          shift and go to state 148

state 111

    (32) ids -> ID . OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (33) ids -> ID . OPEN_BRACKETS exp CLOSE_BRACKETS
    (34) ids -> ID .

    OPEN_BRACKETS   shift and go to state 81
    COMMA           reduce using rule 34 (ids -> ID .)
    CLOSE_PAREN     reduce using rule 34 (ids -> ID .)


state 112

    (46) write -> WRITE OPEN_PAREN CT_STRING . write_comp CLOSE_PAREN
    (48) write_comp -> . COMMA CT_STRING write_comp
    (49) write_comp -> . COMMA expressions write_comp
    (50) write_comp -> . empty
    (90) empty -> .

    COMMA           shift and go to state 150
    CLOSE_PAREN     reduce using rule 90 (empty -> .)

    write_comp                     shift and go to state 149
    empty                          shift and go to state 151

state 113

    (47) write -> WRITE OPEN_PAREN expressions . write_comp CLOSE_PAREN
    (48) write_comp -> . COMMA CT_STRING write_comp
    (49) write_comp -> . COMMA expressions write_comp
    (50) write_comp -> . empty
    (90) empty -> .

    COMMA           shift and go to state 150
    CLOSE_PAREN     reduce using rule 90 (empty -> .)

    write_comp                     shift and go to state 152
    empty                          shift and go to state 151

state 114

    (51) condition -> IF OPEN_PAREN expressions . CLOSE_PAREN THEN block ELSE block
    (52) condition -> IF OPEN_PAREN expressions . CLOSE_PAREN THEN block

    CLOSE_PAREN     shift and go to state 153


state 115

    (53) condition -> WHILE OPEN_PAREN expressions . CLOSE_PAREN DO block

    CLOSE_PAREN     shift and go to state 154


state 116

    (54) condition -> FOR ids_dec ASSIGN . expressions TO expressions DO block
    (60) expressions -> . expressions_comp
    (61) expressions_comp -> . expression_comp_2
    (62) expressions_comp -> . expression_comp_2 OR expressions_comp
    (63) expression_comp_2 -> . expression_comp_3
    (64) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (65) expression_comp_3 -> . exp
    (66) expression_comp_3 -> . exp expressions_op exp
    (73) exp -> . term
    (74) exp -> . term exp_comp
    (77) term -> . factor
    (78) term -> . factor term_comp
    (81) factor -> . OPEN_PAREN expressions CLOSE_PAREN
    (82) factor -> . variable
    (83) factor -> . func_call
    (84) factor -> . CT_INT
    (85) factor -> . CT_FLOAT
    (86) factor -> . CT_CHAR
    (87) variable -> . ID
    (88) variable -> . ID dim
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 103
    CT_INT          shift and go to state 106
    CT_FLOAT        shift and go to state 107
    CT_CHAR         shift and go to state 108
    ID              shift and go to state 109

    expressions                    shift and go to state 155
    expressions_comp               shift and go to state 97
    expression_comp_2              shift and go to state 98
    expression_comp_3              shift and go to state 99
    exp                            shift and go to state 100
    term                           shift and go to state 101
    factor                         shift and go to state 102
    variable                       shift and go to state 104
    func_call                      shift and go to state 105

state 117

    (55) return -> RETURN OPEN_PAREN exp . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 156


state 118

    (56) func_call -> ID OPEN_PAREN func_call_comp . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 157


state 119

    (57) func_call_comp -> expressions . func_call_comp
    (57) func_call_comp -> . expressions func_call_comp
    (58) func_call_comp -> . COMMA expressions func_call_comp
    (59) func_call_comp -> . empty
    (60) expressions -> . expressions_comp
    (90) empty -> .
    (61) expressions_comp -> . expression_comp_2
    (62) expressions_comp -> . expression_comp_2 OR expressions_comp
    (63) expression_comp_2 -> . expression_comp_3
    (64) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (65) expression_comp_3 -> . exp
    (66) expression_comp_3 -> . exp expressions_op exp
    (73) exp -> . term
    (74) exp -> . term exp_comp
    (77) term -> . factor
    (78) term -> . factor term_comp
    (81) factor -> . OPEN_PAREN expressions CLOSE_PAREN
    (82) factor -> . variable
    (83) factor -> . func_call
    (84) factor -> . CT_INT
    (85) factor -> . CT_FLOAT
    (86) factor -> . CT_CHAR
    (87) variable -> . ID
    (88) variable -> . ID dim
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    COMMA           shift and go to state 120
    CLOSE_PAREN     reduce using rule 90 (empty -> .)
    OPEN_PAREN      shift and go to state 103
    CT_INT          shift and go to state 106
    CT_FLOAT        shift and go to state 107
    CT_CHAR         shift and go to state 108
    ID              shift and go to state 109

    expressions                    shift and go to state 119
    func_call_comp                 shift and go to state 158
    empty                          shift and go to state 121
    expressions_comp               shift and go to state 97
    expression_comp_2              shift and go to state 98
    expression_comp_3              shift and go to state 99
    exp                            shift and go to state 100
    term                           shift and go to state 101
    factor                         shift and go to state 102
    variable                       shift and go to state 104
    func_call                      shift and go to state 105

state 120

    (58) func_call_comp -> COMMA . expressions func_call_comp
    (60) expressions -> . expressions_comp
    (61) expressions_comp -> . expression_comp_2
    (62) expressions_comp -> . expression_comp_2 OR expressions_comp
    (63) expression_comp_2 -> . expression_comp_3
    (64) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (65) expression_comp_3 -> . exp
    (66) expression_comp_3 -> . exp expressions_op exp
    (73) exp -> . term
    (74) exp -> . term exp_comp
    (77) term -> . factor
    (78) term -> . factor term_comp
    (81) factor -> . OPEN_PAREN expressions CLOSE_PAREN
    (82) factor -> . variable
    (83) factor -> . func_call
    (84) factor -> . CT_INT
    (85) factor -> . CT_FLOAT
    (86) factor -> . CT_CHAR
    (87) variable -> . ID
    (88) variable -> . ID dim
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 103
    CT_INT          shift and go to state 106
    CT_FLOAT        shift and go to state 107
    CT_CHAR         shift and go to state 108
    ID              shift and go to state 109

    expressions                    shift and go to state 159
    expressions_comp               shift and go to state 97
    expression_comp_2              shift and go to state 98
    expression_comp_3              shift and go to state 99
    exp                            shift and go to state 100
    term                           shift and go to state 101
    factor                         shift and go to state 102
    variable                       shift and go to state 104
    func_call                      shift and go to state 105

state 121

    (59) func_call_comp -> empty .

    CLOSE_PAREN     reduce using rule 59 (func_call_comp -> empty .)


state 122

    (32) ids -> ID OPEN_BRACKETS exp . CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (33) ids -> ID OPEN_BRACKETS exp . CLOSE_BRACKETS

    CLOSE_BRACKETS  shift and go to state 160


state 123

    (3) funcs -> func_type MODULE ID OPEN_PAREN funcs_params CLOSE_PAREN vars block .

    MAIN            reduce using rule 3 (funcs -> func_type MODULE ID OPEN_PAREN funcs_params CLOSE_PAREN vars block .)


state 124

    (8) funcs_params_comp -> COMMA var_type . ID funcs_params_comp

    ID              shift and go to state 161


state 125

    (89) dim -> OPEN_BRACKETS exp . CLOSE_BRACKETS

    CLOSE_BRACKETS  shift and go to state 162


state 126

    (28) var_module_trans -> SEMICOLON var_type MODULE funcs_comp .

    VOID            reduce using rule 28 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)
    INT             reduce using rule 28 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)
    FLOAT           reduce using rule 28 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)
    CHAR            reduce using rule 28 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)
    MAIN            reduce using rule 28 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)
    OPEN_BRACES     reduce using rule 28 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)


state 127

    (5) funcs_comp -> ID . OPEN_PAREN funcs_params CLOSE_PAREN vars block

    OPEN_PAREN      shift and go to state 163


state 128

    (24) var_comp_recursive -> var_type ids_dec var_comp_2 . var_comp_final
    (25) var_comp_recursive -> var_type ids_dec var_comp_2 . SEMICOLON var_comp_recursive
    (26) var_comp_final -> . SEMICOLON
    (27) var_comp_final -> . var_module_trans
    (28) var_module_trans -> . SEMICOLON var_type MODULE funcs_comp

    SEMICOLON       shift and go to state 165

    var_comp_final                 shift and go to state 164
    var_module_trans               shift and go to state 39

state 129

    (29) ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT . CLOSE_BRACKETS

    CLOSE_BRACKETS  shift and go to state 166


state 130

    (62) expressions_comp -> expression_comp_2 OR . expressions_comp
    (61) expressions_comp -> . expression_comp_2
    (62) expressions_comp -> . expression_comp_2 OR expressions_comp
    (63) expression_comp_2 -> . expression_comp_3
    (64) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (65) expression_comp_3 -> . exp
    (66) expression_comp_3 -> . exp expressions_op exp
    (73) exp -> . term
    (74) exp -> . term exp_comp
    (77) term -> . factor
    (78) term -> . factor term_comp
    (81) factor -> . OPEN_PAREN expressions CLOSE_PAREN
    (82) factor -> . variable
    (83) factor -> . func_call
    (84) factor -> . CT_INT
    (85) factor -> . CT_FLOAT
    (86) factor -> . CT_CHAR
    (87) variable -> . ID
    (88) variable -> . ID dim
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 103
    CT_INT          shift and go to state 106
    CT_FLOAT        shift and go to state 107
    CT_CHAR         shift and go to state 108
    ID              shift and go to state 109

    expression_comp_2              shift and go to state 98
    expressions_comp               shift and go to state 167
    expression_comp_3              shift and go to state 99
    exp                            shift and go to state 100
    term                           shift and go to state 101
    factor                         shift and go to state 102
    variable                       shift and go to state 104
    func_call                      shift and go to state 105

state 131

    (64) expression_comp_2 -> expression_comp_3 AND . expression_comp_2
    (63) expression_comp_2 -> . expression_comp_3
    (64) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (65) expression_comp_3 -> . exp
    (66) expression_comp_3 -> . exp expressions_op exp
    (73) exp -> . term
    (74) exp -> . term exp_comp
    (77) term -> . factor
    (78) term -> . factor term_comp
    (81) factor -> . OPEN_PAREN expressions CLOSE_PAREN
    (82) factor -> . variable
    (83) factor -> . func_call
    (84) factor -> . CT_INT
    (85) factor -> . CT_FLOAT
    (86) factor -> . CT_CHAR
    (87) variable -> . ID
    (88) variable -> . ID dim
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 103
    CT_INT          shift and go to state 106
    CT_FLOAT        shift and go to state 107
    CT_CHAR         shift and go to state 108
    ID              shift and go to state 109

    expression_comp_3              shift and go to state 99
    expression_comp_2              shift and go to state 168
    exp                            shift and go to state 100
    term                           shift and go to state 101
    factor                         shift and go to state 102
    variable                       shift and go to state 104
    func_call                      shift and go to state 105

state 132

    (66) expression_comp_3 -> exp expressions_op . exp
    (73) exp -> . term
    (74) exp -> . term exp_comp
    (77) term -> . factor
    (78) term -> . factor term_comp
    (81) factor -> . OPEN_PAREN expressions CLOSE_PAREN
    (82) factor -> . variable
    (83) factor -> . func_call
    (84) factor -> . CT_INT
    (85) factor -> . CT_FLOAT
    (86) factor -> . CT_CHAR
    (87) variable -> . ID
    (88) variable -> . ID dim
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 103
    CT_INT          shift and go to state 106
    CT_FLOAT        shift and go to state 107
    CT_CHAR         shift and go to state 108
    ID              shift and go to state 109

    exp                            shift and go to state 169
    term                           shift and go to state 101
    factor                         shift and go to state 102
    variable                       shift and go to state 104
    func_call                      shift and go to state 105

state 133

    (67) expressions_op -> LESS_THAN .

    OPEN_PAREN      reduce using rule 67 (expressions_op -> LESS_THAN .)
    CT_INT          reduce using rule 67 (expressions_op -> LESS_THAN .)
    CT_FLOAT        reduce using rule 67 (expressions_op -> LESS_THAN .)
    CT_CHAR         reduce using rule 67 (expressions_op -> LESS_THAN .)
    ID              reduce using rule 67 (expressions_op -> LESS_THAN .)


state 134

    (68) expressions_op -> LESS_THAN_EQUAL .

    OPEN_PAREN      reduce using rule 68 (expressions_op -> LESS_THAN_EQUAL .)
    CT_INT          reduce using rule 68 (expressions_op -> LESS_THAN_EQUAL .)
    CT_FLOAT        reduce using rule 68 (expressions_op -> LESS_THAN_EQUAL .)
    CT_CHAR         reduce using rule 68 (expressions_op -> LESS_THAN_EQUAL .)
    ID              reduce using rule 68 (expressions_op -> LESS_THAN_EQUAL .)


state 135

    (69) expressions_op -> MORE_THAN .

    OPEN_PAREN      reduce using rule 69 (expressions_op -> MORE_THAN .)
    CT_INT          reduce using rule 69 (expressions_op -> MORE_THAN .)
    CT_FLOAT        reduce using rule 69 (expressions_op -> MORE_THAN .)
    CT_CHAR         reduce using rule 69 (expressions_op -> MORE_THAN .)
    ID              reduce using rule 69 (expressions_op -> MORE_THAN .)


state 136

    (70) expressions_op -> MORE_THAN_EQUAL .

    OPEN_PAREN      reduce using rule 70 (expressions_op -> MORE_THAN_EQUAL .)
    CT_INT          reduce using rule 70 (expressions_op -> MORE_THAN_EQUAL .)
    CT_FLOAT        reduce using rule 70 (expressions_op -> MORE_THAN_EQUAL .)
    CT_CHAR         reduce using rule 70 (expressions_op -> MORE_THAN_EQUAL .)
    ID              reduce using rule 70 (expressions_op -> MORE_THAN_EQUAL .)


state 137

    (71) expressions_op -> EQUALS .

    OPEN_PAREN      reduce using rule 71 (expressions_op -> EQUALS .)
    CT_INT          reduce using rule 71 (expressions_op -> EQUALS .)
    CT_FLOAT        reduce using rule 71 (expressions_op -> EQUALS .)
    CT_CHAR         reduce using rule 71 (expressions_op -> EQUALS .)
    ID              reduce using rule 71 (expressions_op -> EQUALS .)


state 138

    (72) expressions_op -> NOT_EQUALS .

    OPEN_PAREN      reduce using rule 72 (expressions_op -> NOT_EQUALS .)
    CT_INT          reduce using rule 72 (expressions_op -> NOT_EQUALS .)
    CT_FLOAT        reduce using rule 72 (expressions_op -> NOT_EQUALS .)
    CT_CHAR         reduce using rule 72 (expressions_op -> NOT_EQUALS .)
    ID              reduce using rule 72 (expressions_op -> NOT_EQUALS .)


state 139

    (74) exp -> term exp_comp .

    LESS_THAN       reduce using rule 74 (exp -> term exp_comp .)
    LESS_THAN_EQUAL reduce using rule 74 (exp -> term exp_comp .)
    MORE_THAN       reduce using rule 74 (exp -> term exp_comp .)
    MORE_THAN_EQUAL reduce using rule 74 (exp -> term exp_comp .)
    EQUALS          reduce using rule 74 (exp -> term exp_comp .)
    NOT_EQUALS      reduce using rule 74 (exp -> term exp_comp .)
    AND             reduce using rule 74 (exp -> term exp_comp .)
    OR              reduce using rule 74 (exp -> term exp_comp .)
    SEMICOLON       reduce using rule 74 (exp -> term exp_comp .)
    COMMA           reduce using rule 74 (exp -> term exp_comp .)
    CLOSE_PAREN     reduce using rule 74 (exp -> term exp_comp .)
    OPEN_PAREN      reduce using rule 74 (exp -> term exp_comp .)
    CT_INT          reduce using rule 74 (exp -> term exp_comp .)
    CT_FLOAT        reduce using rule 74 (exp -> term exp_comp .)
    CT_CHAR         reduce using rule 74 (exp -> term exp_comp .)
    ID              reduce using rule 74 (exp -> term exp_comp .)
    CLOSE_BRACKETS  reduce using rule 74 (exp -> term exp_comp .)
    TO              reduce using rule 74 (exp -> term exp_comp .)
    DO              reduce using rule 74 (exp -> term exp_comp .)


state 140

    (75) exp_comp -> PLUS . exp
    (73) exp -> . term
    (74) exp -> . term exp_comp
    (77) term -> . factor
    (78) term -> . factor term_comp
    (81) factor -> . OPEN_PAREN expressions CLOSE_PAREN
    (82) factor -> . variable
    (83) factor -> . func_call
    (84) factor -> . CT_INT
    (85) factor -> . CT_FLOAT
    (86) factor -> . CT_CHAR
    (87) variable -> . ID
    (88) variable -> . ID dim
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 103
    CT_INT          shift and go to state 106
    CT_FLOAT        shift and go to state 107
    CT_CHAR         shift and go to state 108
    ID              shift and go to state 109

    exp                            shift and go to state 170
    term                           shift and go to state 101
    factor                         shift and go to state 102
    variable                       shift and go to state 104
    func_call                      shift and go to state 105

state 141

    (76) exp_comp -> MINUS . exp
    (73) exp -> . term
    (74) exp -> . term exp_comp
    (77) term -> . factor
    (78) term -> . factor term_comp
    (81) factor -> . OPEN_PAREN expressions CLOSE_PAREN
    (82) factor -> . variable
    (83) factor -> . func_call
    (84) factor -> . CT_INT
    (85) factor -> . CT_FLOAT
    (86) factor -> . CT_CHAR
    (87) variable -> . ID
    (88) variable -> . ID dim
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 103
    CT_INT          shift and go to state 106
    CT_FLOAT        shift and go to state 107
    CT_CHAR         shift and go to state 108
    ID              shift and go to state 109

    exp                            shift and go to state 171
    term                           shift and go to state 101
    factor                         shift and go to state 102
    variable                       shift and go to state 104
    func_call                      shift and go to state 105

state 142

    (78) term -> factor term_comp .

    PLUS            reduce using rule 78 (term -> factor term_comp .)
    MINUS           reduce using rule 78 (term -> factor term_comp .)
    LESS_THAN       reduce using rule 78 (term -> factor term_comp .)
    LESS_THAN_EQUAL reduce using rule 78 (term -> factor term_comp .)
    MORE_THAN       reduce using rule 78 (term -> factor term_comp .)
    MORE_THAN_EQUAL reduce using rule 78 (term -> factor term_comp .)
    EQUALS          reduce using rule 78 (term -> factor term_comp .)
    NOT_EQUALS      reduce using rule 78 (term -> factor term_comp .)
    AND             reduce using rule 78 (term -> factor term_comp .)
    OR              reduce using rule 78 (term -> factor term_comp .)
    SEMICOLON       reduce using rule 78 (term -> factor term_comp .)
    COMMA           reduce using rule 78 (term -> factor term_comp .)
    CLOSE_PAREN     reduce using rule 78 (term -> factor term_comp .)
    OPEN_PAREN      reduce using rule 78 (term -> factor term_comp .)
    CT_INT          reduce using rule 78 (term -> factor term_comp .)
    CT_FLOAT        reduce using rule 78 (term -> factor term_comp .)
    CT_CHAR         reduce using rule 78 (term -> factor term_comp .)
    ID              reduce using rule 78 (term -> factor term_comp .)
    CLOSE_BRACKETS  reduce using rule 78 (term -> factor term_comp .)
    TO              reduce using rule 78 (term -> factor term_comp .)
    DO              reduce using rule 78 (term -> factor term_comp .)


state 143

    (79) term_comp -> MULTIPLIES . term
    (77) term -> . factor
    (78) term -> . factor term_comp
    (81) factor -> . OPEN_PAREN expressions CLOSE_PAREN
    (82) factor -> . variable
    (83) factor -> . func_call
    (84) factor -> . CT_INT
    (85) factor -> . CT_FLOAT
    (86) factor -> . CT_CHAR
    (87) variable -> . ID
    (88) variable -> . ID dim
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 103
    CT_INT          shift and go to state 106
    CT_FLOAT        shift and go to state 107
    CT_CHAR         shift and go to state 108
    ID              shift and go to state 109

    term                           shift and go to state 172
    factor                         shift and go to state 102
    variable                       shift and go to state 104
    func_call                      shift and go to state 105

state 144

    (80) term_comp -> DIVIDE . term
    (77) term -> . factor
    (78) term -> . factor term_comp
    (81) factor -> . OPEN_PAREN expressions CLOSE_PAREN
    (82) factor -> . variable
    (83) factor -> . func_call
    (84) factor -> . CT_INT
    (85) factor -> . CT_FLOAT
    (86) factor -> . CT_CHAR
    (87) variable -> . ID
    (88) variable -> . ID dim
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 103
    CT_INT          shift and go to state 106
    CT_FLOAT        shift and go to state 107
    CT_CHAR         shift and go to state 108
    ID              shift and go to state 109

    term                           shift and go to state 173
    factor                         shift and go to state 102
    variable                       shift and go to state 104
    func_call                      shift and go to state 105

state 145

    (81) factor -> OPEN_PAREN expressions . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 174


state 146

    (43) read -> READ OPEN_PAREN ids read_comp . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 175


state 147

    (44) read_comp -> COMMA . ids read_comp
    (32) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (33) ids -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (34) ids -> . ID

    ID              shift and go to state 111

    ids                            shift and go to state 176

state 148

    (45) read_comp -> empty .

    CLOSE_PAREN     reduce using rule 45 (read_comp -> empty .)


state 149

    (46) write -> WRITE OPEN_PAREN CT_STRING write_comp . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 177


state 150

    (48) write_comp -> COMMA . CT_STRING write_comp
    (49) write_comp -> COMMA . expressions write_comp
    (60) expressions -> . expressions_comp
    (61) expressions_comp -> . expression_comp_2
    (62) expressions_comp -> . expression_comp_2 OR expressions_comp
    (63) expression_comp_2 -> . expression_comp_3
    (64) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (65) expression_comp_3 -> . exp
    (66) expression_comp_3 -> . exp expressions_op exp
    (73) exp -> . term
    (74) exp -> . term exp_comp
    (77) term -> . factor
    (78) term -> . factor term_comp
    (81) factor -> . OPEN_PAREN expressions CLOSE_PAREN
    (82) factor -> . variable
    (83) factor -> . func_call
    (84) factor -> . CT_INT
    (85) factor -> . CT_FLOAT
    (86) factor -> . CT_CHAR
    (87) variable -> . ID
    (88) variable -> . ID dim
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    CT_STRING       shift and go to state 178
    OPEN_PAREN      shift and go to state 103
    CT_INT          shift and go to state 106
    CT_FLOAT        shift and go to state 107
    CT_CHAR         shift and go to state 108
    ID              shift and go to state 109

    expressions                    shift and go to state 179
    expressions_comp               shift and go to state 97
    expression_comp_2              shift and go to state 98
    expression_comp_3              shift and go to state 99
    exp                            shift and go to state 100
    term                           shift and go to state 101
    factor                         shift and go to state 102
    variable                       shift and go to state 104
    func_call                      shift and go to state 105

state 151

    (50) write_comp -> empty .

    CLOSE_PAREN     reduce using rule 50 (write_comp -> empty .)


state 152

    (47) write -> WRITE OPEN_PAREN expressions write_comp . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 180


state 153

    (51) condition -> IF OPEN_PAREN expressions CLOSE_PAREN . THEN block ELSE block
    (52) condition -> IF OPEN_PAREN expressions CLOSE_PAREN . THEN block

    THEN            shift and go to state 181


state 154

    (53) condition -> WHILE OPEN_PAREN expressions CLOSE_PAREN . DO block

    DO              shift and go to state 182


state 155

    (54) condition -> FOR ids_dec ASSIGN expressions . TO expressions DO block

    TO              shift and go to state 183


state 156

    (55) return -> RETURN OPEN_PAREN exp CLOSE_PAREN .

    SEMICOLON       reduce using rule 55 (return -> RETURN OPEN_PAREN exp CLOSE_PAREN .)


state 157

    (56) func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .

    SEMICOLON       reduce using rule 56 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    MULTIPLIES      reduce using rule 56 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    DIVIDE          reduce using rule 56 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    PLUS            reduce using rule 56 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    MINUS           reduce using rule 56 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    LESS_THAN       reduce using rule 56 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    LESS_THAN_EQUAL reduce using rule 56 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    MORE_THAN       reduce using rule 56 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    MORE_THAN_EQUAL reduce using rule 56 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    EQUALS          reduce using rule 56 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    NOT_EQUALS      reduce using rule 56 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    AND             reduce using rule 56 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    OR              reduce using rule 56 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    COMMA           reduce using rule 56 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    CLOSE_PAREN     reduce using rule 56 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    OPEN_PAREN      reduce using rule 56 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    CT_INT          reduce using rule 56 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    CT_FLOAT        reduce using rule 56 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    CT_CHAR         reduce using rule 56 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    ID              reduce using rule 56 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    CLOSE_BRACKETS  reduce using rule 56 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    TO              reduce using rule 56 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)
    DO              reduce using rule 56 (func_call -> ID OPEN_PAREN func_call_comp CLOSE_PAREN .)


state 158

    (57) func_call_comp -> expressions func_call_comp .

    CLOSE_PAREN     reduce using rule 57 (func_call_comp -> expressions func_call_comp .)


state 159

    (58) func_call_comp -> COMMA expressions . func_call_comp
    (57) func_call_comp -> . expressions func_call_comp
    (58) func_call_comp -> . COMMA expressions func_call_comp
    (59) func_call_comp -> . empty
    (60) expressions -> . expressions_comp
    (90) empty -> .
    (61) expressions_comp -> . expression_comp_2
    (62) expressions_comp -> . expression_comp_2 OR expressions_comp
    (63) expression_comp_2 -> . expression_comp_3
    (64) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (65) expression_comp_3 -> . exp
    (66) expression_comp_3 -> . exp expressions_op exp
    (73) exp -> . term
    (74) exp -> . term exp_comp
    (77) term -> . factor
    (78) term -> . factor term_comp
    (81) factor -> . OPEN_PAREN expressions CLOSE_PAREN
    (82) factor -> . variable
    (83) factor -> . func_call
    (84) factor -> . CT_INT
    (85) factor -> . CT_FLOAT
    (86) factor -> . CT_CHAR
    (87) variable -> . ID
    (88) variable -> . ID dim
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    COMMA           shift and go to state 120
    CLOSE_PAREN     reduce using rule 90 (empty -> .)
    OPEN_PAREN      shift and go to state 103
    CT_INT          shift and go to state 106
    CT_FLOAT        shift and go to state 107
    CT_CHAR         shift and go to state 108
    ID              shift and go to state 109

    expressions                    shift and go to state 119
    func_call_comp                 shift and go to state 184
    empty                          shift and go to state 121
    expressions_comp               shift and go to state 97
    expression_comp_2              shift and go to state 98
    expression_comp_3              shift and go to state 99
    exp                            shift and go to state 100
    term                           shift and go to state 101
    factor                         shift and go to state 102
    variable                       shift and go to state 104
    func_call                      shift and go to state 105

state 160

    (32) ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS . OPEN_BRACKETS exp CLOSE_BRACKETS
    (33) ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS .

    OPEN_BRACKETS   shift and go to state 185
    ASSIGN          reduce using rule 33 (ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS .)
    COMMA           reduce using rule 33 (ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CLOSE_PAREN     reduce using rule 33 (ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS .)


state 161

    (8) funcs_params_comp -> COMMA var_type ID . funcs_params_comp
    (8) funcs_params_comp -> . COMMA var_type ID funcs_params_comp
    (9) funcs_params_comp -> . empty
    (90) empty -> .

    COMMA           shift and go to state 84
    CLOSE_PAREN     reduce using rule 90 (empty -> .)

    funcs_params_comp              shift and go to state 186
    empty                          shift and go to state 85

state 162

    (89) dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .

    COMMA           reduce using rule 89 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CLOSE_PAREN     reduce using rule 89 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    MULTIPLIES      reduce using rule 89 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    DIVIDE          reduce using rule 89 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    PLUS            reduce using rule 89 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    MINUS           reduce using rule 89 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    LESS_THAN       reduce using rule 89 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    LESS_THAN_EQUAL reduce using rule 89 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    MORE_THAN       reduce using rule 89 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    MORE_THAN_EQUAL reduce using rule 89 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    EQUALS          reduce using rule 89 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    NOT_EQUALS      reduce using rule 89 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    AND             reduce using rule 89 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    OR              reduce using rule 89 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    SEMICOLON       reduce using rule 89 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    OPEN_PAREN      reduce using rule 89 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CT_INT          reduce using rule 89 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CT_FLOAT        reduce using rule 89 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CT_CHAR         reduce using rule 89 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    ID              reduce using rule 89 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CLOSE_BRACKETS  reduce using rule 89 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    TO              reduce using rule 89 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    DO              reduce using rule 89 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)


state 163

    (5) funcs_comp -> ID OPEN_PAREN . funcs_params CLOSE_PAREN vars block
    (6) funcs_params -> . var_type variable funcs_params_comp
    (7) funcs_params -> . empty
    (13) var_type -> . INT
    (14) var_type -> . FLOAT
    (15) var_type -> . CHAR
    (90) empty -> .

    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 15
    CLOSE_PAREN     reduce using rule 90 (empty -> .)

    funcs_params                   shift and go to state 187
    var_type                       shift and go to state 35
    empty                          shift and go to state 36

state 164

    (24) var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .

    VOID            reduce using rule 24 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)
    INT             reduce using rule 24 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)
    FLOAT           reduce using rule 24 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)
    CHAR            reduce using rule 24 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)
    MAIN            reduce using rule 24 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)
    OPEN_BRACES     reduce using rule 24 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)


state 165

    (25) var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON . var_comp_recursive
    (26) var_comp_final -> SEMICOLON .
    (28) var_module_trans -> SEMICOLON . var_type MODULE funcs_comp
    (24) var_comp_recursive -> . var_type ids_dec var_comp_2 var_comp_final
    (25) var_comp_recursive -> . var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive
    (13) var_type -> . INT
    (14) var_type -> . FLOAT
    (15) var_type -> . CHAR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
    VOID            reduce using rule 26 (var_comp_final -> SEMICOLON .)
    MAIN            reduce using rule 26 (var_comp_final -> SEMICOLON .)
    OPEN_BRACES     reduce using rule 26 (var_comp_final -> SEMICOLON .)
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 15

  ! INT             [ reduce using rule 26 (var_comp_final -> SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 26 (var_comp_final -> SEMICOLON .) ]
  ! CHAR            [ reduce using rule 26 (var_comp_final -> SEMICOLON .) ]

    var_type                       shift and go to state 61
    var_comp_recursive             shift and go to state 188

state 166

    (29) ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS .

    COMMA           reduce using rule 29 (ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS .)
    SEMICOLON       reduce using rule 29 (ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS .)
    ASSIGN          reduce using rule 29 (ids_dec -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS .)


state 167

    (62) expressions_comp -> expression_comp_2 OR expressions_comp .

    SEMICOLON       reduce using rule 62 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    COMMA           reduce using rule 62 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    CLOSE_PAREN     reduce using rule 62 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    OPEN_PAREN      reduce using rule 62 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    CT_INT          reduce using rule 62 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    CT_FLOAT        reduce using rule 62 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    CT_CHAR         reduce using rule 62 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    ID              reduce using rule 62 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    TO              reduce using rule 62 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    DO              reduce using rule 62 (expressions_comp -> expression_comp_2 OR expressions_comp .)


state 168

    (64) expression_comp_2 -> expression_comp_3 AND expression_comp_2 .

    OR              reduce using rule 64 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    SEMICOLON       reduce using rule 64 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    COMMA           reduce using rule 64 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    CLOSE_PAREN     reduce using rule 64 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    OPEN_PAREN      reduce using rule 64 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    CT_INT          reduce using rule 64 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    CT_FLOAT        reduce using rule 64 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    CT_CHAR         reduce using rule 64 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    ID              reduce using rule 64 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    TO              reduce using rule 64 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    DO              reduce using rule 64 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)


state 169

    (66) expression_comp_3 -> exp expressions_op exp .

    AND             reduce using rule 66 (expression_comp_3 -> exp expressions_op exp .)
    OR              reduce using rule 66 (expression_comp_3 -> exp expressions_op exp .)
    SEMICOLON       reduce using rule 66 (expression_comp_3 -> exp expressions_op exp .)
    COMMA           reduce using rule 66 (expression_comp_3 -> exp expressions_op exp .)
    CLOSE_PAREN     reduce using rule 66 (expression_comp_3 -> exp expressions_op exp .)
    OPEN_PAREN      reduce using rule 66 (expression_comp_3 -> exp expressions_op exp .)
    CT_INT          reduce using rule 66 (expression_comp_3 -> exp expressions_op exp .)
    CT_FLOAT        reduce using rule 66 (expression_comp_3 -> exp expressions_op exp .)
    CT_CHAR         reduce using rule 66 (expression_comp_3 -> exp expressions_op exp .)
    ID              reduce using rule 66 (expression_comp_3 -> exp expressions_op exp .)
    TO              reduce using rule 66 (expression_comp_3 -> exp expressions_op exp .)
    DO              reduce using rule 66 (expression_comp_3 -> exp expressions_op exp .)


state 170

    (75) exp_comp -> PLUS exp .

    LESS_THAN       reduce using rule 75 (exp_comp -> PLUS exp .)
    LESS_THAN_EQUAL reduce using rule 75 (exp_comp -> PLUS exp .)
    MORE_THAN       reduce using rule 75 (exp_comp -> PLUS exp .)
    MORE_THAN_EQUAL reduce using rule 75 (exp_comp -> PLUS exp .)
    EQUALS          reduce using rule 75 (exp_comp -> PLUS exp .)
    NOT_EQUALS      reduce using rule 75 (exp_comp -> PLUS exp .)
    AND             reduce using rule 75 (exp_comp -> PLUS exp .)
    OR              reduce using rule 75 (exp_comp -> PLUS exp .)
    SEMICOLON       reduce using rule 75 (exp_comp -> PLUS exp .)
    COMMA           reduce using rule 75 (exp_comp -> PLUS exp .)
    CLOSE_PAREN     reduce using rule 75 (exp_comp -> PLUS exp .)
    OPEN_PAREN      reduce using rule 75 (exp_comp -> PLUS exp .)
    CT_INT          reduce using rule 75 (exp_comp -> PLUS exp .)
    CT_FLOAT        reduce using rule 75 (exp_comp -> PLUS exp .)
    CT_CHAR         reduce using rule 75 (exp_comp -> PLUS exp .)
    ID              reduce using rule 75 (exp_comp -> PLUS exp .)
    CLOSE_BRACKETS  reduce using rule 75 (exp_comp -> PLUS exp .)
    TO              reduce using rule 75 (exp_comp -> PLUS exp .)
    DO              reduce using rule 75 (exp_comp -> PLUS exp .)


state 171

    (76) exp_comp -> MINUS exp .

    LESS_THAN       reduce using rule 76 (exp_comp -> MINUS exp .)
    LESS_THAN_EQUAL reduce using rule 76 (exp_comp -> MINUS exp .)
    MORE_THAN       reduce using rule 76 (exp_comp -> MINUS exp .)
    MORE_THAN_EQUAL reduce using rule 76 (exp_comp -> MINUS exp .)
    EQUALS          reduce using rule 76 (exp_comp -> MINUS exp .)
    NOT_EQUALS      reduce using rule 76 (exp_comp -> MINUS exp .)
    AND             reduce using rule 76 (exp_comp -> MINUS exp .)
    OR              reduce using rule 76 (exp_comp -> MINUS exp .)
    SEMICOLON       reduce using rule 76 (exp_comp -> MINUS exp .)
    COMMA           reduce using rule 76 (exp_comp -> MINUS exp .)
    CLOSE_PAREN     reduce using rule 76 (exp_comp -> MINUS exp .)
    OPEN_PAREN      reduce using rule 76 (exp_comp -> MINUS exp .)
    CT_INT          reduce using rule 76 (exp_comp -> MINUS exp .)
    CT_FLOAT        reduce using rule 76 (exp_comp -> MINUS exp .)
    CT_CHAR         reduce using rule 76 (exp_comp -> MINUS exp .)
    ID              reduce using rule 76 (exp_comp -> MINUS exp .)
    CLOSE_BRACKETS  reduce using rule 76 (exp_comp -> MINUS exp .)
    TO              reduce using rule 76 (exp_comp -> MINUS exp .)
    DO              reduce using rule 76 (exp_comp -> MINUS exp .)


state 172

    (79) term_comp -> MULTIPLIES term .

    PLUS            reduce using rule 79 (term_comp -> MULTIPLIES term .)
    MINUS           reduce using rule 79 (term_comp -> MULTIPLIES term .)
    LESS_THAN       reduce using rule 79 (term_comp -> MULTIPLIES term .)
    LESS_THAN_EQUAL reduce using rule 79 (term_comp -> MULTIPLIES term .)
    MORE_THAN       reduce using rule 79 (term_comp -> MULTIPLIES term .)
    MORE_THAN_EQUAL reduce using rule 79 (term_comp -> MULTIPLIES term .)
    EQUALS          reduce using rule 79 (term_comp -> MULTIPLIES term .)
    NOT_EQUALS      reduce using rule 79 (term_comp -> MULTIPLIES term .)
    AND             reduce using rule 79 (term_comp -> MULTIPLIES term .)
    OR              reduce using rule 79 (term_comp -> MULTIPLIES term .)
    SEMICOLON       reduce using rule 79 (term_comp -> MULTIPLIES term .)
    COMMA           reduce using rule 79 (term_comp -> MULTIPLIES term .)
    CLOSE_PAREN     reduce using rule 79 (term_comp -> MULTIPLIES term .)
    OPEN_PAREN      reduce using rule 79 (term_comp -> MULTIPLIES term .)
    CT_INT          reduce using rule 79 (term_comp -> MULTIPLIES term .)
    CT_FLOAT        reduce using rule 79 (term_comp -> MULTIPLIES term .)
    CT_CHAR         reduce using rule 79 (term_comp -> MULTIPLIES term .)
    ID              reduce using rule 79 (term_comp -> MULTIPLIES term .)
    CLOSE_BRACKETS  reduce using rule 79 (term_comp -> MULTIPLIES term .)
    TO              reduce using rule 79 (term_comp -> MULTIPLIES term .)
    DO              reduce using rule 79 (term_comp -> MULTIPLIES term .)


state 173

    (80) term_comp -> DIVIDE term .

    PLUS            reduce using rule 80 (term_comp -> DIVIDE term .)
    MINUS           reduce using rule 80 (term_comp -> DIVIDE term .)
    LESS_THAN       reduce using rule 80 (term_comp -> DIVIDE term .)
    LESS_THAN_EQUAL reduce using rule 80 (term_comp -> DIVIDE term .)
    MORE_THAN       reduce using rule 80 (term_comp -> DIVIDE term .)
    MORE_THAN_EQUAL reduce using rule 80 (term_comp -> DIVIDE term .)
    EQUALS          reduce using rule 80 (term_comp -> DIVIDE term .)
    NOT_EQUALS      reduce using rule 80 (term_comp -> DIVIDE term .)
    AND             reduce using rule 80 (term_comp -> DIVIDE term .)
    OR              reduce using rule 80 (term_comp -> DIVIDE term .)
    SEMICOLON       reduce using rule 80 (term_comp -> DIVIDE term .)
    COMMA           reduce using rule 80 (term_comp -> DIVIDE term .)
    CLOSE_PAREN     reduce using rule 80 (term_comp -> DIVIDE term .)
    OPEN_PAREN      reduce using rule 80 (term_comp -> DIVIDE term .)
    CT_INT          reduce using rule 80 (term_comp -> DIVIDE term .)
    CT_FLOAT        reduce using rule 80 (term_comp -> DIVIDE term .)
    CT_CHAR         reduce using rule 80 (term_comp -> DIVIDE term .)
    ID              reduce using rule 80 (term_comp -> DIVIDE term .)
    CLOSE_BRACKETS  reduce using rule 80 (term_comp -> DIVIDE term .)
    TO              reduce using rule 80 (term_comp -> DIVIDE term .)
    DO              reduce using rule 80 (term_comp -> DIVIDE term .)


state 174

    (81) factor -> OPEN_PAREN expressions CLOSE_PAREN .

    MULTIPLIES      reduce using rule 81 (factor -> OPEN_PAREN expressions CLOSE_PAREN .)
    DIVIDE          reduce using rule 81 (factor -> OPEN_PAREN expressions CLOSE_PAREN .)
    PLUS            reduce using rule 81 (factor -> OPEN_PAREN expressions CLOSE_PAREN .)
    MINUS           reduce using rule 81 (factor -> OPEN_PAREN expressions CLOSE_PAREN .)
    LESS_THAN       reduce using rule 81 (factor -> OPEN_PAREN expressions CLOSE_PAREN .)
    LESS_THAN_EQUAL reduce using rule 81 (factor -> OPEN_PAREN expressions CLOSE_PAREN .)
    MORE_THAN       reduce using rule 81 (factor -> OPEN_PAREN expressions CLOSE_PAREN .)
    MORE_THAN_EQUAL reduce using rule 81 (factor -> OPEN_PAREN expressions CLOSE_PAREN .)
    EQUALS          reduce using rule 81 (factor -> OPEN_PAREN expressions CLOSE_PAREN .)
    NOT_EQUALS      reduce using rule 81 (factor -> OPEN_PAREN expressions CLOSE_PAREN .)
    AND             reduce using rule 81 (factor -> OPEN_PAREN expressions CLOSE_PAREN .)
    OR              reduce using rule 81 (factor -> OPEN_PAREN expressions CLOSE_PAREN .)
    SEMICOLON       reduce using rule 81 (factor -> OPEN_PAREN expressions CLOSE_PAREN .)
    COMMA           reduce using rule 81 (factor -> OPEN_PAREN expressions CLOSE_PAREN .)
    CLOSE_PAREN     reduce using rule 81 (factor -> OPEN_PAREN expressions CLOSE_PAREN .)
    OPEN_PAREN      reduce using rule 81 (factor -> OPEN_PAREN expressions CLOSE_PAREN .)
    CT_INT          reduce using rule 81 (factor -> OPEN_PAREN expressions CLOSE_PAREN .)
    CT_FLOAT        reduce using rule 81 (factor -> OPEN_PAREN expressions CLOSE_PAREN .)
    CT_CHAR         reduce using rule 81 (factor -> OPEN_PAREN expressions CLOSE_PAREN .)
    ID              reduce using rule 81 (factor -> OPEN_PAREN expressions CLOSE_PAREN .)
    CLOSE_BRACKETS  reduce using rule 81 (factor -> OPEN_PAREN expressions CLOSE_PAREN .)
    TO              reduce using rule 81 (factor -> OPEN_PAREN expressions CLOSE_PAREN .)
    DO              reduce using rule 81 (factor -> OPEN_PAREN expressions CLOSE_PAREN .)


state 175

    (43) read -> READ OPEN_PAREN ids read_comp CLOSE_PAREN .

    SEMICOLON       reduce using rule 43 (read -> READ OPEN_PAREN ids read_comp CLOSE_PAREN .)


state 176

    (44) read_comp -> COMMA ids . read_comp
    (44) read_comp -> . COMMA ids read_comp
    (45) read_comp -> . empty
    (90) empty -> .

    COMMA           shift and go to state 147
    CLOSE_PAREN     reduce using rule 90 (empty -> .)

    read_comp                      shift and go to state 189
    empty                          shift and go to state 148

state 177

    (46) write -> WRITE OPEN_PAREN CT_STRING write_comp CLOSE_PAREN .

    SEMICOLON       reduce using rule 46 (write -> WRITE OPEN_PAREN CT_STRING write_comp CLOSE_PAREN .)


state 178

    (48) write_comp -> COMMA CT_STRING . write_comp
    (48) write_comp -> . COMMA CT_STRING write_comp
    (49) write_comp -> . COMMA expressions write_comp
    (50) write_comp -> . empty
    (90) empty -> .

    COMMA           shift and go to state 150
    CLOSE_PAREN     reduce using rule 90 (empty -> .)

    write_comp                     shift and go to state 190
    empty                          shift and go to state 151

state 179

    (49) write_comp -> COMMA expressions . write_comp
    (48) write_comp -> . COMMA CT_STRING write_comp
    (49) write_comp -> . COMMA expressions write_comp
    (50) write_comp -> . empty
    (90) empty -> .

    COMMA           shift and go to state 150
    CLOSE_PAREN     reduce using rule 90 (empty -> .)

    write_comp                     shift and go to state 191
    empty                          shift and go to state 151

state 180

    (47) write -> WRITE OPEN_PAREN expressions write_comp CLOSE_PAREN .

    SEMICOLON       reduce using rule 47 (write -> WRITE OPEN_PAREN expressions write_comp CLOSE_PAREN .)


state 181

    (51) condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN . block ELSE block
    (52) condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN . block
    (10) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 33

    block                          shift and go to state 192

state 182

    (53) condition -> WHILE OPEN_PAREN expressions CLOSE_PAREN DO . block
    (10) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 33

    block                          shift and go to state 193

state 183

    (54) condition -> FOR ids_dec ASSIGN expressions TO . expressions DO block
    (60) expressions -> . expressions_comp
    (61) expressions_comp -> . expression_comp_2
    (62) expressions_comp -> . expression_comp_2 OR expressions_comp
    (63) expression_comp_2 -> . expression_comp_3
    (64) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (65) expression_comp_3 -> . exp
    (66) expression_comp_3 -> . exp expressions_op exp
    (73) exp -> . term
    (74) exp -> . term exp_comp
    (77) term -> . factor
    (78) term -> . factor term_comp
    (81) factor -> . OPEN_PAREN expressions CLOSE_PAREN
    (82) factor -> . variable
    (83) factor -> . func_call
    (84) factor -> . CT_INT
    (85) factor -> . CT_FLOAT
    (86) factor -> . CT_CHAR
    (87) variable -> . ID
    (88) variable -> . ID dim
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 103
    CT_INT          shift and go to state 106
    CT_FLOAT        shift and go to state 107
    CT_CHAR         shift and go to state 108
    ID              shift and go to state 109

    expressions                    shift and go to state 194
    expressions_comp               shift and go to state 97
    expression_comp_2              shift and go to state 98
    expression_comp_3              shift and go to state 99
    exp                            shift and go to state 100
    term                           shift and go to state 101
    factor                         shift and go to state 102
    variable                       shift and go to state 104
    func_call                      shift and go to state 105

state 184

    (58) func_call_comp -> COMMA expressions func_call_comp .

    CLOSE_PAREN     reduce using rule 58 (func_call_comp -> COMMA expressions func_call_comp .)


state 185

    (32) ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS . exp CLOSE_BRACKETS
    (73) exp -> . term
    (74) exp -> . term exp_comp
    (77) term -> . factor
    (78) term -> . factor term_comp
    (81) factor -> . OPEN_PAREN expressions CLOSE_PAREN
    (82) factor -> . variable
    (83) factor -> . func_call
    (84) factor -> . CT_INT
    (85) factor -> . CT_FLOAT
    (86) factor -> . CT_CHAR
    (87) variable -> . ID
    (88) variable -> . ID dim
    (56) func_call -> . ID OPEN_PAREN func_call_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 103
    CT_INT          shift and go to state 106
    CT_FLOAT        shift and go to state 107
    CT_CHAR         shift and go to state 108
    ID              shift and go to state 109

    exp                            shift and go to state 195
    term                           shift and go to state 101
    factor                         shift and go to state 102
    variable                       shift and go to state 104
    func_call                      shift and go to state 105

state 186

    (8) funcs_params_comp -> COMMA var_type ID funcs_params_comp .

    CLOSE_PAREN     reduce using rule 8 (funcs_params_comp -> COMMA var_type ID funcs_params_comp .)


state 187

    (5) funcs_comp -> ID OPEN_PAREN funcs_params . CLOSE_PAREN vars block

    CLOSE_PAREN     shift and go to state 196


state 188

    (25) var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .

    VOID            reduce using rule 25 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    INT             reduce using rule 25 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    FLOAT           reduce using rule 25 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    CHAR            reduce using rule 25 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    MAIN            reduce using rule 25 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    OPEN_BRACES     reduce using rule 25 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)


state 189

    (44) read_comp -> COMMA ids read_comp .

    CLOSE_PAREN     reduce using rule 44 (read_comp -> COMMA ids read_comp .)


state 190

    (48) write_comp -> COMMA CT_STRING write_comp .

    CLOSE_PAREN     reduce using rule 48 (write_comp -> COMMA CT_STRING write_comp .)


state 191

    (49) write_comp -> COMMA expressions write_comp .

    CLOSE_PAREN     reduce using rule 49 (write_comp -> COMMA expressions write_comp .)


state 192

    (51) condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block . ELSE block
    (52) condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block .

    ELSE            shift and go to state 197
    READ            reduce using rule 52 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block .)
    WRITE           reduce using rule 52 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block .)
    IF              reduce using rule 52 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block .)
    WHILE           reduce using rule 52 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block .)
    FOR             reduce using rule 52 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block .)
    RETURN          reduce using rule 52 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block .)
    ID              reduce using rule 52 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block .)
    CLOSE_BRACES    reduce using rule 52 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block .)


state 193

    (53) condition -> WHILE OPEN_PAREN expressions CLOSE_PAREN DO block .

    READ            reduce using rule 53 (condition -> WHILE OPEN_PAREN expressions CLOSE_PAREN DO block .)
    WRITE           reduce using rule 53 (condition -> WHILE OPEN_PAREN expressions CLOSE_PAREN DO block .)
    IF              reduce using rule 53 (condition -> WHILE OPEN_PAREN expressions CLOSE_PAREN DO block .)
    WHILE           reduce using rule 53 (condition -> WHILE OPEN_PAREN expressions CLOSE_PAREN DO block .)
    FOR             reduce using rule 53 (condition -> WHILE OPEN_PAREN expressions CLOSE_PAREN DO block .)
    RETURN          reduce using rule 53 (condition -> WHILE OPEN_PAREN expressions CLOSE_PAREN DO block .)
    ID              reduce using rule 53 (condition -> WHILE OPEN_PAREN expressions CLOSE_PAREN DO block .)
    CLOSE_BRACES    reduce using rule 53 (condition -> WHILE OPEN_PAREN expressions CLOSE_PAREN DO block .)


state 194

    (54) condition -> FOR ids_dec ASSIGN expressions TO expressions . DO block

    DO              shift and go to state 198


state 195

    (32) ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp . CLOSE_BRACKETS

    CLOSE_BRACKETS  shift and go to state 199


state 196

    (5) funcs_comp -> ID OPEN_PAREN funcs_params CLOSE_PAREN . vars block
    (16) vars -> . VARS create_var_table var_comp
    (17) vars -> . empty
    (90) empty -> .

    VARS            shift and go to state 6
    OPEN_BRACES     reduce using rule 90 (empty -> .)

    vars                           shift and go to state 200
    empty                          shift and go to state 7

state 197

    (51) condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE . block
    (10) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 33

    block                          shift and go to state 201

state 198

    (54) condition -> FOR ids_dec ASSIGN expressions TO expressions DO . block
    (10) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 33

    block                          shift and go to state 202

state 199

    (32) ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS .

    ASSIGN          reduce using rule 32 (ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS .)
    COMMA           reduce using rule 32 (ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CLOSE_PAREN     reduce using rule 32 (ids -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS .)


state 200

    (5) funcs_comp -> ID OPEN_PAREN funcs_params CLOSE_PAREN vars . block
    (10) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 33

    block                          shift and go to state 203

state 201

    (51) condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE block .

    READ            reduce using rule 51 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE block .)
    WRITE           reduce using rule 51 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE block .)
    IF              reduce using rule 51 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE block .)
    WHILE           reduce using rule 51 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE block .)
    FOR             reduce using rule 51 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE block .)
    RETURN          reduce using rule 51 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE block .)
    ID              reduce using rule 51 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE block .)
    CLOSE_BRACES    reduce using rule 51 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN THEN block ELSE block .)


state 202

    (54) condition -> FOR ids_dec ASSIGN expressions TO expressions DO block .

    READ            reduce using rule 54 (condition -> FOR ids_dec ASSIGN expressions TO expressions DO block .)
    WRITE           reduce using rule 54 (condition -> FOR ids_dec ASSIGN expressions TO expressions DO block .)
    IF              reduce using rule 54 (condition -> FOR ids_dec ASSIGN expressions TO expressions DO block .)
    WHILE           reduce using rule 54 (condition -> FOR ids_dec ASSIGN expressions TO expressions DO block .)
    FOR             reduce using rule 54 (condition -> FOR ids_dec ASSIGN expressions TO expressions DO block .)
    RETURN          reduce using rule 54 (condition -> FOR ids_dec ASSIGN expressions TO expressions DO block .)
    ID              reduce using rule 54 (condition -> FOR ids_dec ASSIGN expressions TO expressions DO block .)
    CLOSE_BRACES    reduce using rule 54 (condition -> FOR ids_dec ASSIGN expressions TO expressions DO block .)


state 203

    (5) funcs_comp -> ID OPEN_PAREN funcs_params CLOSE_PAREN vars block .

    VOID            reduce using rule 5 (funcs_comp -> ID OPEN_PAREN funcs_params CLOSE_PAREN vars block .)
    INT             reduce using rule 5 (funcs_comp -> ID OPEN_PAREN funcs_params CLOSE_PAREN vars block .)
    FLOAT           reduce using rule 5 (funcs_comp -> ID OPEN_PAREN funcs_params CLOSE_PAREN vars block .)
    CHAR            reduce using rule 5 (funcs_comp -> ID OPEN_PAREN funcs_params CLOSE_PAREN vars block .)
    MAIN            reduce using rule 5 (funcs_comp -> ID OPEN_PAREN funcs_params CLOSE_PAREN vars block .)
    OPEN_BRACES     reduce using rule 5 (funcs_comp -> ID OPEN_PAREN funcs_params CLOSE_PAREN vars block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for INT in state 38 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 38 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 38 resolved as shift
WARNING: shift/reduce conflict for OPEN_PAREN in state 109 resolved as shift
WARNING: shift/reduce conflict for INT in state 165 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 165 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 165 resolved as shift
