Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM g_main_quad ID add_program SEMICOLON vars funcs main end_program
Rule 2     add_program -> <empty>
Rule 3     end_program -> <empty>
Rule 4     main -> MAIN OPEN_PAREN CLOSE_PAREN fill_main_quad block
Rule 5     g_main_quad -> <empty>
Rule 6     fill_main_quad -> <empty>
Rule 7     funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs
Rule 8     funcs -> empty
Rule 9     end_funcs -> <empty>
Rule 10    count_local_vars -> <empty>
Rule 11    add_module -> <empty>
Rule 12    funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs
Rule 13    add_parameter_amount -> <empty>
Rule 14    funcs_params -> var_type variable_params funcs_params_comp
Rule 15    funcs_params -> empty
Rule 16    funcs_params_comp -> COMMA var_type variable_params funcs_params_comp
Rule 17    funcs_params_comp -> empty
Rule 18    variable_params -> ID
Rule 19    variable_params -> ID dim
Rule 20    block -> OPEN_BRACES statements CLOSE_BRACES
Rule 21    func_type -> var_type
Rule 22    func_type -> VOID
Rule 23    var_type -> INT
Rule 24    var_type -> FLOAT
Rule 25    var_type -> CHAR
Rule 26    vars -> VARS var_comp
Rule 27    vars -> empty
Rule 28    var_comp -> var_type ids_dec var_comp_2 var_comp_final
Rule 29    var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive
Rule 30    var_comp_2 -> COMMA ids_dec var_comp_3
Rule 31    var_comp_2 -> empty
Rule 32    var_comp_3 -> var_comp_2
Rule 33    var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final
Rule 34    var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive
Rule 35    var_comp_final -> SEMICOLON
Rule 36    var_comp_final -> var_module_trans
Rule 37    var_module_trans -> SEMICOLON var_type MODULE funcs_comp
Rule 38    ids_dec -> ids_dec_matrix
Rule 39    ids_dec -> ids_dec_array
Rule 40    ids_dec -> ids_dec_single
Rule 41    ids_dec_matrix -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
Rule 42    ids_dec_array -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS
Rule 43    ids_dec_single -> ID
Rule 44    ids -> ids_matrix
Rule 45    ids -> ids_array
Rule 46    ids -> ids_single
Rule 47    ids_matrix -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
Rule 48    ids_array -> ID OPEN_BRACKETS exp CLOSE_BRACKETS
Rule 49    ids_single -> ID
Rule 50    statements -> assignment SEMICOLON statements
Rule 51    statements -> read SEMICOLON statements
Rule 52    statements -> write SEMICOLON statements
Rule 53    statements -> condition statements
Rule 54    statements -> return SEMICOLON statements
Rule 55    statements -> func_call SEMICOLON statements
Rule 56    statements -> empty
Rule 57    assignment -> ids ASSIGN expressions
Rule 58    read -> READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN
Rule 59    read_comp -> COMMA ids g_quad_read read_comp
Rule 60    read_comp -> empty
Rule 61    g_quad_read -> <empty>
Rule 62    write -> WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
Rule 63    write -> WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN
Rule 64    write_comp -> COMMA CT_STRING g_quad_write_str write_comp
Rule 65    write_comp -> COMMA expressions g_quad_write write_comp
Rule 66    write_comp -> empty
Rule 67    g_quad_write_str -> <empty>
Rule 68    g_quad_write -> <empty>
Rule 69    end_if -> <empty>
Rule 70    condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
Rule 71    condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
Rule 72    condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
Rule 73    condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
Rule 74    g_if_quad -> <empty>
Rule 75    g_else_quad -> <empty>
Rule 76    while_jump -> <empty>
Rule 77    g_while_quad -> <empty>
Rule 78    end_while -> <empty>
Rule 79    validate_for -> <empty>
Rule 80    for_counter_control -> <empty>
Rule 81    for_counter_end -> <empty>
Rule 82    end_for -> <empty>
Rule 83    return -> RETURN OPEN_PAREN expressions CLOSE_PAREN g_quad_return
Rule 84    g_quad_return -> <empty>
Rule 85    func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end
Rule 86    function_call_end -> <empty>
Rule 87    g_gosub_quad -> <empty>
Rule 88    change_to_global -> <empty>
Rule 89    verify_function_exists -> <empty>
Rule 90    era_activation -> <empty>
Rule 91    func_call_comp -> expressions g_parameter_quad func_call_comp
Rule 92    func_call_comp -> COMMA expressions g_parameter_quad func_call_comp
Rule 93    func_call_comp -> empty
Rule 94    g_parameter_quad -> <empty>
Rule 95    expressions -> expressions_comp
Rule 96    expressions_comp -> expression_comp_2
Rule 97    expressions_comp -> expression_comp_2 OR expressions_comp
Rule 98    expression_comp_2 -> expression_comp_3
Rule 99    expression_comp_2 -> expression_comp_3 AND expression_comp_2
Rule 100   expression_comp_3 -> exp expressions_op exp g_quad_logic
Rule 101   expression_comp_3 -> exp
Rule 102   g_quad_logic -> <empty>
Rule 103   expressions_op -> LESS_THAN add_op
Rule 104   expressions_op -> LESS_THAN_EQUAL add_op
Rule 105   expressions_op -> MORE_THAN add_op
Rule 106   expressions_op -> MORE_THAN_EQUAL add_op
Rule 107   expressions_op -> EQUALS add_op
Rule 108   expressions_op -> NOT_EQUALS add_op
Rule 109   exp -> term g_quad_exp_as_alone
Rule 110   exp -> term g_quad_exp_as exp_comp
Rule 111   g_quad_exp_as -> <empty>
Rule 112   g_quad_exp_as_alone -> <empty>
Rule 113   exp_comp -> PLUS add_op exp
Rule 114   exp_comp -> MINUS add_op exp
Rule 115   term -> factor g_quad_exp_md_alone
Rule 116   term -> factor g_quad_exp_md term_comp
Rule 117   g_quad_exp_md -> <empty>
Rule 118   g_quad_exp_md_alone -> <empty>
Rule 119   term_comp -> MULTIPLIES add_op term
Rule 120   term_comp -> DIVIDE add_op term
Rule 121   add_op -> <empty>
Rule 122   factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
Rule 123   factor -> variable
Rule 124   factor -> func_call
Rule 125   factor -> CT_INT add_ct_int
Rule 126   factor -> CT_FLOAT add_ct_float
Rule 127   factor -> CT_CHAR add_ct_char
Rule 128   add_fake -> <empty>
Rule 129   rem_fake -> <empty>
Rule 130   add_ct_int -> <empty>
Rule 131   add_ct_float -> <empty>
Rule 132   add_ct_char -> <empty>
Rule 133   variable -> ID add_id
Rule 134   variable -> ID dim
Rule 135   add_id -> <empty>
Rule 136   dim -> OPEN_BRACKETS exp CLOSE_BRACKETS
Rule 137   empty -> <empty>

Terminals, with rules where they appear

AND                  : 99
ASSIGN               : 57 73
CHAR                 : 25
CLOSE_BRACES         : 20
CLOSE_BRACKETS       : 41 41 42 47 47 48 136
CLOSE_PAREN          : 4 7 12 58 62 63 70 71 72 83 85 122
COMMA                : 16 30 59 64 65 92
CT_CHAR              : 127
CT_FLOAT             : 126
CT_INT               : 41 41 42 125
CT_STRING            : 62 64
DIVIDE               : 120
DO                   : 72 73
ELSE                 : 71
EQUALS               : 107
FLOAT                : 24
FOR                  : 73
ID                   : 1 7 12 18 19 41 42 43 47 48 49 85 133 134
IF                   : 70 71
INT                  : 23
LESS_THAN            : 103
LESS_THAN_EQUAL      : 104
MAIN                 : 4
MINUS                : 114
MODULE               : 7 37
MORE_THAN            : 105
MORE_THAN_EQUAL      : 106
MULTIPLIES           : 119
NOT_EQUALS           : 108
OPEN_BRACES          : 20
OPEN_BRACKETS        : 41 41 42 47 47 48 136
OPEN_PAREN           : 4 7 12 58 62 63 70 71 72 83 85 122
OR                   : 97
PLUS                 : 113
PROGRAM              : 1
READ                 : 58
RETURN               : 83
SEMICOLON            : 1 29 34 35 37 50 51 52 54 55
THEN                 : 70 71
TO                   : 73
VARS                 : 26
VOID                 : 22
WHILE                : 72
WRITE                : 62 63
error                : 

Nonterminals, with rules where they appear

add_ct_char          : 127
add_ct_float         : 126
add_ct_int           : 125
add_fake             : 122
add_id               : 133
add_module           : 7 12
add_op               : 103 104 105 106 107 108 113 114 119 120
add_parameter_amount : 7 12
add_program          : 1
assignment           : 50
block                : 4 7 12 70 71 71 72 73
change_to_global     : 
condition            : 53
count_local_vars     : 7 12
dim                  : 19 134
empty                : 8 15 17 27 31 56 60 66 93
end_for              : 73
end_funcs            : 7 12
end_if               : 70 71
end_program          : 1
end_while            : 72
era_activation       : 85
exp                  : 47 47 48 100 100 101 113 114 136
exp_comp             : 110
expression_comp_2    : 96 97 99
expression_comp_3    : 98 99
expressions          : 57 63 65 70 71 72 73 73 83 91 92 122
expressions_comp     : 95 97
expressions_op       : 100
factor               : 115 116
fill_main_quad       : 4
for_counter_control  : 73
for_counter_end      : 73
func_call            : 55 124
func_call_comp       : 85 91 92
func_type            : 7
funcs                : 1 7 12
funcs_comp           : 37
funcs_params         : 7 12
funcs_params_comp    : 14 16
function_call_end    : 85
g_else_quad          : 71
g_gosub_quad         : 85
g_if_quad            : 70 71
g_main_quad          : 1
g_parameter_quad     : 91 92
g_quad_exp_as        : 110
g_quad_exp_as_alone  : 109
g_quad_exp_md        : 116
g_quad_exp_md_alone  : 115
g_quad_logic         : 100
g_quad_read          : 58 59
g_quad_return        : 83
g_quad_write         : 63 65
g_quad_write_str     : 62 64
g_while_quad         : 72
ids                  : 57 58 59 73
ids_array            : 45
ids_dec              : 28 29 30 33 34
ids_dec_array        : 39
ids_dec_matrix       : 38
ids_dec_single       : 40
ids_matrix           : 44
ids_single           : 46
main                 : 1
program              : 0
read                 : 51
read_comp            : 58 59
rem_fake             : 122
return               : 54
statements           : 20 50 51 52 53 54 55
term                 : 109 110 119 120
term_comp            : 116
validate_for         : 73
var_comp             : 26
var_comp_2           : 28 29 32 33 34
var_comp_3           : 30
var_comp_final       : 28 33
var_comp_recursive   : 29 34
var_module_trans     : 36
var_type             : 14 16 21 28 29 33 34 37
variable             : 123
variable_params      : 14 16
vars                 : 1 7 12
verify_function_exists : 85
while_jump           : 72
write                : 52
write_comp           : 62 63 64 65

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM g_main_quad ID add_program SEMICOLON vars funcs main end_program

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . g_main_quad ID add_program SEMICOLON vars funcs main end_program
    (5) g_main_quad -> .

    ID              reduce using rule 5 (g_main_quad -> .)

    g_main_quad                    shift and go to state 3

state 3

    (1) program -> PROGRAM g_main_quad . ID add_program SEMICOLON vars funcs main end_program

    ID              shift and go to state 4


state 4

    (1) program -> PROGRAM g_main_quad ID . add_program SEMICOLON vars funcs main end_program
    (2) add_program -> .

    SEMICOLON       reduce using rule 2 (add_program -> .)

    add_program                    shift and go to state 5

state 5

    (1) program -> PROGRAM g_main_quad ID add_program . SEMICOLON vars funcs main end_program

    SEMICOLON       shift and go to state 6


state 6

    (1) program -> PROGRAM g_main_quad ID add_program SEMICOLON . vars funcs main end_program
    (26) vars -> . VARS var_comp
    (27) vars -> . empty
    (137) empty -> .

    VARS            shift and go to state 8
    VOID            reduce using rule 137 (empty -> .)
    INT             reduce using rule 137 (empty -> .)
    FLOAT           reduce using rule 137 (empty -> .)
    CHAR            reduce using rule 137 (empty -> .)
    MAIN            reduce using rule 137 (empty -> .)

    vars                           shift and go to state 7
    empty                          shift and go to state 9

state 7

    (1) program -> PROGRAM g_main_quad ID add_program SEMICOLON vars . funcs main end_program
    (7) funcs -> . func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs
    (8) funcs -> . empty
    (21) func_type -> . var_type
    (22) func_type -> . VOID
    (137) empty -> .
    (23) var_type -> . INT
    (24) var_type -> . FLOAT
    (25) var_type -> . CHAR

    VOID            shift and go to state 14
    MAIN            reduce using rule 137 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

    funcs                          shift and go to state 10
    func_type                      shift and go to state 11
    empty                          shift and go to state 12
    var_type                       shift and go to state 13

state 8

    (26) vars -> VARS . var_comp
    (28) var_comp -> . var_type ids_dec var_comp_2 var_comp_final
    (29) var_comp -> . var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive
    (23) var_type -> . INT
    (24) var_type -> . FLOAT
    (25) var_type -> . CHAR

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

    var_comp                       shift and go to state 18
    var_type                       shift and go to state 19

state 9

    (27) vars -> empty .

    VOID            reduce using rule 27 (vars -> empty .)
    INT             reduce using rule 27 (vars -> empty .)
    FLOAT           reduce using rule 27 (vars -> empty .)
    CHAR            reduce using rule 27 (vars -> empty .)
    MAIN            reduce using rule 27 (vars -> empty .)
    OPEN_BRACES     reduce using rule 27 (vars -> empty .)


state 10

    (1) program -> PROGRAM g_main_quad ID add_program SEMICOLON vars funcs . main end_program
    (4) main -> . MAIN OPEN_PAREN CLOSE_PAREN fill_main_quad block

    MAIN            shift and go to state 21

    main                           shift and go to state 20

state 11

    (7) funcs -> func_type . MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs

    MODULE          shift and go to state 22


state 12

    (8) funcs -> empty .

    MAIN            reduce using rule 8 (funcs -> empty .)
    VOID            reduce using rule 8 (funcs -> empty .)
    INT             reduce using rule 8 (funcs -> empty .)
    FLOAT           reduce using rule 8 (funcs -> empty .)
    CHAR            reduce using rule 8 (funcs -> empty .)
    OPEN_BRACES     reduce using rule 8 (funcs -> empty .)


state 13

    (21) func_type -> var_type .

    MODULE          reduce using rule 21 (func_type -> var_type .)


state 14

    (22) func_type -> VOID .

    MODULE          reduce using rule 22 (func_type -> VOID .)


state 15

    (23) var_type -> INT .

    MODULE          reduce using rule 23 (var_type -> INT .)
    ID              reduce using rule 23 (var_type -> INT .)


state 16

    (24) var_type -> FLOAT .

    MODULE          reduce using rule 24 (var_type -> FLOAT .)
    ID              reduce using rule 24 (var_type -> FLOAT .)


state 17

    (25) var_type -> CHAR .

    MODULE          reduce using rule 25 (var_type -> CHAR .)
    ID              reduce using rule 25 (var_type -> CHAR .)


state 18

    (26) vars -> VARS var_comp .

    VOID            reduce using rule 26 (vars -> VARS var_comp .)
    INT             reduce using rule 26 (vars -> VARS var_comp .)
    FLOAT           reduce using rule 26 (vars -> VARS var_comp .)
    CHAR            reduce using rule 26 (vars -> VARS var_comp .)
    MAIN            reduce using rule 26 (vars -> VARS var_comp .)
    OPEN_BRACES     reduce using rule 26 (vars -> VARS var_comp .)


state 19

    (28) var_comp -> var_type . ids_dec var_comp_2 var_comp_final
    (29) var_comp -> var_type . ids_dec var_comp_2 SEMICOLON var_comp_recursive
    (38) ids_dec -> . ids_dec_matrix
    (39) ids_dec -> . ids_dec_array
    (40) ids_dec -> . ids_dec_single
    (41) ids_dec_matrix -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (42) ids_dec_array -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (43) ids_dec_single -> . ID

    ID              shift and go to state 27

    ids_dec                        shift and go to state 23
    ids_dec_matrix                 shift and go to state 24
    ids_dec_array                  shift and go to state 25
    ids_dec_single                 shift and go to state 26

state 20

    (1) program -> PROGRAM g_main_quad ID add_program SEMICOLON vars funcs main . end_program
    (3) end_program -> .

    $end            reduce using rule 3 (end_program -> .)

    end_program                    shift and go to state 28

state 21

    (4) main -> MAIN . OPEN_PAREN CLOSE_PAREN fill_main_quad block

    OPEN_PAREN      shift and go to state 29


state 22

    (7) funcs -> func_type MODULE . ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs

    ID              shift and go to state 30


state 23

    (28) var_comp -> var_type ids_dec . var_comp_2 var_comp_final
    (29) var_comp -> var_type ids_dec . var_comp_2 SEMICOLON var_comp_recursive
    (30) var_comp_2 -> . COMMA ids_dec var_comp_3
    (31) var_comp_2 -> . empty
    (137) empty -> .

    COMMA           shift and go to state 32
    SEMICOLON       reduce using rule 137 (empty -> .)

    var_comp_2                     shift and go to state 31
    empty                          shift and go to state 33

state 24

    (38) ids_dec -> ids_dec_matrix .

    COMMA           reduce using rule 38 (ids_dec -> ids_dec_matrix .)
    SEMICOLON       reduce using rule 38 (ids_dec -> ids_dec_matrix .)


state 25

    (39) ids_dec -> ids_dec_array .

    COMMA           reduce using rule 39 (ids_dec -> ids_dec_array .)
    SEMICOLON       reduce using rule 39 (ids_dec -> ids_dec_array .)


state 26

    (40) ids_dec -> ids_dec_single .

    COMMA           reduce using rule 40 (ids_dec -> ids_dec_single .)
    SEMICOLON       reduce using rule 40 (ids_dec -> ids_dec_single .)


state 27

    (41) ids_dec_matrix -> ID . OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (42) ids_dec_array -> ID . OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (43) ids_dec_single -> ID .

    OPEN_BRACKETS   shift and go to state 34
    COMMA           reduce using rule 43 (ids_dec_single -> ID .)
    SEMICOLON       reduce using rule 43 (ids_dec_single -> ID .)


state 28

    (1) program -> PROGRAM g_main_quad ID add_program SEMICOLON vars funcs main end_program .

    $end            reduce using rule 1 (program -> PROGRAM g_main_quad ID add_program SEMICOLON vars funcs main end_program .)


state 29

    (4) main -> MAIN OPEN_PAREN . CLOSE_PAREN fill_main_quad block

    CLOSE_PAREN     shift and go to state 35


state 30

    (7) funcs -> func_type MODULE ID . add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs
    (11) add_module -> .

    OPEN_PAREN      reduce using rule 11 (add_module -> .)

    add_module                     shift and go to state 36

state 31

    (28) var_comp -> var_type ids_dec var_comp_2 . var_comp_final
    (29) var_comp -> var_type ids_dec var_comp_2 . SEMICOLON var_comp_recursive
    (35) var_comp_final -> . SEMICOLON
    (36) var_comp_final -> . var_module_trans
    (37) var_module_trans -> . SEMICOLON var_type MODULE funcs_comp

    SEMICOLON       shift and go to state 38

    var_comp_final                 shift and go to state 37
    var_module_trans               shift and go to state 39

state 32

    (30) var_comp_2 -> COMMA . ids_dec var_comp_3
    (38) ids_dec -> . ids_dec_matrix
    (39) ids_dec -> . ids_dec_array
    (40) ids_dec -> . ids_dec_single
    (41) ids_dec_matrix -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (42) ids_dec_array -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (43) ids_dec_single -> . ID

    ID              shift and go to state 27

    ids_dec                        shift and go to state 40
    ids_dec_matrix                 shift and go to state 24
    ids_dec_array                  shift and go to state 25
    ids_dec_single                 shift and go to state 26

state 33

    (31) var_comp_2 -> empty .

    SEMICOLON       reduce using rule 31 (var_comp_2 -> empty .)


state 34

    (41) ids_dec_matrix -> ID OPEN_BRACKETS . CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (42) ids_dec_array -> ID OPEN_BRACKETS . CT_INT CLOSE_BRACKETS

    CT_INT          shift and go to state 41


state 35

    (4) main -> MAIN OPEN_PAREN CLOSE_PAREN . fill_main_quad block
    (6) fill_main_quad -> .

    OPEN_BRACES     reduce using rule 6 (fill_main_quad -> .)

    fill_main_quad                 shift and go to state 42

state 36

    (7) funcs -> func_type MODULE ID add_module . OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs

    OPEN_PAREN      shift and go to state 43


state 37

    (28) var_comp -> var_type ids_dec var_comp_2 var_comp_final .

    VOID            reduce using rule 28 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)
    INT             reduce using rule 28 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)
    FLOAT           reduce using rule 28 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)
    CHAR            reduce using rule 28 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)
    MAIN            reduce using rule 28 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)
    OPEN_BRACES     reduce using rule 28 (var_comp -> var_type ids_dec var_comp_2 var_comp_final .)


state 38

    (29) var_comp -> var_type ids_dec var_comp_2 SEMICOLON . var_comp_recursive
    (35) var_comp_final -> SEMICOLON .
    (37) var_module_trans -> SEMICOLON . var_type MODULE funcs_comp
    (33) var_comp_recursive -> . var_type ids_dec var_comp_2 var_comp_final
    (34) var_comp_recursive -> . var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive
    (23) var_type -> . INT
    (24) var_type -> . FLOAT
    (25) var_type -> . CHAR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
    VOID            reduce using rule 35 (var_comp_final -> SEMICOLON .)
    MAIN            reduce using rule 35 (var_comp_final -> SEMICOLON .)
    OPEN_BRACES     reduce using rule 35 (var_comp_final -> SEMICOLON .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

  ! INT             [ reduce using rule 35 (var_comp_final -> SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 35 (var_comp_final -> SEMICOLON .) ]
  ! CHAR            [ reduce using rule 35 (var_comp_final -> SEMICOLON .) ]

    var_type                       shift and go to state 44
    var_comp_recursive             shift and go to state 45

state 39

    (36) var_comp_final -> var_module_trans .

    VOID            reduce using rule 36 (var_comp_final -> var_module_trans .)
    INT             reduce using rule 36 (var_comp_final -> var_module_trans .)
    FLOAT           reduce using rule 36 (var_comp_final -> var_module_trans .)
    CHAR            reduce using rule 36 (var_comp_final -> var_module_trans .)
    MAIN            reduce using rule 36 (var_comp_final -> var_module_trans .)
    OPEN_BRACES     reduce using rule 36 (var_comp_final -> var_module_trans .)


state 40

    (30) var_comp_2 -> COMMA ids_dec . var_comp_3
    (32) var_comp_3 -> . var_comp_2
    (30) var_comp_2 -> . COMMA ids_dec var_comp_3
    (31) var_comp_2 -> . empty
    (137) empty -> .

    COMMA           shift and go to state 32
    SEMICOLON       reduce using rule 137 (empty -> .)

    var_comp_3                     shift and go to state 46
    var_comp_2                     shift and go to state 47
    empty                          shift and go to state 33

state 41

    (41) ids_dec_matrix -> ID OPEN_BRACKETS CT_INT . CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (42) ids_dec_array -> ID OPEN_BRACKETS CT_INT . CLOSE_BRACKETS

    CLOSE_BRACKETS  shift and go to state 48


state 42

    (4) main -> MAIN OPEN_PAREN CLOSE_PAREN fill_main_quad . block
    (20) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 50

    block                          shift and go to state 49

state 43

    (7) funcs -> func_type MODULE ID add_module OPEN_PAREN . funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs
    (14) funcs_params -> . var_type variable_params funcs_params_comp
    (15) funcs_params -> . empty
    (23) var_type -> . INT
    (24) var_type -> . FLOAT
    (25) var_type -> . CHAR
    (137) empty -> .

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    CLOSE_PAREN     reduce using rule 137 (empty -> .)

    funcs_params                   shift and go to state 51
    var_type                       shift and go to state 52
    empty                          shift and go to state 53

state 44

    (37) var_module_trans -> SEMICOLON var_type . MODULE funcs_comp
    (33) var_comp_recursive -> var_type . ids_dec var_comp_2 var_comp_final
    (34) var_comp_recursive -> var_type . ids_dec var_comp_2 SEMICOLON var_comp_recursive
    (38) ids_dec -> . ids_dec_matrix
    (39) ids_dec -> . ids_dec_array
    (40) ids_dec -> . ids_dec_single
    (41) ids_dec_matrix -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (42) ids_dec_array -> . ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (43) ids_dec_single -> . ID

    MODULE          shift and go to state 54
    ID              shift and go to state 27

    ids_dec                        shift and go to state 55
    ids_dec_matrix                 shift and go to state 24
    ids_dec_array                  shift and go to state 25
    ids_dec_single                 shift and go to state 26

state 45

    (29) var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .

    VOID            reduce using rule 29 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    INT             reduce using rule 29 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    FLOAT           reduce using rule 29 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    CHAR            reduce using rule 29 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    MAIN            reduce using rule 29 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    OPEN_BRACES     reduce using rule 29 (var_comp -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)


state 46

    (30) var_comp_2 -> COMMA ids_dec var_comp_3 .

    SEMICOLON       reduce using rule 30 (var_comp_2 -> COMMA ids_dec var_comp_3 .)


state 47

    (32) var_comp_3 -> var_comp_2 .

    SEMICOLON       reduce using rule 32 (var_comp_3 -> var_comp_2 .)


state 48

    (41) ids_dec_matrix -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS . OPEN_BRACKETS CT_INT CLOSE_BRACKETS
    (42) ids_dec_array -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS .

    OPEN_BRACKETS   shift and go to state 56
    COMMA           reduce using rule 42 (ids_dec_array -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS .)
    SEMICOLON       reduce using rule 42 (ids_dec_array -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS .)


state 49

    (4) main -> MAIN OPEN_PAREN CLOSE_PAREN fill_main_quad block .

    $end            reduce using rule 4 (main -> MAIN OPEN_PAREN CLOSE_PAREN fill_main_quad block .)


state 50

    (20) block -> OPEN_BRACES . statements CLOSE_BRACES
    (50) statements -> . assignment SEMICOLON statements
    (51) statements -> . read SEMICOLON statements
    (52) statements -> . write SEMICOLON statements
    (53) statements -> . condition statements
    (54) statements -> . return SEMICOLON statements
    (55) statements -> . func_call SEMICOLON statements
    (56) statements -> . empty
    (57) assignment -> . ids ASSIGN expressions
    (58) read -> . READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN
    (62) write -> . WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (63) write -> . WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN
    (70) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (71) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
    (72) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
    (73) condition -> . FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (83) return -> . RETURN OPEN_PAREN expressions CLOSE_PAREN g_quad_return
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end
    (137) empty -> .
    (44) ids -> . ids_matrix
    (45) ids -> . ids_array
    (46) ids -> . ids_single
    (47) ids_matrix -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (48) ids_array -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (49) ids_single -> . ID

    READ            shift and go to state 66
    WRITE           shift and go to state 67
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70
    RETURN          shift and go to state 71
    ID              shift and go to state 72
    CLOSE_BRACES    reduce using rule 137 (empty -> .)

    statements                     shift and go to state 57
    assignment                     shift and go to state 58
    read                           shift and go to state 59
    write                          shift and go to state 60
    condition                      shift and go to state 61
    return                         shift and go to state 62
    func_call                      shift and go to state 63
    empty                          shift and go to state 64
    ids                            shift and go to state 65
    ids_matrix                     shift and go to state 73
    ids_array                      shift and go to state 74
    ids_single                     shift and go to state 75

state 51

    (7) funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params . CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs

    CLOSE_PAREN     shift and go to state 76


state 52

    (14) funcs_params -> var_type . variable_params funcs_params_comp
    (18) variable_params -> . ID
    (19) variable_params -> . ID dim

    ID              shift and go to state 78

    variable_params                shift and go to state 77

state 53

    (15) funcs_params -> empty .

    CLOSE_PAREN     reduce using rule 15 (funcs_params -> empty .)


state 54

    (37) var_module_trans -> SEMICOLON var_type MODULE . funcs_comp
    (12) funcs_comp -> . ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs

    ID              shift and go to state 80

    funcs_comp                     shift and go to state 79

state 55

    (33) var_comp_recursive -> var_type ids_dec . var_comp_2 var_comp_final
    (34) var_comp_recursive -> var_type ids_dec . var_comp_2 SEMICOLON var_comp_recursive
    (30) var_comp_2 -> . COMMA ids_dec var_comp_3
    (31) var_comp_2 -> . empty
    (137) empty -> .

    COMMA           shift and go to state 32
    SEMICOLON       reduce using rule 137 (empty -> .)

    var_comp_2                     shift and go to state 81
    empty                          shift and go to state 33

state 56

    (41) ids_dec_matrix -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS . CT_INT CLOSE_BRACKETS

    CT_INT          shift and go to state 82


state 57

    (20) block -> OPEN_BRACES statements . CLOSE_BRACES

    CLOSE_BRACES    shift and go to state 83


state 58

    (50) statements -> assignment . SEMICOLON statements

    SEMICOLON       shift and go to state 84


state 59

    (51) statements -> read . SEMICOLON statements

    SEMICOLON       shift and go to state 85


state 60

    (52) statements -> write . SEMICOLON statements

    SEMICOLON       shift and go to state 86


state 61

    (53) statements -> condition . statements
    (50) statements -> . assignment SEMICOLON statements
    (51) statements -> . read SEMICOLON statements
    (52) statements -> . write SEMICOLON statements
    (53) statements -> . condition statements
    (54) statements -> . return SEMICOLON statements
    (55) statements -> . func_call SEMICOLON statements
    (56) statements -> . empty
    (57) assignment -> . ids ASSIGN expressions
    (58) read -> . READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN
    (62) write -> . WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (63) write -> . WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN
    (70) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (71) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
    (72) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
    (73) condition -> . FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (83) return -> . RETURN OPEN_PAREN expressions CLOSE_PAREN g_quad_return
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end
    (137) empty -> .
    (44) ids -> . ids_matrix
    (45) ids -> . ids_array
    (46) ids -> . ids_single
    (47) ids_matrix -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (48) ids_array -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (49) ids_single -> . ID

    READ            shift and go to state 66
    WRITE           shift and go to state 67
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70
    RETURN          shift and go to state 71
    ID              shift and go to state 72
    CLOSE_BRACES    reduce using rule 137 (empty -> .)

    condition                      shift and go to state 61
    statements                     shift and go to state 87
    assignment                     shift and go to state 58
    read                           shift and go to state 59
    write                          shift and go to state 60
    return                         shift and go to state 62
    func_call                      shift and go to state 63
    empty                          shift and go to state 64
    ids                            shift and go to state 65
    ids_matrix                     shift and go to state 73
    ids_array                      shift and go to state 74
    ids_single                     shift and go to state 75

state 62

    (54) statements -> return . SEMICOLON statements

    SEMICOLON       shift and go to state 88


state 63

    (55) statements -> func_call . SEMICOLON statements

    SEMICOLON       shift and go to state 89


state 64

    (56) statements -> empty .

    CLOSE_BRACES    reduce using rule 56 (statements -> empty .)


state 65

    (57) assignment -> ids . ASSIGN expressions

    ASSIGN          shift and go to state 90


state 66

    (58) read -> READ . OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 91


state 67

    (62) write -> WRITE . OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (63) write -> WRITE . OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN

    OPEN_PAREN      shift and go to state 92


state 68

    (70) condition -> IF . OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (71) condition -> IF . OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if

    OPEN_PAREN      shift and go to state 93


state 69

    (72) condition -> WHILE . while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
    (76) while_jump -> .

    OPEN_PAREN      reduce using rule 76 (while_jump -> .)

    while_jump                     shift and go to state 94

state 70

    (73) condition -> FOR . ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (44) ids -> . ids_matrix
    (45) ids -> . ids_array
    (46) ids -> . ids_single
    (47) ids_matrix -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (48) ids_array -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (49) ids_single -> . ID

    ID              shift and go to state 96

    ids                            shift and go to state 95
    ids_matrix                     shift and go to state 73
    ids_array                      shift and go to state 74
    ids_single                     shift and go to state 75

state 71

    (83) return -> RETURN . OPEN_PAREN expressions CLOSE_PAREN g_quad_return

    OPEN_PAREN      shift and go to state 97


state 72

    (85) func_call -> ID . verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end
    (47) ids_matrix -> ID . OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (48) ids_array -> ID . OPEN_BRACKETS exp CLOSE_BRACKETS
    (49) ids_single -> ID .
    (89) verify_function_exists -> .

    OPEN_BRACKETS   shift and go to state 99
    ASSIGN          reduce using rule 49 (ids_single -> ID .)
    OPEN_PAREN      reduce using rule 89 (verify_function_exists -> .)

    verify_function_exists         shift and go to state 98

state 73

    (44) ids -> ids_matrix .

    ASSIGN          reduce using rule 44 (ids -> ids_matrix .)
    COMMA           reduce using rule 44 (ids -> ids_matrix .)
    CLOSE_PAREN     reduce using rule 44 (ids -> ids_matrix .)


state 74

    (45) ids -> ids_array .

    ASSIGN          reduce using rule 45 (ids -> ids_array .)
    COMMA           reduce using rule 45 (ids -> ids_array .)
    CLOSE_PAREN     reduce using rule 45 (ids -> ids_array .)


state 75

    (46) ids -> ids_single .

    ASSIGN          reduce using rule 46 (ids -> ids_single .)
    COMMA           reduce using rule 46 (ids -> ids_single .)
    CLOSE_PAREN     reduce using rule 46 (ids -> ids_single .)


state 76

    (7) funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN . add_parameter_amount vars count_local_vars block end_funcs funcs
    (13) add_parameter_amount -> .

    VARS            reduce using rule 13 (add_parameter_amount -> .)
    OPEN_BRACES     reduce using rule 13 (add_parameter_amount -> .)

    add_parameter_amount           shift and go to state 100

state 77

    (14) funcs_params -> var_type variable_params . funcs_params_comp
    (16) funcs_params_comp -> . COMMA var_type variable_params funcs_params_comp
    (17) funcs_params_comp -> . empty
    (137) empty -> .

    COMMA           shift and go to state 102
    CLOSE_PAREN     reduce using rule 137 (empty -> .)

    funcs_params_comp              shift and go to state 101
    empty                          shift and go to state 103

state 78

    (18) variable_params -> ID .
    (19) variable_params -> ID . dim
    (136) dim -> . OPEN_BRACKETS exp CLOSE_BRACKETS

    COMMA           reduce using rule 18 (variable_params -> ID .)
    CLOSE_PAREN     reduce using rule 18 (variable_params -> ID .)
    OPEN_BRACKETS   shift and go to state 105

    dim                            shift and go to state 104

state 79

    (37) var_module_trans -> SEMICOLON var_type MODULE funcs_comp .

    VOID            reduce using rule 37 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)
    INT             reduce using rule 37 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)
    FLOAT           reduce using rule 37 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)
    CHAR            reduce using rule 37 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)
    MAIN            reduce using rule 37 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)
    OPEN_BRACES     reduce using rule 37 (var_module_trans -> SEMICOLON var_type MODULE funcs_comp .)


state 80

    (12) funcs_comp -> ID . add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs
    (11) add_module -> .

    OPEN_PAREN      reduce using rule 11 (add_module -> .)

    add_module                     shift and go to state 106

state 81

    (33) var_comp_recursive -> var_type ids_dec var_comp_2 . var_comp_final
    (34) var_comp_recursive -> var_type ids_dec var_comp_2 . SEMICOLON var_comp_recursive
    (35) var_comp_final -> . SEMICOLON
    (36) var_comp_final -> . var_module_trans
    (37) var_module_trans -> . SEMICOLON var_type MODULE funcs_comp

    SEMICOLON       shift and go to state 108

    var_comp_final                 shift and go to state 107
    var_module_trans               shift and go to state 39

state 82

    (41) ids_dec_matrix -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT . CLOSE_BRACKETS

    CLOSE_BRACKETS  shift and go to state 109


state 83

    (20) block -> OPEN_BRACES statements CLOSE_BRACES .

    $end            reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    VOID            reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    INT             reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    FLOAT           reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    CHAR            reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    MAIN            reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    OPEN_BRACES     reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    ELSE            reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    READ            reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    WRITE           reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    IF              reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    WHILE           reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    FOR             reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    RETURN          reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    ID              reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)
    CLOSE_BRACES    reduce using rule 20 (block -> OPEN_BRACES statements CLOSE_BRACES .)


state 84

    (50) statements -> assignment SEMICOLON . statements
    (50) statements -> . assignment SEMICOLON statements
    (51) statements -> . read SEMICOLON statements
    (52) statements -> . write SEMICOLON statements
    (53) statements -> . condition statements
    (54) statements -> . return SEMICOLON statements
    (55) statements -> . func_call SEMICOLON statements
    (56) statements -> . empty
    (57) assignment -> . ids ASSIGN expressions
    (58) read -> . READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN
    (62) write -> . WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (63) write -> . WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN
    (70) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (71) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
    (72) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
    (73) condition -> . FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (83) return -> . RETURN OPEN_PAREN expressions CLOSE_PAREN g_quad_return
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end
    (137) empty -> .
    (44) ids -> . ids_matrix
    (45) ids -> . ids_array
    (46) ids -> . ids_single
    (47) ids_matrix -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (48) ids_array -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (49) ids_single -> . ID

    READ            shift and go to state 66
    WRITE           shift and go to state 67
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70
    RETURN          shift and go to state 71
    ID              shift and go to state 72
    CLOSE_BRACES    reduce using rule 137 (empty -> .)

    assignment                     shift and go to state 58
    statements                     shift and go to state 110
    read                           shift and go to state 59
    write                          shift and go to state 60
    condition                      shift and go to state 61
    return                         shift and go to state 62
    func_call                      shift and go to state 63
    empty                          shift and go to state 64
    ids                            shift and go to state 65
    ids_matrix                     shift and go to state 73
    ids_array                      shift and go to state 74
    ids_single                     shift and go to state 75

state 85

    (51) statements -> read SEMICOLON . statements
    (50) statements -> . assignment SEMICOLON statements
    (51) statements -> . read SEMICOLON statements
    (52) statements -> . write SEMICOLON statements
    (53) statements -> . condition statements
    (54) statements -> . return SEMICOLON statements
    (55) statements -> . func_call SEMICOLON statements
    (56) statements -> . empty
    (57) assignment -> . ids ASSIGN expressions
    (58) read -> . READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN
    (62) write -> . WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (63) write -> . WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN
    (70) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (71) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
    (72) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
    (73) condition -> . FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (83) return -> . RETURN OPEN_PAREN expressions CLOSE_PAREN g_quad_return
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end
    (137) empty -> .
    (44) ids -> . ids_matrix
    (45) ids -> . ids_array
    (46) ids -> . ids_single
    (47) ids_matrix -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (48) ids_array -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (49) ids_single -> . ID

    READ            shift and go to state 66
    WRITE           shift and go to state 67
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70
    RETURN          shift and go to state 71
    ID              shift and go to state 72
    CLOSE_BRACES    reduce using rule 137 (empty -> .)

    read                           shift and go to state 59
    statements                     shift and go to state 111
    assignment                     shift and go to state 58
    write                          shift and go to state 60
    condition                      shift and go to state 61
    return                         shift and go to state 62
    func_call                      shift and go to state 63
    empty                          shift and go to state 64
    ids                            shift and go to state 65
    ids_matrix                     shift and go to state 73
    ids_array                      shift and go to state 74
    ids_single                     shift and go to state 75

state 86

    (52) statements -> write SEMICOLON . statements
    (50) statements -> . assignment SEMICOLON statements
    (51) statements -> . read SEMICOLON statements
    (52) statements -> . write SEMICOLON statements
    (53) statements -> . condition statements
    (54) statements -> . return SEMICOLON statements
    (55) statements -> . func_call SEMICOLON statements
    (56) statements -> . empty
    (57) assignment -> . ids ASSIGN expressions
    (58) read -> . READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN
    (62) write -> . WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (63) write -> . WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN
    (70) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (71) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
    (72) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
    (73) condition -> . FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (83) return -> . RETURN OPEN_PAREN expressions CLOSE_PAREN g_quad_return
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end
    (137) empty -> .
    (44) ids -> . ids_matrix
    (45) ids -> . ids_array
    (46) ids -> . ids_single
    (47) ids_matrix -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (48) ids_array -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (49) ids_single -> . ID

    READ            shift and go to state 66
    WRITE           shift and go to state 67
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70
    RETURN          shift and go to state 71
    ID              shift and go to state 72
    CLOSE_BRACES    reduce using rule 137 (empty -> .)

    write                          shift and go to state 60
    statements                     shift and go to state 112
    assignment                     shift and go to state 58
    read                           shift and go to state 59
    condition                      shift and go to state 61
    return                         shift and go to state 62
    func_call                      shift and go to state 63
    empty                          shift and go to state 64
    ids                            shift and go to state 65
    ids_matrix                     shift and go to state 73
    ids_array                      shift and go to state 74
    ids_single                     shift and go to state 75

state 87

    (53) statements -> condition statements .

    CLOSE_BRACES    reduce using rule 53 (statements -> condition statements .)


state 88

    (54) statements -> return SEMICOLON . statements
    (50) statements -> . assignment SEMICOLON statements
    (51) statements -> . read SEMICOLON statements
    (52) statements -> . write SEMICOLON statements
    (53) statements -> . condition statements
    (54) statements -> . return SEMICOLON statements
    (55) statements -> . func_call SEMICOLON statements
    (56) statements -> . empty
    (57) assignment -> . ids ASSIGN expressions
    (58) read -> . READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN
    (62) write -> . WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (63) write -> . WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN
    (70) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (71) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
    (72) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
    (73) condition -> . FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (83) return -> . RETURN OPEN_PAREN expressions CLOSE_PAREN g_quad_return
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end
    (137) empty -> .
    (44) ids -> . ids_matrix
    (45) ids -> . ids_array
    (46) ids -> . ids_single
    (47) ids_matrix -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (48) ids_array -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (49) ids_single -> . ID

    READ            shift and go to state 66
    WRITE           shift and go to state 67
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70
    RETURN          shift and go to state 71
    ID              shift and go to state 72
    CLOSE_BRACES    reduce using rule 137 (empty -> .)

    return                         shift and go to state 62
    statements                     shift and go to state 113
    assignment                     shift and go to state 58
    read                           shift and go to state 59
    write                          shift and go to state 60
    condition                      shift and go to state 61
    func_call                      shift and go to state 63
    empty                          shift and go to state 64
    ids                            shift and go to state 65
    ids_matrix                     shift and go to state 73
    ids_array                      shift and go to state 74
    ids_single                     shift and go to state 75

state 89

    (55) statements -> func_call SEMICOLON . statements
    (50) statements -> . assignment SEMICOLON statements
    (51) statements -> . read SEMICOLON statements
    (52) statements -> . write SEMICOLON statements
    (53) statements -> . condition statements
    (54) statements -> . return SEMICOLON statements
    (55) statements -> . func_call SEMICOLON statements
    (56) statements -> . empty
    (57) assignment -> . ids ASSIGN expressions
    (58) read -> . READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN
    (62) write -> . WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (63) write -> . WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN
    (70) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if
    (71) condition -> . IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
    (72) condition -> . WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while
    (73) condition -> . FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (83) return -> . RETURN OPEN_PAREN expressions CLOSE_PAREN g_quad_return
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end
    (137) empty -> .
    (44) ids -> . ids_matrix
    (45) ids -> . ids_array
    (46) ids -> . ids_single
    (47) ids_matrix -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (48) ids_array -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (49) ids_single -> . ID

    READ            shift and go to state 66
    WRITE           shift and go to state 67
    IF              shift and go to state 68
    WHILE           shift and go to state 69
    FOR             shift and go to state 70
    RETURN          shift and go to state 71
    ID              shift and go to state 72
    CLOSE_BRACES    reduce using rule 137 (empty -> .)

    func_call                      shift and go to state 63
    statements                     shift and go to state 114
    assignment                     shift and go to state 58
    read                           shift and go to state 59
    write                          shift and go to state 60
    condition                      shift and go to state 61
    return                         shift and go to state 62
    empty                          shift and go to state 64
    ids                            shift and go to state 65
    ids_matrix                     shift and go to state 73
    ids_array                      shift and go to state 74
    ids_single                     shift and go to state 75

state 90

    (57) assignment -> ids ASSIGN . expressions
    (95) expressions -> . expressions_comp
    (96) expressions_comp -> . expression_comp_2
    (97) expressions_comp -> . expression_comp_2 OR expressions_comp
    (98) expression_comp_2 -> . expression_comp_3
    (99) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (100) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (101) expression_comp_3 -> . exp
    (109) exp -> . term g_quad_exp_as_alone
    (110) exp -> . term g_quad_exp_as exp_comp
    (115) term -> . factor g_quad_exp_md_alone
    (116) term -> . factor g_quad_exp_md term_comp
    (122) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (123) factor -> . variable
    (124) factor -> . func_call
    (125) factor -> . CT_INT add_ct_int
    (126) factor -> . CT_FLOAT add_ct_float
    (127) factor -> . CT_CHAR add_ct_char
    (133) variable -> . ID add_id
    (134) variable -> . ID dim
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end

    OPEN_PAREN      shift and go to state 122
    CT_INT          shift and go to state 125
    CT_FLOAT        shift and go to state 126
    CT_CHAR         shift and go to state 127
    ID              shift and go to state 128

    expressions                    shift and go to state 115
    expressions_comp               shift and go to state 116
    expression_comp_2              shift and go to state 117
    expression_comp_3              shift and go to state 118
    exp                            shift and go to state 119
    term                           shift and go to state 120
    factor                         shift and go to state 121
    variable                       shift and go to state 123
    func_call                      shift and go to state 124

state 91

    (58) read -> READ OPEN_PAREN . ids g_quad_read read_comp CLOSE_PAREN
    (44) ids -> . ids_matrix
    (45) ids -> . ids_array
    (46) ids -> . ids_single
    (47) ids_matrix -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (48) ids_array -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (49) ids_single -> . ID

    ID              shift and go to state 96

    ids                            shift and go to state 129
    ids_matrix                     shift and go to state 73
    ids_array                      shift and go to state 74
    ids_single                     shift and go to state 75

state 92

    (62) write -> WRITE OPEN_PAREN . CT_STRING g_quad_write_str write_comp CLOSE_PAREN
    (63) write -> WRITE OPEN_PAREN . expressions g_quad_write write_comp CLOSE_PAREN
    (95) expressions -> . expressions_comp
    (96) expressions_comp -> . expression_comp_2
    (97) expressions_comp -> . expression_comp_2 OR expressions_comp
    (98) expression_comp_2 -> . expression_comp_3
    (99) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (100) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (101) expression_comp_3 -> . exp
    (109) exp -> . term g_quad_exp_as_alone
    (110) exp -> . term g_quad_exp_as exp_comp
    (115) term -> . factor g_quad_exp_md_alone
    (116) term -> . factor g_quad_exp_md term_comp
    (122) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (123) factor -> . variable
    (124) factor -> . func_call
    (125) factor -> . CT_INT add_ct_int
    (126) factor -> . CT_FLOAT add_ct_float
    (127) factor -> . CT_CHAR add_ct_char
    (133) variable -> . ID add_id
    (134) variable -> . ID dim
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end

    CT_STRING       shift and go to state 130
    OPEN_PAREN      shift and go to state 122
    CT_INT          shift and go to state 125
    CT_FLOAT        shift and go to state 126
    CT_CHAR         shift and go to state 127
    ID              shift and go to state 128

    expressions                    shift and go to state 131
    expressions_comp               shift and go to state 116
    expression_comp_2              shift and go to state 117
    expression_comp_3              shift and go to state 118
    exp                            shift and go to state 119
    term                           shift and go to state 120
    factor                         shift and go to state 121
    variable                       shift and go to state 123
    func_call                      shift and go to state 124

state 93

    (70) condition -> IF OPEN_PAREN . expressions CLOSE_PAREN g_if_quad THEN block end_if
    (71) condition -> IF OPEN_PAREN . expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if
    (95) expressions -> . expressions_comp
    (96) expressions_comp -> . expression_comp_2
    (97) expressions_comp -> . expression_comp_2 OR expressions_comp
    (98) expression_comp_2 -> . expression_comp_3
    (99) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (100) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (101) expression_comp_3 -> . exp
    (109) exp -> . term g_quad_exp_as_alone
    (110) exp -> . term g_quad_exp_as exp_comp
    (115) term -> . factor g_quad_exp_md_alone
    (116) term -> . factor g_quad_exp_md term_comp
    (122) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (123) factor -> . variable
    (124) factor -> . func_call
    (125) factor -> . CT_INT add_ct_int
    (126) factor -> . CT_FLOAT add_ct_float
    (127) factor -> . CT_CHAR add_ct_char
    (133) variable -> . ID add_id
    (134) variable -> . ID dim
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end

    OPEN_PAREN      shift and go to state 122
    CT_INT          shift and go to state 125
    CT_FLOAT        shift and go to state 126
    CT_CHAR         shift and go to state 127
    ID              shift and go to state 128

    expressions                    shift and go to state 132
    expressions_comp               shift and go to state 116
    expression_comp_2              shift and go to state 117
    expression_comp_3              shift and go to state 118
    exp                            shift and go to state 119
    term                           shift and go to state 120
    factor                         shift and go to state 121
    variable                       shift and go to state 123
    func_call                      shift and go to state 124

state 94

    (72) condition -> WHILE while_jump . OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while

    OPEN_PAREN      shift and go to state 133


state 95

    (73) condition -> FOR ids . validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for
    (79) validate_for -> .

    ASSIGN          reduce using rule 79 (validate_for -> .)

    validate_for                   shift and go to state 134

state 96

    (47) ids_matrix -> ID . OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (48) ids_array -> ID . OPEN_BRACKETS exp CLOSE_BRACKETS
    (49) ids_single -> ID .

    OPEN_BRACKETS   shift and go to state 99
    ASSIGN          reduce using rule 49 (ids_single -> ID .)
    COMMA           reduce using rule 49 (ids_single -> ID .)
    CLOSE_PAREN     reduce using rule 49 (ids_single -> ID .)


state 97

    (83) return -> RETURN OPEN_PAREN . expressions CLOSE_PAREN g_quad_return
    (95) expressions -> . expressions_comp
    (96) expressions_comp -> . expression_comp_2
    (97) expressions_comp -> . expression_comp_2 OR expressions_comp
    (98) expression_comp_2 -> . expression_comp_3
    (99) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (100) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (101) expression_comp_3 -> . exp
    (109) exp -> . term g_quad_exp_as_alone
    (110) exp -> . term g_quad_exp_as exp_comp
    (115) term -> . factor g_quad_exp_md_alone
    (116) term -> . factor g_quad_exp_md term_comp
    (122) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (123) factor -> . variable
    (124) factor -> . func_call
    (125) factor -> . CT_INT add_ct_int
    (126) factor -> . CT_FLOAT add_ct_float
    (127) factor -> . CT_CHAR add_ct_char
    (133) variable -> . ID add_id
    (134) variable -> . ID dim
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end

    OPEN_PAREN      shift and go to state 122
    CT_INT          shift and go to state 125
    CT_FLOAT        shift and go to state 126
    CT_CHAR         shift and go to state 127
    ID              shift and go to state 128

    expressions                    shift and go to state 135
    expressions_comp               shift and go to state 116
    expression_comp_2              shift and go to state 117
    expression_comp_3              shift and go to state 118
    exp                            shift and go to state 119
    term                           shift and go to state 120
    factor                         shift and go to state 121
    variable                       shift and go to state 123
    func_call                      shift and go to state 124

state 98

    (85) func_call -> ID verify_function_exists . OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end

    OPEN_PAREN      shift and go to state 136


state 99

    (47) ids_matrix -> ID OPEN_BRACKETS . exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (48) ids_array -> ID OPEN_BRACKETS . exp CLOSE_BRACKETS
    (109) exp -> . term g_quad_exp_as_alone
    (110) exp -> . term g_quad_exp_as exp_comp
    (115) term -> . factor g_quad_exp_md_alone
    (116) term -> . factor g_quad_exp_md term_comp
    (122) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (123) factor -> . variable
    (124) factor -> . func_call
    (125) factor -> . CT_INT add_ct_int
    (126) factor -> . CT_FLOAT add_ct_float
    (127) factor -> . CT_CHAR add_ct_char
    (133) variable -> . ID add_id
    (134) variable -> . ID dim
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end

    OPEN_PAREN      shift and go to state 122
    CT_INT          shift and go to state 125
    CT_FLOAT        shift and go to state 126
    CT_CHAR         shift and go to state 127
    ID              shift and go to state 128

    exp                            shift and go to state 137
    term                           shift and go to state 120
    factor                         shift and go to state 121
    variable                       shift and go to state 123
    func_call                      shift and go to state 124

state 100

    (7) funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount . vars count_local_vars block end_funcs funcs
    (26) vars -> . VARS var_comp
    (27) vars -> . empty
    (137) empty -> .

    VARS            shift and go to state 8
    OPEN_BRACES     reduce using rule 137 (empty -> .)

    vars                           shift and go to state 138
    empty                          shift and go to state 9

state 101

    (14) funcs_params -> var_type variable_params funcs_params_comp .

    CLOSE_PAREN     reduce using rule 14 (funcs_params -> var_type variable_params funcs_params_comp .)


state 102

    (16) funcs_params_comp -> COMMA . var_type variable_params funcs_params_comp
    (23) var_type -> . INT
    (24) var_type -> . FLOAT
    (25) var_type -> . CHAR

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

    var_type                       shift and go to state 139

state 103

    (17) funcs_params_comp -> empty .

    CLOSE_PAREN     reduce using rule 17 (funcs_params_comp -> empty .)


state 104

    (19) variable_params -> ID dim .

    COMMA           reduce using rule 19 (variable_params -> ID dim .)
    CLOSE_PAREN     reduce using rule 19 (variable_params -> ID dim .)


state 105

    (136) dim -> OPEN_BRACKETS . exp CLOSE_BRACKETS
    (109) exp -> . term g_quad_exp_as_alone
    (110) exp -> . term g_quad_exp_as exp_comp
    (115) term -> . factor g_quad_exp_md_alone
    (116) term -> . factor g_quad_exp_md term_comp
    (122) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (123) factor -> . variable
    (124) factor -> . func_call
    (125) factor -> . CT_INT add_ct_int
    (126) factor -> . CT_FLOAT add_ct_float
    (127) factor -> . CT_CHAR add_ct_char
    (133) variable -> . ID add_id
    (134) variable -> . ID dim
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end

    OPEN_PAREN      shift and go to state 122
    CT_INT          shift and go to state 125
    CT_FLOAT        shift and go to state 126
    CT_CHAR         shift and go to state 127
    ID              shift and go to state 128

    exp                            shift and go to state 140
    term                           shift and go to state 120
    factor                         shift and go to state 121
    variable                       shift and go to state 123
    func_call                      shift and go to state 124

state 106

    (12) funcs_comp -> ID add_module . OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs

    OPEN_PAREN      shift and go to state 141


state 107

    (33) var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .

    VOID            reduce using rule 33 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)
    INT             reduce using rule 33 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)
    FLOAT           reduce using rule 33 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)
    CHAR            reduce using rule 33 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)
    MAIN            reduce using rule 33 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)
    OPEN_BRACES     reduce using rule 33 (var_comp_recursive -> var_type ids_dec var_comp_2 var_comp_final .)


state 108

    (34) var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON . var_comp_recursive
    (35) var_comp_final -> SEMICOLON .
    (37) var_module_trans -> SEMICOLON . var_type MODULE funcs_comp
    (33) var_comp_recursive -> . var_type ids_dec var_comp_2 var_comp_final
    (34) var_comp_recursive -> . var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive
    (23) var_type -> . INT
    (24) var_type -> . FLOAT
    (25) var_type -> . CHAR

  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
    VOID            reduce using rule 35 (var_comp_final -> SEMICOLON .)
    MAIN            reduce using rule 35 (var_comp_final -> SEMICOLON .)
    OPEN_BRACES     reduce using rule 35 (var_comp_final -> SEMICOLON .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

  ! INT             [ reduce using rule 35 (var_comp_final -> SEMICOLON .) ]
  ! FLOAT           [ reduce using rule 35 (var_comp_final -> SEMICOLON .) ]
  ! CHAR            [ reduce using rule 35 (var_comp_final -> SEMICOLON .) ]

    var_type                       shift and go to state 44
    var_comp_recursive             shift and go to state 142

state 109

    (41) ids_dec_matrix -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS .

    COMMA           reduce using rule 41 (ids_dec_matrix -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS .)
    SEMICOLON       reduce using rule 41 (ids_dec_matrix -> ID OPEN_BRACKETS CT_INT CLOSE_BRACKETS OPEN_BRACKETS CT_INT CLOSE_BRACKETS .)


state 110

    (50) statements -> assignment SEMICOLON statements .

    CLOSE_BRACES    reduce using rule 50 (statements -> assignment SEMICOLON statements .)


state 111

    (51) statements -> read SEMICOLON statements .

    CLOSE_BRACES    reduce using rule 51 (statements -> read SEMICOLON statements .)


state 112

    (52) statements -> write SEMICOLON statements .

    CLOSE_BRACES    reduce using rule 52 (statements -> write SEMICOLON statements .)


state 113

    (54) statements -> return SEMICOLON statements .

    CLOSE_BRACES    reduce using rule 54 (statements -> return SEMICOLON statements .)


state 114

    (55) statements -> func_call SEMICOLON statements .

    CLOSE_BRACES    reduce using rule 55 (statements -> func_call SEMICOLON statements .)


state 115

    (57) assignment -> ids ASSIGN expressions .

    SEMICOLON       reduce using rule 57 (assignment -> ids ASSIGN expressions .)


state 116

    (95) expressions -> expressions_comp .

    SEMICOLON       reduce using rule 95 (expressions -> expressions_comp .)
    COMMA           reduce using rule 95 (expressions -> expressions_comp .)
    CLOSE_PAREN     reduce using rule 95 (expressions -> expressions_comp .)
    TO              reduce using rule 95 (expressions -> expressions_comp .)
    OPEN_PAREN      reduce using rule 95 (expressions -> expressions_comp .)
    CT_INT          reduce using rule 95 (expressions -> expressions_comp .)
    CT_FLOAT        reduce using rule 95 (expressions -> expressions_comp .)
    CT_CHAR         reduce using rule 95 (expressions -> expressions_comp .)
    ID              reduce using rule 95 (expressions -> expressions_comp .)
    DO              reduce using rule 95 (expressions -> expressions_comp .)


state 117

    (96) expressions_comp -> expression_comp_2 .
    (97) expressions_comp -> expression_comp_2 . OR expressions_comp

    SEMICOLON       reduce using rule 96 (expressions_comp -> expression_comp_2 .)
    COMMA           reduce using rule 96 (expressions_comp -> expression_comp_2 .)
    CLOSE_PAREN     reduce using rule 96 (expressions_comp -> expression_comp_2 .)
    TO              reduce using rule 96 (expressions_comp -> expression_comp_2 .)
    OPEN_PAREN      reduce using rule 96 (expressions_comp -> expression_comp_2 .)
    CT_INT          reduce using rule 96 (expressions_comp -> expression_comp_2 .)
    CT_FLOAT        reduce using rule 96 (expressions_comp -> expression_comp_2 .)
    CT_CHAR         reduce using rule 96 (expressions_comp -> expression_comp_2 .)
    ID              reduce using rule 96 (expressions_comp -> expression_comp_2 .)
    DO              reduce using rule 96 (expressions_comp -> expression_comp_2 .)
    OR              shift and go to state 143


state 118

    (98) expression_comp_2 -> expression_comp_3 .
    (99) expression_comp_2 -> expression_comp_3 . AND expression_comp_2

    OR              reduce using rule 98 (expression_comp_2 -> expression_comp_3 .)
    SEMICOLON       reduce using rule 98 (expression_comp_2 -> expression_comp_3 .)
    COMMA           reduce using rule 98 (expression_comp_2 -> expression_comp_3 .)
    CLOSE_PAREN     reduce using rule 98 (expression_comp_2 -> expression_comp_3 .)
    TO              reduce using rule 98 (expression_comp_2 -> expression_comp_3 .)
    OPEN_PAREN      reduce using rule 98 (expression_comp_2 -> expression_comp_3 .)
    CT_INT          reduce using rule 98 (expression_comp_2 -> expression_comp_3 .)
    CT_FLOAT        reduce using rule 98 (expression_comp_2 -> expression_comp_3 .)
    CT_CHAR         reduce using rule 98 (expression_comp_2 -> expression_comp_3 .)
    ID              reduce using rule 98 (expression_comp_2 -> expression_comp_3 .)
    DO              reduce using rule 98 (expression_comp_2 -> expression_comp_3 .)
    AND             shift and go to state 144


state 119

    (100) expression_comp_3 -> exp . expressions_op exp g_quad_logic
    (101) expression_comp_3 -> exp .
    (103) expressions_op -> . LESS_THAN add_op
    (104) expressions_op -> . LESS_THAN_EQUAL add_op
    (105) expressions_op -> . MORE_THAN add_op
    (106) expressions_op -> . MORE_THAN_EQUAL add_op
    (107) expressions_op -> . EQUALS add_op
    (108) expressions_op -> . NOT_EQUALS add_op

    AND             reduce using rule 101 (expression_comp_3 -> exp .)
    OR              reduce using rule 101 (expression_comp_3 -> exp .)
    SEMICOLON       reduce using rule 101 (expression_comp_3 -> exp .)
    COMMA           reduce using rule 101 (expression_comp_3 -> exp .)
    CLOSE_PAREN     reduce using rule 101 (expression_comp_3 -> exp .)
    TO              reduce using rule 101 (expression_comp_3 -> exp .)
    OPEN_PAREN      reduce using rule 101 (expression_comp_3 -> exp .)
    CT_INT          reduce using rule 101 (expression_comp_3 -> exp .)
    CT_FLOAT        reduce using rule 101 (expression_comp_3 -> exp .)
    CT_CHAR         reduce using rule 101 (expression_comp_3 -> exp .)
    ID              reduce using rule 101 (expression_comp_3 -> exp .)
    DO              reduce using rule 101 (expression_comp_3 -> exp .)
    LESS_THAN       shift and go to state 146
    LESS_THAN_EQUAL shift and go to state 147
    MORE_THAN       shift and go to state 148
    MORE_THAN_EQUAL shift and go to state 149
    EQUALS          shift and go to state 150
    NOT_EQUALS      shift and go to state 151

    expressions_op                 shift and go to state 145

state 120

    (109) exp -> term . g_quad_exp_as_alone
    (110) exp -> term . g_quad_exp_as exp_comp
    (112) g_quad_exp_as_alone -> .
    (111) g_quad_exp_as -> .

    LESS_THAN       reduce using rule 112 (g_quad_exp_as_alone -> .)
    LESS_THAN_EQUAL reduce using rule 112 (g_quad_exp_as_alone -> .)
    MORE_THAN       reduce using rule 112 (g_quad_exp_as_alone -> .)
    MORE_THAN_EQUAL reduce using rule 112 (g_quad_exp_as_alone -> .)
    EQUALS          reduce using rule 112 (g_quad_exp_as_alone -> .)
    NOT_EQUALS      reduce using rule 112 (g_quad_exp_as_alone -> .)
    AND             reduce using rule 112 (g_quad_exp_as_alone -> .)
    OR              reduce using rule 112 (g_quad_exp_as_alone -> .)
    SEMICOLON       reduce using rule 112 (g_quad_exp_as_alone -> .)
    COMMA           reduce using rule 112 (g_quad_exp_as_alone -> .)
    CLOSE_PAREN     reduce using rule 112 (g_quad_exp_as_alone -> .)
    CLOSE_BRACKETS  reduce using rule 112 (g_quad_exp_as_alone -> .)
    TO              reduce using rule 112 (g_quad_exp_as_alone -> .)
    OPEN_PAREN      reduce using rule 112 (g_quad_exp_as_alone -> .)
    CT_INT          reduce using rule 112 (g_quad_exp_as_alone -> .)
    CT_FLOAT        reduce using rule 112 (g_quad_exp_as_alone -> .)
    CT_CHAR         reduce using rule 112 (g_quad_exp_as_alone -> .)
    ID              reduce using rule 112 (g_quad_exp_as_alone -> .)
    DO              reduce using rule 112 (g_quad_exp_as_alone -> .)
    PLUS            reduce using rule 111 (g_quad_exp_as -> .)
    MINUS           reduce using rule 111 (g_quad_exp_as -> .)

    g_quad_exp_as_alone            shift and go to state 152
    g_quad_exp_as                  shift and go to state 153

state 121

    (115) term -> factor . g_quad_exp_md_alone
    (116) term -> factor . g_quad_exp_md term_comp
    (118) g_quad_exp_md_alone -> .
    (117) g_quad_exp_md -> .

    PLUS            reduce using rule 118 (g_quad_exp_md_alone -> .)
    MINUS           reduce using rule 118 (g_quad_exp_md_alone -> .)
    LESS_THAN       reduce using rule 118 (g_quad_exp_md_alone -> .)
    LESS_THAN_EQUAL reduce using rule 118 (g_quad_exp_md_alone -> .)
    MORE_THAN       reduce using rule 118 (g_quad_exp_md_alone -> .)
    MORE_THAN_EQUAL reduce using rule 118 (g_quad_exp_md_alone -> .)
    EQUALS          reduce using rule 118 (g_quad_exp_md_alone -> .)
    NOT_EQUALS      reduce using rule 118 (g_quad_exp_md_alone -> .)
    AND             reduce using rule 118 (g_quad_exp_md_alone -> .)
    OR              reduce using rule 118 (g_quad_exp_md_alone -> .)
    SEMICOLON       reduce using rule 118 (g_quad_exp_md_alone -> .)
    COMMA           reduce using rule 118 (g_quad_exp_md_alone -> .)
    CLOSE_PAREN     reduce using rule 118 (g_quad_exp_md_alone -> .)
    CLOSE_BRACKETS  reduce using rule 118 (g_quad_exp_md_alone -> .)
    TO              reduce using rule 118 (g_quad_exp_md_alone -> .)
    OPEN_PAREN      reduce using rule 118 (g_quad_exp_md_alone -> .)
    CT_INT          reduce using rule 118 (g_quad_exp_md_alone -> .)
    CT_FLOAT        reduce using rule 118 (g_quad_exp_md_alone -> .)
    CT_CHAR         reduce using rule 118 (g_quad_exp_md_alone -> .)
    ID              reduce using rule 118 (g_quad_exp_md_alone -> .)
    DO              reduce using rule 118 (g_quad_exp_md_alone -> .)
    MULTIPLIES      reduce using rule 117 (g_quad_exp_md -> .)
    DIVIDE          reduce using rule 117 (g_quad_exp_md -> .)

    g_quad_exp_md_alone            shift and go to state 154
    g_quad_exp_md                  shift and go to state 155

state 122

    (122) factor -> OPEN_PAREN . add_fake expressions CLOSE_PAREN rem_fake
    (128) add_fake -> .

    OPEN_PAREN      reduce using rule 128 (add_fake -> .)
    CT_INT          reduce using rule 128 (add_fake -> .)
    CT_FLOAT        reduce using rule 128 (add_fake -> .)
    CT_CHAR         reduce using rule 128 (add_fake -> .)
    ID              reduce using rule 128 (add_fake -> .)

    add_fake                       shift and go to state 156

state 123

    (123) factor -> variable .

    MULTIPLIES      reduce using rule 123 (factor -> variable .)
    DIVIDE          reduce using rule 123 (factor -> variable .)
    PLUS            reduce using rule 123 (factor -> variable .)
    MINUS           reduce using rule 123 (factor -> variable .)
    LESS_THAN       reduce using rule 123 (factor -> variable .)
    LESS_THAN_EQUAL reduce using rule 123 (factor -> variable .)
    MORE_THAN       reduce using rule 123 (factor -> variable .)
    MORE_THAN_EQUAL reduce using rule 123 (factor -> variable .)
    EQUALS          reduce using rule 123 (factor -> variable .)
    NOT_EQUALS      reduce using rule 123 (factor -> variable .)
    AND             reduce using rule 123 (factor -> variable .)
    OR              reduce using rule 123 (factor -> variable .)
    SEMICOLON       reduce using rule 123 (factor -> variable .)
    COMMA           reduce using rule 123 (factor -> variable .)
    CLOSE_PAREN     reduce using rule 123 (factor -> variable .)
    CLOSE_BRACKETS  reduce using rule 123 (factor -> variable .)
    TO              reduce using rule 123 (factor -> variable .)
    OPEN_PAREN      reduce using rule 123 (factor -> variable .)
    CT_INT          reduce using rule 123 (factor -> variable .)
    CT_FLOAT        reduce using rule 123 (factor -> variable .)
    CT_CHAR         reduce using rule 123 (factor -> variable .)
    ID              reduce using rule 123 (factor -> variable .)
    DO              reduce using rule 123 (factor -> variable .)


state 124

    (124) factor -> func_call .

    MULTIPLIES      reduce using rule 124 (factor -> func_call .)
    DIVIDE          reduce using rule 124 (factor -> func_call .)
    PLUS            reduce using rule 124 (factor -> func_call .)
    MINUS           reduce using rule 124 (factor -> func_call .)
    LESS_THAN       reduce using rule 124 (factor -> func_call .)
    LESS_THAN_EQUAL reduce using rule 124 (factor -> func_call .)
    MORE_THAN       reduce using rule 124 (factor -> func_call .)
    MORE_THAN_EQUAL reduce using rule 124 (factor -> func_call .)
    EQUALS          reduce using rule 124 (factor -> func_call .)
    NOT_EQUALS      reduce using rule 124 (factor -> func_call .)
    AND             reduce using rule 124 (factor -> func_call .)
    OR              reduce using rule 124 (factor -> func_call .)
    SEMICOLON       reduce using rule 124 (factor -> func_call .)
    COMMA           reduce using rule 124 (factor -> func_call .)
    CLOSE_PAREN     reduce using rule 124 (factor -> func_call .)
    CLOSE_BRACKETS  reduce using rule 124 (factor -> func_call .)
    TO              reduce using rule 124 (factor -> func_call .)
    OPEN_PAREN      reduce using rule 124 (factor -> func_call .)
    CT_INT          reduce using rule 124 (factor -> func_call .)
    CT_FLOAT        reduce using rule 124 (factor -> func_call .)
    CT_CHAR         reduce using rule 124 (factor -> func_call .)
    ID              reduce using rule 124 (factor -> func_call .)
    DO              reduce using rule 124 (factor -> func_call .)


state 125

    (125) factor -> CT_INT . add_ct_int
    (130) add_ct_int -> .

    MULTIPLIES      reduce using rule 130 (add_ct_int -> .)
    DIVIDE          reduce using rule 130 (add_ct_int -> .)
    PLUS            reduce using rule 130 (add_ct_int -> .)
    MINUS           reduce using rule 130 (add_ct_int -> .)
    LESS_THAN       reduce using rule 130 (add_ct_int -> .)
    LESS_THAN_EQUAL reduce using rule 130 (add_ct_int -> .)
    MORE_THAN       reduce using rule 130 (add_ct_int -> .)
    MORE_THAN_EQUAL reduce using rule 130 (add_ct_int -> .)
    EQUALS          reduce using rule 130 (add_ct_int -> .)
    NOT_EQUALS      reduce using rule 130 (add_ct_int -> .)
    AND             reduce using rule 130 (add_ct_int -> .)
    OR              reduce using rule 130 (add_ct_int -> .)
    SEMICOLON       reduce using rule 130 (add_ct_int -> .)
    COMMA           reduce using rule 130 (add_ct_int -> .)
    CLOSE_PAREN     reduce using rule 130 (add_ct_int -> .)
    CLOSE_BRACKETS  reduce using rule 130 (add_ct_int -> .)
    TO              reduce using rule 130 (add_ct_int -> .)
    OPEN_PAREN      reduce using rule 130 (add_ct_int -> .)
    CT_INT          reduce using rule 130 (add_ct_int -> .)
    CT_FLOAT        reduce using rule 130 (add_ct_int -> .)
    CT_CHAR         reduce using rule 130 (add_ct_int -> .)
    ID              reduce using rule 130 (add_ct_int -> .)
    DO              reduce using rule 130 (add_ct_int -> .)

    add_ct_int                     shift and go to state 157

state 126

    (126) factor -> CT_FLOAT . add_ct_float
    (131) add_ct_float -> .

    MULTIPLIES      reduce using rule 131 (add_ct_float -> .)
    DIVIDE          reduce using rule 131 (add_ct_float -> .)
    PLUS            reduce using rule 131 (add_ct_float -> .)
    MINUS           reduce using rule 131 (add_ct_float -> .)
    LESS_THAN       reduce using rule 131 (add_ct_float -> .)
    LESS_THAN_EQUAL reduce using rule 131 (add_ct_float -> .)
    MORE_THAN       reduce using rule 131 (add_ct_float -> .)
    MORE_THAN_EQUAL reduce using rule 131 (add_ct_float -> .)
    EQUALS          reduce using rule 131 (add_ct_float -> .)
    NOT_EQUALS      reduce using rule 131 (add_ct_float -> .)
    AND             reduce using rule 131 (add_ct_float -> .)
    OR              reduce using rule 131 (add_ct_float -> .)
    SEMICOLON       reduce using rule 131 (add_ct_float -> .)
    COMMA           reduce using rule 131 (add_ct_float -> .)
    CLOSE_PAREN     reduce using rule 131 (add_ct_float -> .)
    CLOSE_BRACKETS  reduce using rule 131 (add_ct_float -> .)
    TO              reduce using rule 131 (add_ct_float -> .)
    OPEN_PAREN      reduce using rule 131 (add_ct_float -> .)
    CT_INT          reduce using rule 131 (add_ct_float -> .)
    CT_FLOAT        reduce using rule 131 (add_ct_float -> .)
    CT_CHAR         reduce using rule 131 (add_ct_float -> .)
    ID              reduce using rule 131 (add_ct_float -> .)
    DO              reduce using rule 131 (add_ct_float -> .)

    add_ct_float                   shift and go to state 158

state 127

    (127) factor -> CT_CHAR . add_ct_char
    (132) add_ct_char -> .

    MULTIPLIES      reduce using rule 132 (add_ct_char -> .)
    DIVIDE          reduce using rule 132 (add_ct_char -> .)
    PLUS            reduce using rule 132 (add_ct_char -> .)
    MINUS           reduce using rule 132 (add_ct_char -> .)
    LESS_THAN       reduce using rule 132 (add_ct_char -> .)
    LESS_THAN_EQUAL reduce using rule 132 (add_ct_char -> .)
    MORE_THAN       reduce using rule 132 (add_ct_char -> .)
    MORE_THAN_EQUAL reduce using rule 132 (add_ct_char -> .)
    EQUALS          reduce using rule 132 (add_ct_char -> .)
    NOT_EQUALS      reduce using rule 132 (add_ct_char -> .)
    AND             reduce using rule 132 (add_ct_char -> .)
    OR              reduce using rule 132 (add_ct_char -> .)
    SEMICOLON       reduce using rule 132 (add_ct_char -> .)
    COMMA           reduce using rule 132 (add_ct_char -> .)
    CLOSE_PAREN     reduce using rule 132 (add_ct_char -> .)
    CLOSE_BRACKETS  reduce using rule 132 (add_ct_char -> .)
    TO              reduce using rule 132 (add_ct_char -> .)
    OPEN_PAREN      reduce using rule 132 (add_ct_char -> .)
    CT_INT          reduce using rule 132 (add_ct_char -> .)
    CT_FLOAT        reduce using rule 132 (add_ct_char -> .)
    CT_CHAR         reduce using rule 132 (add_ct_char -> .)
    ID              reduce using rule 132 (add_ct_char -> .)
    DO              reduce using rule 132 (add_ct_char -> .)

    add_ct_char                    shift and go to state 159

state 128

    (133) variable -> ID . add_id
    (134) variable -> ID . dim
    (85) func_call -> ID . verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end
    (135) add_id -> .
    (136) dim -> . OPEN_BRACKETS exp CLOSE_BRACKETS
    (89) verify_function_exists -> .

  ! reduce/reduce conflict for OPEN_PAREN resolved using rule 89 (verify_function_exists -> .)
    MULTIPLIES      reduce using rule 135 (add_id -> .)
    DIVIDE          reduce using rule 135 (add_id -> .)
    PLUS            reduce using rule 135 (add_id -> .)
    MINUS           reduce using rule 135 (add_id -> .)
    LESS_THAN       reduce using rule 135 (add_id -> .)
    LESS_THAN_EQUAL reduce using rule 135 (add_id -> .)
    MORE_THAN       reduce using rule 135 (add_id -> .)
    MORE_THAN_EQUAL reduce using rule 135 (add_id -> .)
    EQUALS          reduce using rule 135 (add_id -> .)
    NOT_EQUALS      reduce using rule 135 (add_id -> .)
    AND             reduce using rule 135 (add_id -> .)
    OR              reduce using rule 135 (add_id -> .)
    SEMICOLON       reduce using rule 135 (add_id -> .)
    COMMA           reduce using rule 135 (add_id -> .)
    CLOSE_PAREN     reduce using rule 135 (add_id -> .)
    CLOSE_BRACKETS  reduce using rule 135 (add_id -> .)
    TO              reduce using rule 135 (add_id -> .)
    CT_INT          reduce using rule 135 (add_id -> .)
    CT_FLOAT        reduce using rule 135 (add_id -> .)
    CT_CHAR         reduce using rule 135 (add_id -> .)
    ID              reduce using rule 135 (add_id -> .)
    DO              reduce using rule 135 (add_id -> .)
    OPEN_BRACKETS   shift and go to state 105
    OPEN_PAREN      reduce using rule 89 (verify_function_exists -> .)

  ! OPEN_PAREN      [ reduce using rule 135 (add_id -> .) ]

    add_id                         shift and go to state 160
    dim                            shift and go to state 161
    verify_function_exists         shift and go to state 98

state 129

    (58) read -> READ OPEN_PAREN ids . g_quad_read read_comp CLOSE_PAREN
    (61) g_quad_read -> .

    COMMA           reduce using rule 61 (g_quad_read -> .)
    CLOSE_PAREN     reduce using rule 61 (g_quad_read -> .)

    g_quad_read                    shift and go to state 162

state 130

    (62) write -> WRITE OPEN_PAREN CT_STRING . g_quad_write_str write_comp CLOSE_PAREN
    (67) g_quad_write_str -> .

    COMMA           reduce using rule 67 (g_quad_write_str -> .)
    CLOSE_PAREN     reduce using rule 67 (g_quad_write_str -> .)

    g_quad_write_str               shift and go to state 163

state 131

    (63) write -> WRITE OPEN_PAREN expressions . g_quad_write write_comp CLOSE_PAREN
    (68) g_quad_write -> .

    COMMA           reduce using rule 68 (g_quad_write -> .)
    CLOSE_PAREN     reduce using rule 68 (g_quad_write -> .)

    g_quad_write                   shift and go to state 164

state 132

    (70) condition -> IF OPEN_PAREN expressions . CLOSE_PAREN g_if_quad THEN block end_if
    (71) condition -> IF OPEN_PAREN expressions . CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if

    CLOSE_PAREN     shift and go to state 165


state 133

    (72) condition -> WHILE while_jump OPEN_PAREN . expressions CLOSE_PAREN g_while_quad DO block end_while
    (95) expressions -> . expressions_comp
    (96) expressions_comp -> . expression_comp_2
    (97) expressions_comp -> . expression_comp_2 OR expressions_comp
    (98) expression_comp_2 -> . expression_comp_3
    (99) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (100) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (101) expression_comp_3 -> . exp
    (109) exp -> . term g_quad_exp_as_alone
    (110) exp -> . term g_quad_exp_as exp_comp
    (115) term -> . factor g_quad_exp_md_alone
    (116) term -> . factor g_quad_exp_md term_comp
    (122) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (123) factor -> . variable
    (124) factor -> . func_call
    (125) factor -> . CT_INT add_ct_int
    (126) factor -> . CT_FLOAT add_ct_float
    (127) factor -> . CT_CHAR add_ct_char
    (133) variable -> . ID add_id
    (134) variable -> . ID dim
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end

    OPEN_PAREN      shift and go to state 122
    CT_INT          shift and go to state 125
    CT_FLOAT        shift and go to state 126
    CT_CHAR         shift and go to state 127
    ID              shift and go to state 128

    expressions                    shift and go to state 166
    expressions_comp               shift and go to state 116
    expression_comp_2              shift and go to state 117
    expression_comp_3              shift and go to state 118
    exp                            shift and go to state 119
    term                           shift and go to state 120
    factor                         shift and go to state 121
    variable                       shift and go to state 123
    func_call                      shift and go to state 124

state 134

    (73) condition -> FOR ids validate_for . ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for

    ASSIGN          shift and go to state 167


state 135

    (83) return -> RETURN OPEN_PAREN expressions . CLOSE_PAREN g_quad_return

    CLOSE_PAREN     shift and go to state 168


state 136

    (85) func_call -> ID verify_function_exists OPEN_PAREN . era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end
    (90) era_activation -> .

    COMMA           reduce using rule 90 (era_activation -> .)
    OPEN_PAREN      reduce using rule 90 (era_activation -> .)
    CT_INT          reduce using rule 90 (era_activation -> .)
    CT_FLOAT        reduce using rule 90 (era_activation -> .)
    CT_CHAR         reduce using rule 90 (era_activation -> .)
    ID              reduce using rule 90 (era_activation -> .)
    CLOSE_PAREN     reduce using rule 90 (era_activation -> .)

    era_activation                 shift and go to state 169

state 137

    (47) ids_matrix -> ID OPEN_BRACKETS exp . CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (48) ids_array -> ID OPEN_BRACKETS exp . CLOSE_BRACKETS

    CLOSE_BRACKETS  shift and go to state 170


state 138

    (7) funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars . count_local_vars block end_funcs funcs
    (10) count_local_vars -> .

    OPEN_BRACES     reduce using rule 10 (count_local_vars -> .)

    count_local_vars               shift and go to state 171

state 139

    (16) funcs_params_comp -> COMMA var_type . variable_params funcs_params_comp
    (18) variable_params -> . ID
    (19) variable_params -> . ID dim

    ID              shift and go to state 78

    variable_params                shift and go to state 172

state 140

    (136) dim -> OPEN_BRACKETS exp . CLOSE_BRACKETS

    CLOSE_BRACKETS  shift and go to state 173


state 141

    (12) funcs_comp -> ID add_module OPEN_PAREN . funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs
    (14) funcs_params -> . var_type variable_params funcs_params_comp
    (15) funcs_params -> . empty
    (23) var_type -> . INT
    (24) var_type -> . FLOAT
    (25) var_type -> . CHAR
    (137) empty -> .

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17
    CLOSE_PAREN     reduce using rule 137 (empty -> .)

    funcs_params                   shift and go to state 174
    var_type                       shift and go to state 52
    empty                          shift and go to state 53

state 142

    (34) var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .

    VOID            reduce using rule 34 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    INT             reduce using rule 34 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    FLOAT           reduce using rule 34 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    CHAR            reduce using rule 34 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    MAIN            reduce using rule 34 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)
    OPEN_BRACES     reduce using rule 34 (var_comp_recursive -> var_type ids_dec var_comp_2 SEMICOLON var_comp_recursive .)


state 143

    (97) expressions_comp -> expression_comp_2 OR . expressions_comp
    (96) expressions_comp -> . expression_comp_2
    (97) expressions_comp -> . expression_comp_2 OR expressions_comp
    (98) expression_comp_2 -> . expression_comp_3
    (99) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (100) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (101) expression_comp_3 -> . exp
    (109) exp -> . term g_quad_exp_as_alone
    (110) exp -> . term g_quad_exp_as exp_comp
    (115) term -> . factor g_quad_exp_md_alone
    (116) term -> . factor g_quad_exp_md term_comp
    (122) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (123) factor -> . variable
    (124) factor -> . func_call
    (125) factor -> . CT_INT add_ct_int
    (126) factor -> . CT_FLOAT add_ct_float
    (127) factor -> . CT_CHAR add_ct_char
    (133) variable -> . ID add_id
    (134) variable -> . ID dim
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end

    OPEN_PAREN      shift and go to state 122
    CT_INT          shift and go to state 125
    CT_FLOAT        shift and go to state 126
    CT_CHAR         shift and go to state 127
    ID              shift and go to state 128

    expression_comp_2              shift and go to state 117
    expressions_comp               shift and go to state 175
    expression_comp_3              shift and go to state 118
    exp                            shift and go to state 119
    term                           shift and go to state 120
    factor                         shift and go to state 121
    variable                       shift and go to state 123
    func_call                      shift and go to state 124

state 144

    (99) expression_comp_2 -> expression_comp_3 AND . expression_comp_2
    (98) expression_comp_2 -> . expression_comp_3
    (99) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (100) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (101) expression_comp_3 -> . exp
    (109) exp -> . term g_quad_exp_as_alone
    (110) exp -> . term g_quad_exp_as exp_comp
    (115) term -> . factor g_quad_exp_md_alone
    (116) term -> . factor g_quad_exp_md term_comp
    (122) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (123) factor -> . variable
    (124) factor -> . func_call
    (125) factor -> . CT_INT add_ct_int
    (126) factor -> . CT_FLOAT add_ct_float
    (127) factor -> . CT_CHAR add_ct_char
    (133) variable -> . ID add_id
    (134) variable -> . ID dim
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end

    OPEN_PAREN      shift and go to state 122
    CT_INT          shift and go to state 125
    CT_FLOAT        shift and go to state 126
    CT_CHAR         shift and go to state 127
    ID              shift and go to state 128

    expression_comp_3              shift and go to state 118
    expression_comp_2              shift and go to state 176
    exp                            shift and go to state 119
    term                           shift and go to state 120
    factor                         shift and go to state 121
    variable                       shift and go to state 123
    func_call                      shift and go to state 124

state 145

    (100) expression_comp_3 -> exp expressions_op . exp g_quad_logic
    (109) exp -> . term g_quad_exp_as_alone
    (110) exp -> . term g_quad_exp_as exp_comp
    (115) term -> . factor g_quad_exp_md_alone
    (116) term -> . factor g_quad_exp_md term_comp
    (122) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (123) factor -> . variable
    (124) factor -> . func_call
    (125) factor -> . CT_INT add_ct_int
    (126) factor -> . CT_FLOAT add_ct_float
    (127) factor -> . CT_CHAR add_ct_char
    (133) variable -> . ID add_id
    (134) variable -> . ID dim
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end

    OPEN_PAREN      shift and go to state 122
    CT_INT          shift and go to state 125
    CT_FLOAT        shift and go to state 126
    CT_CHAR         shift and go to state 127
    ID              shift and go to state 128

    exp                            shift and go to state 177
    term                           shift and go to state 120
    factor                         shift and go to state 121
    variable                       shift and go to state 123
    func_call                      shift and go to state 124

state 146

    (103) expressions_op -> LESS_THAN . add_op
    (121) add_op -> .

    OPEN_PAREN      reduce using rule 121 (add_op -> .)
    CT_INT          reduce using rule 121 (add_op -> .)
    CT_FLOAT        reduce using rule 121 (add_op -> .)
    CT_CHAR         reduce using rule 121 (add_op -> .)
    ID              reduce using rule 121 (add_op -> .)

    add_op                         shift and go to state 178

state 147

    (104) expressions_op -> LESS_THAN_EQUAL . add_op
    (121) add_op -> .

    OPEN_PAREN      reduce using rule 121 (add_op -> .)
    CT_INT          reduce using rule 121 (add_op -> .)
    CT_FLOAT        reduce using rule 121 (add_op -> .)
    CT_CHAR         reduce using rule 121 (add_op -> .)
    ID              reduce using rule 121 (add_op -> .)

    add_op                         shift and go to state 179

state 148

    (105) expressions_op -> MORE_THAN . add_op
    (121) add_op -> .

    OPEN_PAREN      reduce using rule 121 (add_op -> .)
    CT_INT          reduce using rule 121 (add_op -> .)
    CT_FLOAT        reduce using rule 121 (add_op -> .)
    CT_CHAR         reduce using rule 121 (add_op -> .)
    ID              reduce using rule 121 (add_op -> .)

    add_op                         shift and go to state 180

state 149

    (106) expressions_op -> MORE_THAN_EQUAL . add_op
    (121) add_op -> .

    OPEN_PAREN      reduce using rule 121 (add_op -> .)
    CT_INT          reduce using rule 121 (add_op -> .)
    CT_FLOAT        reduce using rule 121 (add_op -> .)
    CT_CHAR         reduce using rule 121 (add_op -> .)
    ID              reduce using rule 121 (add_op -> .)

    add_op                         shift and go to state 181

state 150

    (107) expressions_op -> EQUALS . add_op
    (121) add_op -> .

    OPEN_PAREN      reduce using rule 121 (add_op -> .)
    CT_INT          reduce using rule 121 (add_op -> .)
    CT_FLOAT        reduce using rule 121 (add_op -> .)
    CT_CHAR         reduce using rule 121 (add_op -> .)
    ID              reduce using rule 121 (add_op -> .)

    add_op                         shift and go to state 182

state 151

    (108) expressions_op -> NOT_EQUALS . add_op
    (121) add_op -> .

    OPEN_PAREN      reduce using rule 121 (add_op -> .)
    CT_INT          reduce using rule 121 (add_op -> .)
    CT_FLOAT        reduce using rule 121 (add_op -> .)
    CT_CHAR         reduce using rule 121 (add_op -> .)
    ID              reduce using rule 121 (add_op -> .)

    add_op                         shift and go to state 183

state 152

    (109) exp -> term g_quad_exp_as_alone .

    LESS_THAN       reduce using rule 109 (exp -> term g_quad_exp_as_alone .)
    LESS_THAN_EQUAL reduce using rule 109 (exp -> term g_quad_exp_as_alone .)
    MORE_THAN       reduce using rule 109 (exp -> term g_quad_exp_as_alone .)
    MORE_THAN_EQUAL reduce using rule 109 (exp -> term g_quad_exp_as_alone .)
    EQUALS          reduce using rule 109 (exp -> term g_quad_exp_as_alone .)
    NOT_EQUALS      reduce using rule 109 (exp -> term g_quad_exp_as_alone .)
    AND             reduce using rule 109 (exp -> term g_quad_exp_as_alone .)
    OR              reduce using rule 109 (exp -> term g_quad_exp_as_alone .)
    SEMICOLON       reduce using rule 109 (exp -> term g_quad_exp_as_alone .)
    COMMA           reduce using rule 109 (exp -> term g_quad_exp_as_alone .)
    CLOSE_PAREN     reduce using rule 109 (exp -> term g_quad_exp_as_alone .)
    CLOSE_BRACKETS  reduce using rule 109 (exp -> term g_quad_exp_as_alone .)
    TO              reduce using rule 109 (exp -> term g_quad_exp_as_alone .)
    OPEN_PAREN      reduce using rule 109 (exp -> term g_quad_exp_as_alone .)
    CT_INT          reduce using rule 109 (exp -> term g_quad_exp_as_alone .)
    CT_FLOAT        reduce using rule 109 (exp -> term g_quad_exp_as_alone .)
    CT_CHAR         reduce using rule 109 (exp -> term g_quad_exp_as_alone .)
    ID              reduce using rule 109 (exp -> term g_quad_exp_as_alone .)
    DO              reduce using rule 109 (exp -> term g_quad_exp_as_alone .)


state 153

    (110) exp -> term g_quad_exp_as . exp_comp
    (113) exp_comp -> . PLUS add_op exp
    (114) exp_comp -> . MINUS add_op exp

    PLUS            shift and go to state 185
    MINUS           shift and go to state 186

    exp_comp                       shift and go to state 184

state 154

    (115) term -> factor g_quad_exp_md_alone .

    PLUS            reduce using rule 115 (term -> factor g_quad_exp_md_alone .)
    MINUS           reduce using rule 115 (term -> factor g_quad_exp_md_alone .)
    LESS_THAN       reduce using rule 115 (term -> factor g_quad_exp_md_alone .)
    LESS_THAN_EQUAL reduce using rule 115 (term -> factor g_quad_exp_md_alone .)
    MORE_THAN       reduce using rule 115 (term -> factor g_quad_exp_md_alone .)
    MORE_THAN_EQUAL reduce using rule 115 (term -> factor g_quad_exp_md_alone .)
    EQUALS          reduce using rule 115 (term -> factor g_quad_exp_md_alone .)
    NOT_EQUALS      reduce using rule 115 (term -> factor g_quad_exp_md_alone .)
    AND             reduce using rule 115 (term -> factor g_quad_exp_md_alone .)
    OR              reduce using rule 115 (term -> factor g_quad_exp_md_alone .)
    SEMICOLON       reduce using rule 115 (term -> factor g_quad_exp_md_alone .)
    COMMA           reduce using rule 115 (term -> factor g_quad_exp_md_alone .)
    CLOSE_PAREN     reduce using rule 115 (term -> factor g_quad_exp_md_alone .)
    CLOSE_BRACKETS  reduce using rule 115 (term -> factor g_quad_exp_md_alone .)
    TO              reduce using rule 115 (term -> factor g_quad_exp_md_alone .)
    OPEN_PAREN      reduce using rule 115 (term -> factor g_quad_exp_md_alone .)
    CT_INT          reduce using rule 115 (term -> factor g_quad_exp_md_alone .)
    CT_FLOAT        reduce using rule 115 (term -> factor g_quad_exp_md_alone .)
    CT_CHAR         reduce using rule 115 (term -> factor g_quad_exp_md_alone .)
    ID              reduce using rule 115 (term -> factor g_quad_exp_md_alone .)
    DO              reduce using rule 115 (term -> factor g_quad_exp_md_alone .)


state 155

    (116) term -> factor g_quad_exp_md . term_comp
    (119) term_comp -> . MULTIPLIES add_op term
    (120) term_comp -> . DIVIDE add_op term

    MULTIPLIES      shift and go to state 188
    DIVIDE          shift and go to state 189

    term_comp                      shift and go to state 187

state 156

    (122) factor -> OPEN_PAREN add_fake . expressions CLOSE_PAREN rem_fake
    (95) expressions -> . expressions_comp
    (96) expressions_comp -> . expression_comp_2
    (97) expressions_comp -> . expression_comp_2 OR expressions_comp
    (98) expression_comp_2 -> . expression_comp_3
    (99) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (100) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (101) expression_comp_3 -> . exp
    (109) exp -> . term g_quad_exp_as_alone
    (110) exp -> . term g_quad_exp_as exp_comp
    (115) term -> . factor g_quad_exp_md_alone
    (116) term -> . factor g_quad_exp_md term_comp
    (122) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (123) factor -> . variable
    (124) factor -> . func_call
    (125) factor -> . CT_INT add_ct_int
    (126) factor -> . CT_FLOAT add_ct_float
    (127) factor -> . CT_CHAR add_ct_char
    (133) variable -> . ID add_id
    (134) variable -> . ID dim
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end

    OPEN_PAREN      shift and go to state 122
    CT_INT          shift and go to state 125
    CT_FLOAT        shift and go to state 126
    CT_CHAR         shift and go to state 127
    ID              shift and go to state 128

    expressions                    shift and go to state 190
    expressions_comp               shift and go to state 116
    expression_comp_2              shift and go to state 117
    expression_comp_3              shift and go to state 118
    exp                            shift and go to state 119
    term                           shift and go to state 120
    factor                         shift and go to state 121
    variable                       shift and go to state 123
    func_call                      shift and go to state 124

state 157

    (125) factor -> CT_INT add_ct_int .

    MULTIPLIES      reduce using rule 125 (factor -> CT_INT add_ct_int .)
    DIVIDE          reduce using rule 125 (factor -> CT_INT add_ct_int .)
    PLUS            reduce using rule 125 (factor -> CT_INT add_ct_int .)
    MINUS           reduce using rule 125 (factor -> CT_INT add_ct_int .)
    LESS_THAN       reduce using rule 125 (factor -> CT_INT add_ct_int .)
    LESS_THAN_EQUAL reduce using rule 125 (factor -> CT_INT add_ct_int .)
    MORE_THAN       reduce using rule 125 (factor -> CT_INT add_ct_int .)
    MORE_THAN_EQUAL reduce using rule 125 (factor -> CT_INT add_ct_int .)
    EQUALS          reduce using rule 125 (factor -> CT_INT add_ct_int .)
    NOT_EQUALS      reduce using rule 125 (factor -> CT_INT add_ct_int .)
    AND             reduce using rule 125 (factor -> CT_INT add_ct_int .)
    OR              reduce using rule 125 (factor -> CT_INT add_ct_int .)
    SEMICOLON       reduce using rule 125 (factor -> CT_INT add_ct_int .)
    COMMA           reduce using rule 125 (factor -> CT_INT add_ct_int .)
    CLOSE_PAREN     reduce using rule 125 (factor -> CT_INT add_ct_int .)
    CLOSE_BRACKETS  reduce using rule 125 (factor -> CT_INT add_ct_int .)
    TO              reduce using rule 125 (factor -> CT_INT add_ct_int .)
    OPEN_PAREN      reduce using rule 125 (factor -> CT_INT add_ct_int .)
    CT_INT          reduce using rule 125 (factor -> CT_INT add_ct_int .)
    CT_FLOAT        reduce using rule 125 (factor -> CT_INT add_ct_int .)
    CT_CHAR         reduce using rule 125 (factor -> CT_INT add_ct_int .)
    ID              reduce using rule 125 (factor -> CT_INT add_ct_int .)
    DO              reduce using rule 125 (factor -> CT_INT add_ct_int .)


state 158

    (126) factor -> CT_FLOAT add_ct_float .

    MULTIPLIES      reduce using rule 126 (factor -> CT_FLOAT add_ct_float .)
    DIVIDE          reduce using rule 126 (factor -> CT_FLOAT add_ct_float .)
    PLUS            reduce using rule 126 (factor -> CT_FLOAT add_ct_float .)
    MINUS           reduce using rule 126 (factor -> CT_FLOAT add_ct_float .)
    LESS_THAN       reduce using rule 126 (factor -> CT_FLOAT add_ct_float .)
    LESS_THAN_EQUAL reduce using rule 126 (factor -> CT_FLOAT add_ct_float .)
    MORE_THAN       reduce using rule 126 (factor -> CT_FLOAT add_ct_float .)
    MORE_THAN_EQUAL reduce using rule 126 (factor -> CT_FLOAT add_ct_float .)
    EQUALS          reduce using rule 126 (factor -> CT_FLOAT add_ct_float .)
    NOT_EQUALS      reduce using rule 126 (factor -> CT_FLOAT add_ct_float .)
    AND             reduce using rule 126 (factor -> CT_FLOAT add_ct_float .)
    OR              reduce using rule 126 (factor -> CT_FLOAT add_ct_float .)
    SEMICOLON       reduce using rule 126 (factor -> CT_FLOAT add_ct_float .)
    COMMA           reduce using rule 126 (factor -> CT_FLOAT add_ct_float .)
    CLOSE_PAREN     reduce using rule 126 (factor -> CT_FLOAT add_ct_float .)
    CLOSE_BRACKETS  reduce using rule 126 (factor -> CT_FLOAT add_ct_float .)
    TO              reduce using rule 126 (factor -> CT_FLOAT add_ct_float .)
    OPEN_PAREN      reduce using rule 126 (factor -> CT_FLOAT add_ct_float .)
    CT_INT          reduce using rule 126 (factor -> CT_FLOAT add_ct_float .)
    CT_FLOAT        reduce using rule 126 (factor -> CT_FLOAT add_ct_float .)
    CT_CHAR         reduce using rule 126 (factor -> CT_FLOAT add_ct_float .)
    ID              reduce using rule 126 (factor -> CT_FLOAT add_ct_float .)
    DO              reduce using rule 126 (factor -> CT_FLOAT add_ct_float .)


state 159

    (127) factor -> CT_CHAR add_ct_char .

    MULTIPLIES      reduce using rule 127 (factor -> CT_CHAR add_ct_char .)
    DIVIDE          reduce using rule 127 (factor -> CT_CHAR add_ct_char .)
    PLUS            reduce using rule 127 (factor -> CT_CHAR add_ct_char .)
    MINUS           reduce using rule 127 (factor -> CT_CHAR add_ct_char .)
    LESS_THAN       reduce using rule 127 (factor -> CT_CHAR add_ct_char .)
    LESS_THAN_EQUAL reduce using rule 127 (factor -> CT_CHAR add_ct_char .)
    MORE_THAN       reduce using rule 127 (factor -> CT_CHAR add_ct_char .)
    MORE_THAN_EQUAL reduce using rule 127 (factor -> CT_CHAR add_ct_char .)
    EQUALS          reduce using rule 127 (factor -> CT_CHAR add_ct_char .)
    NOT_EQUALS      reduce using rule 127 (factor -> CT_CHAR add_ct_char .)
    AND             reduce using rule 127 (factor -> CT_CHAR add_ct_char .)
    OR              reduce using rule 127 (factor -> CT_CHAR add_ct_char .)
    SEMICOLON       reduce using rule 127 (factor -> CT_CHAR add_ct_char .)
    COMMA           reduce using rule 127 (factor -> CT_CHAR add_ct_char .)
    CLOSE_PAREN     reduce using rule 127 (factor -> CT_CHAR add_ct_char .)
    CLOSE_BRACKETS  reduce using rule 127 (factor -> CT_CHAR add_ct_char .)
    TO              reduce using rule 127 (factor -> CT_CHAR add_ct_char .)
    OPEN_PAREN      reduce using rule 127 (factor -> CT_CHAR add_ct_char .)
    CT_INT          reduce using rule 127 (factor -> CT_CHAR add_ct_char .)
    CT_FLOAT        reduce using rule 127 (factor -> CT_CHAR add_ct_char .)
    CT_CHAR         reduce using rule 127 (factor -> CT_CHAR add_ct_char .)
    ID              reduce using rule 127 (factor -> CT_CHAR add_ct_char .)
    DO              reduce using rule 127 (factor -> CT_CHAR add_ct_char .)


state 160

    (133) variable -> ID add_id .

    MULTIPLIES      reduce using rule 133 (variable -> ID add_id .)
    DIVIDE          reduce using rule 133 (variable -> ID add_id .)
    PLUS            reduce using rule 133 (variable -> ID add_id .)
    MINUS           reduce using rule 133 (variable -> ID add_id .)
    LESS_THAN       reduce using rule 133 (variable -> ID add_id .)
    LESS_THAN_EQUAL reduce using rule 133 (variable -> ID add_id .)
    MORE_THAN       reduce using rule 133 (variable -> ID add_id .)
    MORE_THAN_EQUAL reduce using rule 133 (variable -> ID add_id .)
    EQUALS          reduce using rule 133 (variable -> ID add_id .)
    NOT_EQUALS      reduce using rule 133 (variable -> ID add_id .)
    AND             reduce using rule 133 (variable -> ID add_id .)
    OR              reduce using rule 133 (variable -> ID add_id .)
    SEMICOLON       reduce using rule 133 (variable -> ID add_id .)
    COMMA           reduce using rule 133 (variable -> ID add_id .)
    CLOSE_PAREN     reduce using rule 133 (variable -> ID add_id .)
    CLOSE_BRACKETS  reduce using rule 133 (variable -> ID add_id .)
    TO              reduce using rule 133 (variable -> ID add_id .)
    OPEN_PAREN      reduce using rule 133 (variable -> ID add_id .)
    CT_INT          reduce using rule 133 (variable -> ID add_id .)
    CT_FLOAT        reduce using rule 133 (variable -> ID add_id .)
    CT_CHAR         reduce using rule 133 (variable -> ID add_id .)
    ID              reduce using rule 133 (variable -> ID add_id .)
    DO              reduce using rule 133 (variable -> ID add_id .)


state 161

    (134) variable -> ID dim .

    MULTIPLIES      reduce using rule 134 (variable -> ID dim .)
    DIVIDE          reduce using rule 134 (variable -> ID dim .)
    PLUS            reduce using rule 134 (variable -> ID dim .)
    MINUS           reduce using rule 134 (variable -> ID dim .)
    LESS_THAN       reduce using rule 134 (variable -> ID dim .)
    LESS_THAN_EQUAL reduce using rule 134 (variable -> ID dim .)
    MORE_THAN       reduce using rule 134 (variable -> ID dim .)
    MORE_THAN_EQUAL reduce using rule 134 (variable -> ID dim .)
    EQUALS          reduce using rule 134 (variable -> ID dim .)
    NOT_EQUALS      reduce using rule 134 (variable -> ID dim .)
    AND             reduce using rule 134 (variable -> ID dim .)
    OR              reduce using rule 134 (variable -> ID dim .)
    SEMICOLON       reduce using rule 134 (variable -> ID dim .)
    COMMA           reduce using rule 134 (variable -> ID dim .)
    CLOSE_PAREN     reduce using rule 134 (variable -> ID dim .)
    CLOSE_BRACKETS  reduce using rule 134 (variable -> ID dim .)
    TO              reduce using rule 134 (variable -> ID dim .)
    OPEN_PAREN      reduce using rule 134 (variable -> ID dim .)
    CT_INT          reduce using rule 134 (variable -> ID dim .)
    CT_FLOAT        reduce using rule 134 (variable -> ID dim .)
    CT_CHAR         reduce using rule 134 (variable -> ID dim .)
    ID              reduce using rule 134 (variable -> ID dim .)
    DO              reduce using rule 134 (variable -> ID dim .)


state 162

    (58) read -> READ OPEN_PAREN ids g_quad_read . read_comp CLOSE_PAREN
    (59) read_comp -> . COMMA ids g_quad_read read_comp
    (60) read_comp -> . empty
    (137) empty -> .

    COMMA           shift and go to state 192
    CLOSE_PAREN     reduce using rule 137 (empty -> .)

    read_comp                      shift and go to state 191
    empty                          shift and go to state 193

state 163

    (62) write -> WRITE OPEN_PAREN CT_STRING g_quad_write_str . write_comp CLOSE_PAREN
    (64) write_comp -> . COMMA CT_STRING g_quad_write_str write_comp
    (65) write_comp -> . COMMA expressions g_quad_write write_comp
    (66) write_comp -> . empty
    (137) empty -> .

    COMMA           shift and go to state 195
    CLOSE_PAREN     reduce using rule 137 (empty -> .)

    write_comp                     shift and go to state 194
    empty                          shift and go to state 196

state 164

    (63) write -> WRITE OPEN_PAREN expressions g_quad_write . write_comp CLOSE_PAREN
    (64) write_comp -> . COMMA CT_STRING g_quad_write_str write_comp
    (65) write_comp -> . COMMA expressions g_quad_write write_comp
    (66) write_comp -> . empty
    (137) empty -> .

    COMMA           shift and go to state 195
    CLOSE_PAREN     reduce using rule 137 (empty -> .)

    write_comp                     shift and go to state 197
    empty                          shift and go to state 196

state 165

    (70) condition -> IF OPEN_PAREN expressions CLOSE_PAREN . g_if_quad THEN block end_if
    (71) condition -> IF OPEN_PAREN expressions CLOSE_PAREN . g_if_quad THEN block ELSE g_else_quad block end_if
    (74) g_if_quad -> .

    THEN            reduce using rule 74 (g_if_quad -> .)

    g_if_quad                      shift and go to state 198

state 166

    (72) condition -> WHILE while_jump OPEN_PAREN expressions . CLOSE_PAREN g_while_quad DO block end_while

    CLOSE_PAREN     shift and go to state 199


state 167

    (73) condition -> FOR ids validate_for ASSIGN . expressions for_counter_control TO expressions for_counter_end DO block end_for
    (95) expressions -> . expressions_comp
    (96) expressions_comp -> . expression_comp_2
    (97) expressions_comp -> . expression_comp_2 OR expressions_comp
    (98) expression_comp_2 -> . expression_comp_3
    (99) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (100) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (101) expression_comp_3 -> . exp
    (109) exp -> . term g_quad_exp_as_alone
    (110) exp -> . term g_quad_exp_as exp_comp
    (115) term -> . factor g_quad_exp_md_alone
    (116) term -> . factor g_quad_exp_md term_comp
    (122) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (123) factor -> . variable
    (124) factor -> . func_call
    (125) factor -> . CT_INT add_ct_int
    (126) factor -> . CT_FLOAT add_ct_float
    (127) factor -> . CT_CHAR add_ct_char
    (133) variable -> . ID add_id
    (134) variable -> . ID dim
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end

    OPEN_PAREN      shift and go to state 122
    CT_INT          shift and go to state 125
    CT_FLOAT        shift and go to state 126
    CT_CHAR         shift and go to state 127
    ID              shift and go to state 128

    expressions                    shift and go to state 200
    expressions_comp               shift and go to state 116
    expression_comp_2              shift and go to state 117
    expression_comp_3              shift and go to state 118
    exp                            shift and go to state 119
    term                           shift and go to state 120
    factor                         shift and go to state 121
    variable                       shift and go to state 123
    func_call                      shift and go to state 124

state 168

    (83) return -> RETURN OPEN_PAREN expressions CLOSE_PAREN . g_quad_return
    (84) g_quad_return -> .

    SEMICOLON       reduce using rule 84 (g_quad_return -> .)

    g_quad_return                  shift and go to state 201

state 169

    (85) func_call -> ID verify_function_exists OPEN_PAREN era_activation . func_call_comp CLOSE_PAREN g_gosub_quad function_call_end
    (91) func_call_comp -> . expressions g_parameter_quad func_call_comp
    (92) func_call_comp -> . COMMA expressions g_parameter_quad func_call_comp
    (93) func_call_comp -> . empty
    (95) expressions -> . expressions_comp
    (137) empty -> .
    (96) expressions_comp -> . expression_comp_2
    (97) expressions_comp -> . expression_comp_2 OR expressions_comp
    (98) expression_comp_2 -> . expression_comp_3
    (99) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (100) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (101) expression_comp_3 -> . exp
    (109) exp -> . term g_quad_exp_as_alone
    (110) exp -> . term g_quad_exp_as exp_comp
    (115) term -> . factor g_quad_exp_md_alone
    (116) term -> . factor g_quad_exp_md term_comp
    (122) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (123) factor -> . variable
    (124) factor -> . func_call
    (125) factor -> . CT_INT add_ct_int
    (126) factor -> . CT_FLOAT add_ct_float
    (127) factor -> . CT_CHAR add_ct_char
    (133) variable -> . ID add_id
    (134) variable -> . ID dim
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end

    COMMA           shift and go to state 204
    CLOSE_PAREN     reduce using rule 137 (empty -> .)
    OPEN_PAREN      shift and go to state 122
    CT_INT          shift and go to state 125
    CT_FLOAT        shift and go to state 126
    CT_CHAR         shift and go to state 127
    ID              shift and go to state 128

    func_call_comp                 shift and go to state 202
    expressions                    shift and go to state 203
    empty                          shift and go to state 205
    expressions_comp               shift and go to state 116
    expression_comp_2              shift and go to state 117
    expression_comp_3              shift and go to state 118
    exp                            shift and go to state 119
    term                           shift and go to state 120
    factor                         shift and go to state 121
    variable                       shift and go to state 123
    func_call                      shift and go to state 124

state 170

    (47) ids_matrix -> ID OPEN_BRACKETS exp CLOSE_BRACKETS . OPEN_BRACKETS exp CLOSE_BRACKETS
    (48) ids_array -> ID OPEN_BRACKETS exp CLOSE_BRACKETS .

    OPEN_BRACKETS   shift and go to state 206
    ASSIGN          reduce using rule 48 (ids_array -> ID OPEN_BRACKETS exp CLOSE_BRACKETS .)
    COMMA           reduce using rule 48 (ids_array -> ID OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CLOSE_PAREN     reduce using rule 48 (ids_array -> ID OPEN_BRACKETS exp CLOSE_BRACKETS .)


state 171

    (7) funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars . block end_funcs funcs
    (20) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 50

    block                          shift and go to state 207

state 172

    (16) funcs_params_comp -> COMMA var_type variable_params . funcs_params_comp
    (16) funcs_params_comp -> . COMMA var_type variable_params funcs_params_comp
    (17) funcs_params_comp -> . empty
    (137) empty -> .

    COMMA           shift and go to state 102
    CLOSE_PAREN     reduce using rule 137 (empty -> .)

    funcs_params_comp              shift and go to state 208
    empty                          shift and go to state 103

state 173

    (136) dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .

    COMMA           reduce using rule 136 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CLOSE_PAREN     reduce using rule 136 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    MULTIPLIES      reduce using rule 136 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    DIVIDE          reduce using rule 136 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    PLUS            reduce using rule 136 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    MINUS           reduce using rule 136 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    LESS_THAN       reduce using rule 136 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    LESS_THAN_EQUAL reduce using rule 136 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    MORE_THAN       reduce using rule 136 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    MORE_THAN_EQUAL reduce using rule 136 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    EQUALS          reduce using rule 136 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    NOT_EQUALS      reduce using rule 136 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    AND             reduce using rule 136 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    OR              reduce using rule 136 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    SEMICOLON       reduce using rule 136 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CLOSE_BRACKETS  reduce using rule 136 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    TO              reduce using rule 136 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    OPEN_PAREN      reduce using rule 136 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CT_INT          reduce using rule 136 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CT_FLOAT        reduce using rule 136 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CT_CHAR         reduce using rule 136 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    ID              reduce using rule 136 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)
    DO              reduce using rule 136 (dim -> OPEN_BRACKETS exp CLOSE_BRACKETS .)


state 174

    (12) funcs_comp -> ID add_module OPEN_PAREN funcs_params . CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs

    CLOSE_PAREN     shift and go to state 209


state 175

    (97) expressions_comp -> expression_comp_2 OR expressions_comp .

    SEMICOLON       reduce using rule 97 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    COMMA           reduce using rule 97 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    CLOSE_PAREN     reduce using rule 97 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    TO              reduce using rule 97 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    OPEN_PAREN      reduce using rule 97 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    CT_INT          reduce using rule 97 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    CT_FLOAT        reduce using rule 97 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    CT_CHAR         reduce using rule 97 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    ID              reduce using rule 97 (expressions_comp -> expression_comp_2 OR expressions_comp .)
    DO              reduce using rule 97 (expressions_comp -> expression_comp_2 OR expressions_comp .)


state 176

    (99) expression_comp_2 -> expression_comp_3 AND expression_comp_2 .

    OR              reduce using rule 99 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    SEMICOLON       reduce using rule 99 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    COMMA           reduce using rule 99 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    CLOSE_PAREN     reduce using rule 99 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    TO              reduce using rule 99 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    OPEN_PAREN      reduce using rule 99 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    CT_INT          reduce using rule 99 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    CT_FLOAT        reduce using rule 99 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    CT_CHAR         reduce using rule 99 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    ID              reduce using rule 99 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)
    DO              reduce using rule 99 (expression_comp_2 -> expression_comp_3 AND expression_comp_2 .)


state 177

    (100) expression_comp_3 -> exp expressions_op exp . g_quad_logic
    (102) g_quad_logic -> .

    AND             reduce using rule 102 (g_quad_logic -> .)
    OR              reduce using rule 102 (g_quad_logic -> .)
    SEMICOLON       reduce using rule 102 (g_quad_logic -> .)
    COMMA           reduce using rule 102 (g_quad_logic -> .)
    CLOSE_PAREN     reduce using rule 102 (g_quad_logic -> .)
    TO              reduce using rule 102 (g_quad_logic -> .)
    OPEN_PAREN      reduce using rule 102 (g_quad_logic -> .)
    CT_INT          reduce using rule 102 (g_quad_logic -> .)
    CT_FLOAT        reduce using rule 102 (g_quad_logic -> .)
    CT_CHAR         reduce using rule 102 (g_quad_logic -> .)
    ID              reduce using rule 102 (g_quad_logic -> .)
    DO              reduce using rule 102 (g_quad_logic -> .)

    g_quad_logic                   shift and go to state 210

state 178

    (103) expressions_op -> LESS_THAN add_op .

    OPEN_PAREN      reduce using rule 103 (expressions_op -> LESS_THAN add_op .)
    CT_INT          reduce using rule 103 (expressions_op -> LESS_THAN add_op .)
    CT_FLOAT        reduce using rule 103 (expressions_op -> LESS_THAN add_op .)
    CT_CHAR         reduce using rule 103 (expressions_op -> LESS_THAN add_op .)
    ID              reduce using rule 103 (expressions_op -> LESS_THAN add_op .)


state 179

    (104) expressions_op -> LESS_THAN_EQUAL add_op .

    OPEN_PAREN      reduce using rule 104 (expressions_op -> LESS_THAN_EQUAL add_op .)
    CT_INT          reduce using rule 104 (expressions_op -> LESS_THAN_EQUAL add_op .)
    CT_FLOAT        reduce using rule 104 (expressions_op -> LESS_THAN_EQUAL add_op .)
    CT_CHAR         reduce using rule 104 (expressions_op -> LESS_THAN_EQUAL add_op .)
    ID              reduce using rule 104 (expressions_op -> LESS_THAN_EQUAL add_op .)


state 180

    (105) expressions_op -> MORE_THAN add_op .

    OPEN_PAREN      reduce using rule 105 (expressions_op -> MORE_THAN add_op .)
    CT_INT          reduce using rule 105 (expressions_op -> MORE_THAN add_op .)
    CT_FLOAT        reduce using rule 105 (expressions_op -> MORE_THAN add_op .)
    CT_CHAR         reduce using rule 105 (expressions_op -> MORE_THAN add_op .)
    ID              reduce using rule 105 (expressions_op -> MORE_THAN add_op .)


state 181

    (106) expressions_op -> MORE_THAN_EQUAL add_op .

    OPEN_PAREN      reduce using rule 106 (expressions_op -> MORE_THAN_EQUAL add_op .)
    CT_INT          reduce using rule 106 (expressions_op -> MORE_THAN_EQUAL add_op .)
    CT_FLOAT        reduce using rule 106 (expressions_op -> MORE_THAN_EQUAL add_op .)
    CT_CHAR         reduce using rule 106 (expressions_op -> MORE_THAN_EQUAL add_op .)
    ID              reduce using rule 106 (expressions_op -> MORE_THAN_EQUAL add_op .)


state 182

    (107) expressions_op -> EQUALS add_op .

    OPEN_PAREN      reduce using rule 107 (expressions_op -> EQUALS add_op .)
    CT_INT          reduce using rule 107 (expressions_op -> EQUALS add_op .)
    CT_FLOAT        reduce using rule 107 (expressions_op -> EQUALS add_op .)
    CT_CHAR         reduce using rule 107 (expressions_op -> EQUALS add_op .)
    ID              reduce using rule 107 (expressions_op -> EQUALS add_op .)


state 183

    (108) expressions_op -> NOT_EQUALS add_op .

    OPEN_PAREN      reduce using rule 108 (expressions_op -> NOT_EQUALS add_op .)
    CT_INT          reduce using rule 108 (expressions_op -> NOT_EQUALS add_op .)
    CT_FLOAT        reduce using rule 108 (expressions_op -> NOT_EQUALS add_op .)
    CT_CHAR         reduce using rule 108 (expressions_op -> NOT_EQUALS add_op .)
    ID              reduce using rule 108 (expressions_op -> NOT_EQUALS add_op .)


state 184

    (110) exp -> term g_quad_exp_as exp_comp .

    LESS_THAN       reduce using rule 110 (exp -> term g_quad_exp_as exp_comp .)
    LESS_THAN_EQUAL reduce using rule 110 (exp -> term g_quad_exp_as exp_comp .)
    MORE_THAN       reduce using rule 110 (exp -> term g_quad_exp_as exp_comp .)
    MORE_THAN_EQUAL reduce using rule 110 (exp -> term g_quad_exp_as exp_comp .)
    EQUALS          reduce using rule 110 (exp -> term g_quad_exp_as exp_comp .)
    NOT_EQUALS      reduce using rule 110 (exp -> term g_quad_exp_as exp_comp .)
    AND             reduce using rule 110 (exp -> term g_quad_exp_as exp_comp .)
    OR              reduce using rule 110 (exp -> term g_quad_exp_as exp_comp .)
    SEMICOLON       reduce using rule 110 (exp -> term g_quad_exp_as exp_comp .)
    COMMA           reduce using rule 110 (exp -> term g_quad_exp_as exp_comp .)
    CLOSE_PAREN     reduce using rule 110 (exp -> term g_quad_exp_as exp_comp .)
    CLOSE_BRACKETS  reduce using rule 110 (exp -> term g_quad_exp_as exp_comp .)
    TO              reduce using rule 110 (exp -> term g_quad_exp_as exp_comp .)
    OPEN_PAREN      reduce using rule 110 (exp -> term g_quad_exp_as exp_comp .)
    CT_INT          reduce using rule 110 (exp -> term g_quad_exp_as exp_comp .)
    CT_FLOAT        reduce using rule 110 (exp -> term g_quad_exp_as exp_comp .)
    CT_CHAR         reduce using rule 110 (exp -> term g_quad_exp_as exp_comp .)
    ID              reduce using rule 110 (exp -> term g_quad_exp_as exp_comp .)
    DO              reduce using rule 110 (exp -> term g_quad_exp_as exp_comp .)


state 185

    (113) exp_comp -> PLUS . add_op exp
    (121) add_op -> .

    OPEN_PAREN      reduce using rule 121 (add_op -> .)
    CT_INT          reduce using rule 121 (add_op -> .)
    CT_FLOAT        reduce using rule 121 (add_op -> .)
    CT_CHAR         reduce using rule 121 (add_op -> .)
    ID              reduce using rule 121 (add_op -> .)

    add_op                         shift and go to state 211

state 186

    (114) exp_comp -> MINUS . add_op exp
    (121) add_op -> .

    OPEN_PAREN      reduce using rule 121 (add_op -> .)
    CT_INT          reduce using rule 121 (add_op -> .)
    CT_FLOAT        reduce using rule 121 (add_op -> .)
    CT_CHAR         reduce using rule 121 (add_op -> .)
    ID              reduce using rule 121 (add_op -> .)

    add_op                         shift and go to state 212

state 187

    (116) term -> factor g_quad_exp_md term_comp .

    PLUS            reduce using rule 116 (term -> factor g_quad_exp_md term_comp .)
    MINUS           reduce using rule 116 (term -> factor g_quad_exp_md term_comp .)
    LESS_THAN       reduce using rule 116 (term -> factor g_quad_exp_md term_comp .)
    LESS_THAN_EQUAL reduce using rule 116 (term -> factor g_quad_exp_md term_comp .)
    MORE_THAN       reduce using rule 116 (term -> factor g_quad_exp_md term_comp .)
    MORE_THAN_EQUAL reduce using rule 116 (term -> factor g_quad_exp_md term_comp .)
    EQUALS          reduce using rule 116 (term -> factor g_quad_exp_md term_comp .)
    NOT_EQUALS      reduce using rule 116 (term -> factor g_quad_exp_md term_comp .)
    AND             reduce using rule 116 (term -> factor g_quad_exp_md term_comp .)
    OR              reduce using rule 116 (term -> factor g_quad_exp_md term_comp .)
    SEMICOLON       reduce using rule 116 (term -> factor g_quad_exp_md term_comp .)
    COMMA           reduce using rule 116 (term -> factor g_quad_exp_md term_comp .)
    CLOSE_PAREN     reduce using rule 116 (term -> factor g_quad_exp_md term_comp .)
    CLOSE_BRACKETS  reduce using rule 116 (term -> factor g_quad_exp_md term_comp .)
    TO              reduce using rule 116 (term -> factor g_quad_exp_md term_comp .)
    OPEN_PAREN      reduce using rule 116 (term -> factor g_quad_exp_md term_comp .)
    CT_INT          reduce using rule 116 (term -> factor g_quad_exp_md term_comp .)
    CT_FLOAT        reduce using rule 116 (term -> factor g_quad_exp_md term_comp .)
    CT_CHAR         reduce using rule 116 (term -> factor g_quad_exp_md term_comp .)
    ID              reduce using rule 116 (term -> factor g_quad_exp_md term_comp .)
    DO              reduce using rule 116 (term -> factor g_quad_exp_md term_comp .)


state 188

    (119) term_comp -> MULTIPLIES . add_op term
    (121) add_op -> .

    OPEN_PAREN      reduce using rule 121 (add_op -> .)
    CT_INT          reduce using rule 121 (add_op -> .)
    CT_FLOAT        reduce using rule 121 (add_op -> .)
    CT_CHAR         reduce using rule 121 (add_op -> .)
    ID              reduce using rule 121 (add_op -> .)

    add_op                         shift and go to state 213

state 189

    (120) term_comp -> DIVIDE . add_op term
    (121) add_op -> .

    OPEN_PAREN      reduce using rule 121 (add_op -> .)
    CT_INT          reduce using rule 121 (add_op -> .)
    CT_FLOAT        reduce using rule 121 (add_op -> .)
    CT_CHAR         reduce using rule 121 (add_op -> .)
    ID              reduce using rule 121 (add_op -> .)

    add_op                         shift and go to state 214

state 190

    (122) factor -> OPEN_PAREN add_fake expressions . CLOSE_PAREN rem_fake

    CLOSE_PAREN     shift and go to state 215


state 191

    (58) read -> READ OPEN_PAREN ids g_quad_read read_comp . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 216


state 192

    (59) read_comp -> COMMA . ids g_quad_read read_comp
    (44) ids -> . ids_matrix
    (45) ids -> . ids_array
    (46) ids -> . ids_single
    (47) ids_matrix -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS
    (48) ids_array -> . ID OPEN_BRACKETS exp CLOSE_BRACKETS
    (49) ids_single -> . ID

    ID              shift and go to state 96

    ids                            shift and go to state 217
    ids_matrix                     shift and go to state 73
    ids_array                      shift and go to state 74
    ids_single                     shift and go to state 75

state 193

    (60) read_comp -> empty .

    CLOSE_PAREN     reduce using rule 60 (read_comp -> empty .)


state 194

    (62) write -> WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 218


state 195

    (64) write_comp -> COMMA . CT_STRING g_quad_write_str write_comp
    (65) write_comp -> COMMA . expressions g_quad_write write_comp
    (95) expressions -> . expressions_comp
    (96) expressions_comp -> . expression_comp_2
    (97) expressions_comp -> . expression_comp_2 OR expressions_comp
    (98) expression_comp_2 -> . expression_comp_3
    (99) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (100) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (101) expression_comp_3 -> . exp
    (109) exp -> . term g_quad_exp_as_alone
    (110) exp -> . term g_quad_exp_as exp_comp
    (115) term -> . factor g_quad_exp_md_alone
    (116) term -> . factor g_quad_exp_md term_comp
    (122) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (123) factor -> . variable
    (124) factor -> . func_call
    (125) factor -> . CT_INT add_ct_int
    (126) factor -> . CT_FLOAT add_ct_float
    (127) factor -> . CT_CHAR add_ct_char
    (133) variable -> . ID add_id
    (134) variable -> . ID dim
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end

    CT_STRING       shift and go to state 219
    OPEN_PAREN      shift and go to state 122
    CT_INT          shift and go to state 125
    CT_FLOAT        shift and go to state 126
    CT_CHAR         shift and go to state 127
    ID              shift and go to state 128

    expressions                    shift and go to state 220
    expressions_comp               shift and go to state 116
    expression_comp_2              shift and go to state 117
    expression_comp_3              shift and go to state 118
    exp                            shift and go to state 119
    term                           shift and go to state 120
    factor                         shift and go to state 121
    variable                       shift and go to state 123
    func_call                      shift and go to state 124

state 196

    (66) write_comp -> empty .

    CLOSE_PAREN     reduce using rule 66 (write_comp -> empty .)


state 197

    (63) write -> WRITE OPEN_PAREN expressions g_quad_write write_comp . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 221


state 198

    (70) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad . THEN block end_if
    (71) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad . THEN block ELSE g_else_quad block end_if

    THEN            shift and go to state 222


state 199

    (72) condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN . g_while_quad DO block end_while
    (77) g_while_quad -> .

    DO              reduce using rule 77 (g_while_quad -> .)

    g_while_quad                   shift and go to state 223

state 200

    (73) condition -> FOR ids validate_for ASSIGN expressions . for_counter_control TO expressions for_counter_end DO block end_for
    (80) for_counter_control -> .

    TO              reduce using rule 80 (for_counter_control -> .)

    for_counter_control            shift and go to state 224

state 201

    (83) return -> RETURN OPEN_PAREN expressions CLOSE_PAREN g_quad_return .

    SEMICOLON       reduce using rule 83 (return -> RETURN OPEN_PAREN expressions CLOSE_PAREN g_quad_return .)


state 202

    (85) func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp . CLOSE_PAREN g_gosub_quad function_call_end

    CLOSE_PAREN     shift and go to state 225


state 203

    (91) func_call_comp -> expressions . g_parameter_quad func_call_comp
    (94) g_parameter_quad -> .

    COMMA           reduce using rule 94 (g_parameter_quad -> .)
    OPEN_PAREN      reduce using rule 94 (g_parameter_quad -> .)
    CT_INT          reduce using rule 94 (g_parameter_quad -> .)
    CT_FLOAT        reduce using rule 94 (g_parameter_quad -> .)
    CT_CHAR         reduce using rule 94 (g_parameter_quad -> .)
    ID              reduce using rule 94 (g_parameter_quad -> .)
    CLOSE_PAREN     reduce using rule 94 (g_parameter_quad -> .)

    g_parameter_quad               shift and go to state 226

state 204

    (92) func_call_comp -> COMMA . expressions g_parameter_quad func_call_comp
    (95) expressions -> . expressions_comp
    (96) expressions_comp -> . expression_comp_2
    (97) expressions_comp -> . expression_comp_2 OR expressions_comp
    (98) expression_comp_2 -> . expression_comp_3
    (99) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (100) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (101) expression_comp_3 -> . exp
    (109) exp -> . term g_quad_exp_as_alone
    (110) exp -> . term g_quad_exp_as exp_comp
    (115) term -> . factor g_quad_exp_md_alone
    (116) term -> . factor g_quad_exp_md term_comp
    (122) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (123) factor -> . variable
    (124) factor -> . func_call
    (125) factor -> . CT_INT add_ct_int
    (126) factor -> . CT_FLOAT add_ct_float
    (127) factor -> . CT_CHAR add_ct_char
    (133) variable -> . ID add_id
    (134) variable -> . ID dim
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end

    OPEN_PAREN      shift and go to state 122
    CT_INT          shift and go to state 125
    CT_FLOAT        shift and go to state 126
    CT_CHAR         shift and go to state 127
    ID              shift and go to state 128

    expressions                    shift and go to state 227
    expressions_comp               shift and go to state 116
    expression_comp_2              shift and go to state 117
    expression_comp_3              shift and go to state 118
    exp                            shift and go to state 119
    term                           shift and go to state 120
    factor                         shift and go to state 121
    variable                       shift and go to state 123
    func_call                      shift and go to state 124

state 205

    (93) func_call_comp -> empty .

    CLOSE_PAREN     reduce using rule 93 (func_call_comp -> empty .)


state 206

    (47) ids_matrix -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS . exp CLOSE_BRACKETS
    (109) exp -> . term g_quad_exp_as_alone
    (110) exp -> . term g_quad_exp_as exp_comp
    (115) term -> . factor g_quad_exp_md_alone
    (116) term -> . factor g_quad_exp_md term_comp
    (122) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (123) factor -> . variable
    (124) factor -> . func_call
    (125) factor -> . CT_INT add_ct_int
    (126) factor -> . CT_FLOAT add_ct_float
    (127) factor -> . CT_CHAR add_ct_char
    (133) variable -> . ID add_id
    (134) variable -> . ID dim
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end

    OPEN_PAREN      shift and go to state 122
    CT_INT          shift and go to state 125
    CT_FLOAT        shift and go to state 126
    CT_CHAR         shift and go to state 127
    ID              shift and go to state 128

    exp                            shift and go to state 228
    term                           shift and go to state 120
    factor                         shift and go to state 121
    variable                       shift and go to state 123
    func_call                      shift and go to state 124

state 207

    (7) funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block . end_funcs funcs
    (9) end_funcs -> .

    VOID            reduce using rule 9 (end_funcs -> .)
    INT             reduce using rule 9 (end_funcs -> .)
    FLOAT           reduce using rule 9 (end_funcs -> .)
    CHAR            reduce using rule 9 (end_funcs -> .)
    MAIN            reduce using rule 9 (end_funcs -> .)
    OPEN_BRACES     reduce using rule 9 (end_funcs -> .)

    end_funcs                      shift and go to state 229

state 208

    (16) funcs_params_comp -> COMMA var_type variable_params funcs_params_comp .

    CLOSE_PAREN     reduce using rule 16 (funcs_params_comp -> COMMA var_type variable_params funcs_params_comp .)


state 209

    (12) funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN . add_parameter_amount vars count_local_vars block end_funcs funcs
    (13) add_parameter_amount -> .

    VARS            reduce using rule 13 (add_parameter_amount -> .)
    OPEN_BRACES     reduce using rule 13 (add_parameter_amount -> .)

    add_parameter_amount           shift and go to state 230

state 210

    (100) expression_comp_3 -> exp expressions_op exp g_quad_logic .

    AND             reduce using rule 100 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    OR              reduce using rule 100 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    SEMICOLON       reduce using rule 100 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    COMMA           reduce using rule 100 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    CLOSE_PAREN     reduce using rule 100 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    TO              reduce using rule 100 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    OPEN_PAREN      reduce using rule 100 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    CT_INT          reduce using rule 100 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    CT_FLOAT        reduce using rule 100 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    CT_CHAR         reduce using rule 100 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    ID              reduce using rule 100 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)
    DO              reduce using rule 100 (expression_comp_3 -> exp expressions_op exp g_quad_logic .)


state 211

    (113) exp_comp -> PLUS add_op . exp
    (109) exp -> . term g_quad_exp_as_alone
    (110) exp -> . term g_quad_exp_as exp_comp
    (115) term -> . factor g_quad_exp_md_alone
    (116) term -> . factor g_quad_exp_md term_comp
    (122) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (123) factor -> . variable
    (124) factor -> . func_call
    (125) factor -> . CT_INT add_ct_int
    (126) factor -> . CT_FLOAT add_ct_float
    (127) factor -> . CT_CHAR add_ct_char
    (133) variable -> . ID add_id
    (134) variable -> . ID dim
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end

    OPEN_PAREN      shift and go to state 122
    CT_INT          shift and go to state 125
    CT_FLOAT        shift and go to state 126
    CT_CHAR         shift and go to state 127
    ID              shift and go to state 128

    exp                            shift and go to state 231
    term                           shift and go to state 120
    factor                         shift and go to state 121
    variable                       shift and go to state 123
    func_call                      shift and go to state 124

state 212

    (114) exp_comp -> MINUS add_op . exp
    (109) exp -> . term g_quad_exp_as_alone
    (110) exp -> . term g_quad_exp_as exp_comp
    (115) term -> . factor g_quad_exp_md_alone
    (116) term -> . factor g_quad_exp_md term_comp
    (122) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (123) factor -> . variable
    (124) factor -> . func_call
    (125) factor -> . CT_INT add_ct_int
    (126) factor -> . CT_FLOAT add_ct_float
    (127) factor -> . CT_CHAR add_ct_char
    (133) variable -> . ID add_id
    (134) variable -> . ID dim
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end

    OPEN_PAREN      shift and go to state 122
    CT_INT          shift and go to state 125
    CT_FLOAT        shift and go to state 126
    CT_CHAR         shift and go to state 127
    ID              shift and go to state 128

    exp                            shift and go to state 232
    term                           shift and go to state 120
    factor                         shift and go to state 121
    variable                       shift and go to state 123
    func_call                      shift and go to state 124

state 213

    (119) term_comp -> MULTIPLIES add_op . term
    (115) term -> . factor g_quad_exp_md_alone
    (116) term -> . factor g_quad_exp_md term_comp
    (122) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (123) factor -> . variable
    (124) factor -> . func_call
    (125) factor -> . CT_INT add_ct_int
    (126) factor -> . CT_FLOAT add_ct_float
    (127) factor -> . CT_CHAR add_ct_char
    (133) variable -> . ID add_id
    (134) variable -> . ID dim
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end

    OPEN_PAREN      shift and go to state 122
    CT_INT          shift and go to state 125
    CT_FLOAT        shift and go to state 126
    CT_CHAR         shift and go to state 127
    ID              shift and go to state 128

    term                           shift and go to state 233
    factor                         shift and go to state 121
    variable                       shift and go to state 123
    func_call                      shift and go to state 124

state 214

    (120) term_comp -> DIVIDE add_op . term
    (115) term -> . factor g_quad_exp_md_alone
    (116) term -> . factor g_quad_exp_md term_comp
    (122) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (123) factor -> . variable
    (124) factor -> . func_call
    (125) factor -> . CT_INT add_ct_int
    (126) factor -> . CT_FLOAT add_ct_float
    (127) factor -> . CT_CHAR add_ct_char
    (133) variable -> . ID add_id
    (134) variable -> . ID dim
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end

    OPEN_PAREN      shift and go to state 122
    CT_INT          shift and go to state 125
    CT_FLOAT        shift and go to state 126
    CT_CHAR         shift and go to state 127
    ID              shift and go to state 128

    term                           shift and go to state 234
    factor                         shift and go to state 121
    variable                       shift and go to state 123
    func_call                      shift and go to state 124

state 215

    (122) factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN . rem_fake
    (129) rem_fake -> .

    MULTIPLIES      reduce using rule 129 (rem_fake -> .)
    DIVIDE          reduce using rule 129 (rem_fake -> .)
    PLUS            reduce using rule 129 (rem_fake -> .)
    MINUS           reduce using rule 129 (rem_fake -> .)
    LESS_THAN       reduce using rule 129 (rem_fake -> .)
    LESS_THAN_EQUAL reduce using rule 129 (rem_fake -> .)
    MORE_THAN       reduce using rule 129 (rem_fake -> .)
    MORE_THAN_EQUAL reduce using rule 129 (rem_fake -> .)
    EQUALS          reduce using rule 129 (rem_fake -> .)
    NOT_EQUALS      reduce using rule 129 (rem_fake -> .)
    AND             reduce using rule 129 (rem_fake -> .)
    OR              reduce using rule 129 (rem_fake -> .)
    SEMICOLON       reduce using rule 129 (rem_fake -> .)
    COMMA           reduce using rule 129 (rem_fake -> .)
    CLOSE_PAREN     reduce using rule 129 (rem_fake -> .)
    CLOSE_BRACKETS  reduce using rule 129 (rem_fake -> .)
    TO              reduce using rule 129 (rem_fake -> .)
    OPEN_PAREN      reduce using rule 129 (rem_fake -> .)
    CT_INT          reduce using rule 129 (rem_fake -> .)
    CT_FLOAT        reduce using rule 129 (rem_fake -> .)
    CT_CHAR         reduce using rule 129 (rem_fake -> .)
    ID              reduce using rule 129 (rem_fake -> .)
    DO              reduce using rule 129 (rem_fake -> .)

    rem_fake                       shift and go to state 235

state 216

    (58) read -> READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN .

    SEMICOLON       reduce using rule 58 (read -> READ OPEN_PAREN ids g_quad_read read_comp CLOSE_PAREN .)


state 217

    (59) read_comp -> COMMA ids . g_quad_read read_comp
    (61) g_quad_read -> .

    COMMA           reduce using rule 61 (g_quad_read -> .)
    CLOSE_PAREN     reduce using rule 61 (g_quad_read -> .)

    g_quad_read                    shift and go to state 236

state 218

    (62) write -> WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN .

    SEMICOLON       reduce using rule 62 (write -> WRITE OPEN_PAREN CT_STRING g_quad_write_str write_comp CLOSE_PAREN .)


state 219

    (64) write_comp -> COMMA CT_STRING . g_quad_write_str write_comp
    (67) g_quad_write_str -> .

    COMMA           reduce using rule 67 (g_quad_write_str -> .)
    CLOSE_PAREN     reduce using rule 67 (g_quad_write_str -> .)

    g_quad_write_str               shift and go to state 237

state 220

    (65) write_comp -> COMMA expressions . g_quad_write write_comp
    (68) g_quad_write -> .

    COMMA           reduce using rule 68 (g_quad_write -> .)
    CLOSE_PAREN     reduce using rule 68 (g_quad_write -> .)

    g_quad_write                   shift and go to state 238

state 221

    (63) write -> WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN .

    SEMICOLON       reduce using rule 63 (write -> WRITE OPEN_PAREN expressions g_quad_write write_comp CLOSE_PAREN .)


state 222

    (70) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN . block end_if
    (71) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN . block ELSE g_else_quad block end_if
    (20) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 50

    block                          shift and go to state 239

state 223

    (72) condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad . DO block end_while

    DO              shift and go to state 240


state 224

    (73) condition -> FOR ids validate_for ASSIGN expressions for_counter_control . TO expressions for_counter_end DO block end_for

    TO              shift and go to state 241


state 225

    (85) func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN . g_gosub_quad function_call_end
    (87) g_gosub_quad -> .

    SEMICOLON       reduce using rule 87 (g_gosub_quad -> .)
    MULTIPLIES      reduce using rule 87 (g_gosub_quad -> .)
    DIVIDE          reduce using rule 87 (g_gosub_quad -> .)
    PLUS            reduce using rule 87 (g_gosub_quad -> .)
    MINUS           reduce using rule 87 (g_gosub_quad -> .)
    LESS_THAN       reduce using rule 87 (g_gosub_quad -> .)
    LESS_THAN_EQUAL reduce using rule 87 (g_gosub_quad -> .)
    MORE_THAN       reduce using rule 87 (g_gosub_quad -> .)
    MORE_THAN_EQUAL reduce using rule 87 (g_gosub_quad -> .)
    EQUALS          reduce using rule 87 (g_gosub_quad -> .)
    NOT_EQUALS      reduce using rule 87 (g_gosub_quad -> .)
    AND             reduce using rule 87 (g_gosub_quad -> .)
    OR              reduce using rule 87 (g_gosub_quad -> .)
    COMMA           reduce using rule 87 (g_gosub_quad -> .)
    CLOSE_PAREN     reduce using rule 87 (g_gosub_quad -> .)
    CLOSE_BRACKETS  reduce using rule 87 (g_gosub_quad -> .)
    TO              reduce using rule 87 (g_gosub_quad -> .)
    OPEN_PAREN      reduce using rule 87 (g_gosub_quad -> .)
    CT_INT          reduce using rule 87 (g_gosub_quad -> .)
    CT_FLOAT        reduce using rule 87 (g_gosub_quad -> .)
    CT_CHAR         reduce using rule 87 (g_gosub_quad -> .)
    ID              reduce using rule 87 (g_gosub_quad -> .)
    DO              reduce using rule 87 (g_gosub_quad -> .)

    g_gosub_quad                   shift and go to state 242

state 226

    (91) func_call_comp -> expressions g_parameter_quad . func_call_comp
    (91) func_call_comp -> . expressions g_parameter_quad func_call_comp
    (92) func_call_comp -> . COMMA expressions g_parameter_quad func_call_comp
    (93) func_call_comp -> . empty
    (95) expressions -> . expressions_comp
    (137) empty -> .
    (96) expressions_comp -> . expression_comp_2
    (97) expressions_comp -> . expression_comp_2 OR expressions_comp
    (98) expression_comp_2 -> . expression_comp_3
    (99) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (100) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (101) expression_comp_3 -> . exp
    (109) exp -> . term g_quad_exp_as_alone
    (110) exp -> . term g_quad_exp_as exp_comp
    (115) term -> . factor g_quad_exp_md_alone
    (116) term -> . factor g_quad_exp_md term_comp
    (122) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (123) factor -> . variable
    (124) factor -> . func_call
    (125) factor -> . CT_INT add_ct_int
    (126) factor -> . CT_FLOAT add_ct_float
    (127) factor -> . CT_CHAR add_ct_char
    (133) variable -> . ID add_id
    (134) variable -> . ID dim
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end

    COMMA           shift and go to state 204
    CLOSE_PAREN     reduce using rule 137 (empty -> .)
    OPEN_PAREN      shift and go to state 122
    CT_INT          shift and go to state 125
    CT_FLOAT        shift and go to state 126
    CT_CHAR         shift and go to state 127
    ID              shift and go to state 128

    expressions                    shift and go to state 203
    func_call_comp                 shift and go to state 243
    empty                          shift and go to state 205
    expressions_comp               shift and go to state 116
    expression_comp_2              shift and go to state 117
    expression_comp_3              shift and go to state 118
    exp                            shift and go to state 119
    term                           shift and go to state 120
    factor                         shift and go to state 121
    variable                       shift and go to state 123
    func_call                      shift and go to state 124

state 227

    (92) func_call_comp -> COMMA expressions . g_parameter_quad func_call_comp
    (94) g_parameter_quad -> .

    COMMA           reduce using rule 94 (g_parameter_quad -> .)
    OPEN_PAREN      reduce using rule 94 (g_parameter_quad -> .)
    CT_INT          reduce using rule 94 (g_parameter_quad -> .)
    CT_FLOAT        reduce using rule 94 (g_parameter_quad -> .)
    CT_CHAR         reduce using rule 94 (g_parameter_quad -> .)
    ID              reduce using rule 94 (g_parameter_quad -> .)
    CLOSE_PAREN     reduce using rule 94 (g_parameter_quad -> .)

    g_parameter_quad               shift and go to state 244

state 228

    (47) ids_matrix -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp . CLOSE_BRACKETS

    CLOSE_BRACKETS  shift and go to state 245


state 229

    (7) funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs . funcs
    (7) funcs -> . func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs
    (8) funcs -> . empty
    (21) func_type -> . var_type
    (22) func_type -> . VOID
    (137) empty -> .
    (23) var_type -> . INT
    (24) var_type -> . FLOAT
    (25) var_type -> . CHAR

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
    VOID            shift and go to state 14
    MAIN            reduce using rule 137 (empty -> .)
    OPEN_BRACES     reduce using rule 137 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

  ! VOID            [ reduce using rule 137 (empty -> .) ]
  ! INT             [ reduce using rule 137 (empty -> .) ]
  ! FLOAT           [ reduce using rule 137 (empty -> .) ]
  ! CHAR            [ reduce using rule 137 (empty -> .) ]

    func_type                      shift and go to state 11
    funcs                          shift and go to state 246
    empty                          shift and go to state 12
    var_type                       shift and go to state 13

state 230

    (12) funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount . vars count_local_vars block end_funcs funcs
    (26) vars -> . VARS var_comp
    (27) vars -> . empty
    (137) empty -> .

    VARS            shift and go to state 8
    OPEN_BRACES     reduce using rule 137 (empty -> .)

    vars                           shift and go to state 247
    empty                          shift and go to state 9

state 231

    (113) exp_comp -> PLUS add_op exp .

    LESS_THAN       reduce using rule 113 (exp_comp -> PLUS add_op exp .)
    LESS_THAN_EQUAL reduce using rule 113 (exp_comp -> PLUS add_op exp .)
    MORE_THAN       reduce using rule 113 (exp_comp -> PLUS add_op exp .)
    MORE_THAN_EQUAL reduce using rule 113 (exp_comp -> PLUS add_op exp .)
    EQUALS          reduce using rule 113 (exp_comp -> PLUS add_op exp .)
    NOT_EQUALS      reduce using rule 113 (exp_comp -> PLUS add_op exp .)
    AND             reduce using rule 113 (exp_comp -> PLUS add_op exp .)
    OR              reduce using rule 113 (exp_comp -> PLUS add_op exp .)
    SEMICOLON       reduce using rule 113 (exp_comp -> PLUS add_op exp .)
    COMMA           reduce using rule 113 (exp_comp -> PLUS add_op exp .)
    CLOSE_PAREN     reduce using rule 113 (exp_comp -> PLUS add_op exp .)
    CLOSE_BRACKETS  reduce using rule 113 (exp_comp -> PLUS add_op exp .)
    TO              reduce using rule 113 (exp_comp -> PLUS add_op exp .)
    OPEN_PAREN      reduce using rule 113 (exp_comp -> PLUS add_op exp .)
    CT_INT          reduce using rule 113 (exp_comp -> PLUS add_op exp .)
    CT_FLOAT        reduce using rule 113 (exp_comp -> PLUS add_op exp .)
    CT_CHAR         reduce using rule 113 (exp_comp -> PLUS add_op exp .)
    ID              reduce using rule 113 (exp_comp -> PLUS add_op exp .)
    DO              reduce using rule 113 (exp_comp -> PLUS add_op exp .)


state 232

    (114) exp_comp -> MINUS add_op exp .

    LESS_THAN       reduce using rule 114 (exp_comp -> MINUS add_op exp .)
    LESS_THAN_EQUAL reduce using rule 114 (exp_comp -> MINUS add_op exp .)
    MORE_THAN       reduce using rule 114 (exp_comp -> MINUS add_op exp .)
    MORE_THAN_EQUAL reduce using rule 114 (exp_comp -> MINUS add_op exp .)
    EQUALS          reduce using rule 114 (exp_comp -> MINUS add_op exp .)
    NOT_EQUALS      reduce using rule 114 (exp_comp -> MINUS add_op exp .)
    AND             reduce using rule 114 (exp_comp -> MINUS add_op exp .)
    OR              reduce using rule 114 (exp_comp -> MINUS add_op exp .)
    SEMICOLON       reduce using rule 114 (exp_comp -> MINUS add_op exp .)
    COMMA           reduce using rule 114 (exp_comp -> MINUS add_op exp .)
    CLOSE_PAREN     reduce using rule 114 (exp_comp -> MINUS add_op exp .)
    CLOSE_BRACKETS  reduce using rule 114 (exp_comp -> MINUS add_op exp .)
    TO              reduce using rule 114 (exp_comp -> MINUS add_op exp .)
    OPEN_PAREN      reduce using rule 114 (exp_comp -> MINUS add_op exp .)
    CT_INT          reduce using rule 114 (exp_comp -> MINUS add_op exp .)
    CT_FLOAT        reduce using rule 114 (exp_comp -> MINUS add_op exp .)
    CT_CHAR         reduce using rule 114 (exp_comp -> MINUS add_op exp .)
    ID              reduce using rule 114 (exp_comp -> MINUS add_op exp .)
    DO              reduce using rule 114 (exp_comp -> MINUS add_op exp .)


state 233

    (119) term_comp -> MULTIPLIES add_op term .

    PLUS            reduce using rule 119 (term_comp -> MULTIPLIES add_op term .)
    MINUS           reduce using rule 119 (term_comp -> MULTIPLIES add_op term .)
    LESS_THAN       reduce using rule 119 (term_comp -> MULTIPLIES add_op term .)
    LESS_THAN_EQUAL reduce using rule 119 (term_comp -> MULTIPLIES add_op term .)
    MORE_THAN       reduce using rule 119 (term_comp -> MULTIPLIES add_op term .)
    MORE_THAN_EQUAL reduce using rule 119 (term_comp -> MULTIPLIES add_op term .)
    EQUALS          reduce using rule 119 (term_comp -> MULTIPLIES add_op term .)
    NOT_EQUALS      reduce using rule 119 (term_comp -> MULTIPLIES add_op term .)
    AND             reduce using rule 119 (term_comp -> MULTIPLIES add_op term .)
    OR              reduce using rule 119 (term_comp -> MULTIPLIES add_op term .)
    SEMICOLON       reduce using rule 119 (term_comp -> MULTIPLIES add_op term .)
    COMMA           reduce using rule 119 (term_comp -> MULTIPLIES add_op term .)
    CLOSE_PAREN     reduce using rule 119 (term_comp -> MULTIPLIES add_op term .)
    CLOSE_BRACKETS  reduce using rule 119 (term_comp -> MULTIPLIES add_op term .)
    TO              reduce using rule 119 (term_comp -> MULTIPLIES add_op term .)
    OPEN_PAREN      reduce using rule 119 (term_comp -> MULTIPLIES add_op term .)
    CT_INT          reduce using rule 119 (term_comp -> MULTIPLIES add_op term .)
    CT_FLOAT        reduce using rule 119 (term_comp -> MULTIPLIES add_op term .)
    CT_CHAR         reduce using rule 119 (term_comp -> MULTIPLIES add_op term .)
    ID              reduce using rule 119 (term_comp -> MULTIPLIES add_op term .)
    DO              reduce using rule 119 (term_comp -> MULTIPLIES add_op term .)


state 234

    (120) term_comp -> DIVIDE add_op term .

    PLUS            reduce using rule 120 (term_comp -> DIVIDE add_op term .)
    MINUS           reduce using rule 120 (term_comp -> DIVIDE add_op term .)
    LESS_THAN       reduce using rule 120 (term_comp -> DIVIDE add_op term .)
    LESS_THAN_EQUAL reduce using rule 120 (term_comp -> DIVIDE add_op term .)
    MORE_THAN       reduce using rule 120 (term_comp -> DIVIDE add_op term .)
    MORE_THAN_EQUAL reduce using rule 120 (term_comp -> DIVIDE add_op term .)
    EQUALS          reduce using rule 120 (term_comp -> DIVIDE add_op term .)
    NOT_EQUALS      reduce using rule 120 (term_comp -> DIVIDE add_op term .)
    AND             reduce using rule 120 (term_comp -> DIVIDE add_op term .)
    OR              reduce using rule 120 (term_comp -> DIVIDE add_op term .)
    SEMICOLON       reduce using rule 120 (term_comp -> DIVIDE add_op term .)
    COMMA           reduce using rule 120 (term_comp -> DIVIDE add_op term .)
    CLOSE_PAREN     reduce using rule 120 (term_comp -> DIVIDE add_op term .)
    CLOSE_BRACKETS  reduce using rule 120 (term_comp -> DIVIDE add_op term .)
    TO              reduce using rule 120 (term_comp -> DIVIDE add_op term .)
    OPEN_PAREN      reduce using rule 120 (term_comp -> DIVIDE add_op term .)
    CT_INT          reduce using rule 120 (term_comp -> DIVIDE add_op term .)
    CT_FLOAT        reduce using rule 120 (term_comp -> DIVIDE add_op term .)
    CT_CHAR         reduce using rule 120 (term_comp -> DIVIDE add_op term .)
    ID              reduce using rule 120 (term_comp -> DIVIDE add_op term .)
    DO              reduce using rule 120 (term_comp -> DIVIDE add_op term .)


state 235

    (122) factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .

    MULTIPLIES      reduce using rule 122 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    DIVIDE          reduce using rule 122 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    PLUS            reduce using rule 122 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    MINUS           reduce using rule 122 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    LESS_THAN       reduce using rule 122 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    LESS_THAN_EQUAL reduce using rule 122 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    MORE_THAN       reduce using rule 122 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    MORE_THAN_EQUAL reduce using rule 122 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    EQUALS          reduce using rule 122 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    NOT_EQUALS      reduce using rule 122 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    AND             reduce using rule 122 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    OR              reduce using rule 122 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    SEMICOLON       reduce using rule 122 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    COMMA           reduce using rule 122 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    CLOSE_PAREN     reduce using rule 122 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    CLOSE_BRACKETS  reduce using rule 122 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    TO              reduce using rule 122 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    OPEN_PAREN      reduce using rule 122 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    CT_INT          reduce using rule 122 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    CT_FLOAT        reduce using rule 122 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    CT_CHAR         reduce using rule 122 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    ID              reduce using rule 122 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)
    DO              reduce using rule 122 (factor -> OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake .)


state 236

    (59) read_comp -> COMMA ids g_quad_read . read_comp
    (59) read_comp -> . COMMA ids g_quad_read read_comp
    (60) read_comp -> . empty
    (137) empty -> .

    COMMA           shift and go to state 192
    CLOSE_PAREN     reduce using rule 137 (empty -> .)

    read_comp                      shift and go to state 248
    empty                          shift and go to state 193

state 237

    (64) write_comp -> COMMA CT_STRING g_quad_write_str . write_comp
    (64) write_comp -> . COMMA CT_STRING g_quad_write_str write_comp
    (65) write_comp -> . COMMA expressions g_quad_write write_comp
    (66) write_comp -> . empty
    (137) empty -> .

    COMMA           shift and go to state 195
    CLOSE_PAREN     reduce using rule 137 (empty -> .)

    write_comp                     shift and go to state 249
    empty                          shift and go to state 196

state 238

    (65) write_comp -> COMMA expressions g_quad_write . write_comp
    (64) write_comp -> . COMMA CT_STRING g_quad_write_str write_comp
    (65) write_comp -> . COMMA expressions g_quad_write write_comp
    (66) write_comp -> . empty
    (137) empty -> .

    COMMA           shift and go to state 195
    CLOSE_PAREN     reduce using rule 137 (empty -> .)

    write_comp                     shift and go to state 250
    empty                          shift and go to state 196

state 239

    (70) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block . end_if
    (71) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block . ELSE g_else_quad block end_if
    (69) end_if -> .

    ELSE            shift and go to state 252
    READ            reduce using rule 69 (end_if -> .)
    WRITE           reduce using rule 69 (end_if -> .)
    IF              reduce using rule 69 (end_if -> .)
    WHILE           reduce using rule 69 (end_if -> .)
    FOR             reduce using rule 69 (end_if -> .)
    RETURN          reduce using rule 69 (end_if -> .)
    ID              reduce using rule 69 (end_if -> .)
    CLOSE_BRACES    reduce using rule 69 (end_if -> .)

    end_if                         shift and go to state 251

state 240

    (72) condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO . block end_while
    (20) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 50

    block                          shift and go to state 253

state 241

    (73) condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO . expressions for_counter_end DO block end_for
    (95) expressions -> . expressions_comp
    (96) expressions_comp -> . expression_comp_2
    (97) expressions_comp -> . expression_comp_2 OR expressions_comp
    (98) expression_comp_2 -> . expression_comp_3
    (99) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (100) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (101) expression_comp_3 -> . exp
    (109) exp -> . term g_quad_exp_as_alone
    (110) exp -> . term g_quad_exp_as exp_comp
    (115) term -> . factor g_quad_exp_md_alone
    (116) term -> . factor g_quad_exp_md term_comp
    (122) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (123) factor -> . variable
    (124) factor -> . func_call
    (125) factor -> . CT_INT add_ct_int
    (126) factor -> . CT_FLOAT add_ct_float
    (127) factor -> . CT_CHAR add_ct_char
    (133) variable -> . ID add_id
    (134) variable -> . ID dim
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end

    OPEN_PAREN      shift and go to state 122
    CT_INT          shift and go to state 125
    CT_FLOAT        shift and go to state 126
    CT_CHAR         shift and go to state 127
    ID              shift and go to state 128

    expressions                    shift and go to state 254
    expressions_comp               shift and go to state 116
    expression_comp_2              shift and go to state 117
    expression_comp_3              shift and go to state 118
    exp                            shift and go to state 119
    term                           shift and go to state 120
    factor                         shift and go to state 121
    variable                       shift and go to state 123
    func_call                      shift and go to state 124

state 242

    (85) func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad . function_call_end
    (86) function_call_end -> .

    SEMICOLON       reduce using rule 86 (function_call_end -> .)
    MULTIPLIES      reduce using rule 86 (function_call_end -> .)
    DIVIDE          reduce using rule 86 (function_call_end -> .)
    PLUS            reduce using rule 86 (function_call_end -> .)
    MINUS           reduce using rule 86 (function_call_end -> .)
    LESS_THAN       reduce using rule 86 (function_call_end -> .)
    LESS_THAN_EQUAL reduce using rule 86 (function_call_end -> .)
    MORE_THAN       reduce using rule 86 (function_call_end -> .)
    MORE_THAN_EQUAL reduce using rule 86 (function_call_end -> .)
    EQUALS          reduce using rule 86 (function_call_end -> .)
    NOT_EQUALS      reduce using rule 86 (function_call_end -> .)
    AND             reduce using rule 86 (function_call_end -> .)
    OR              reduce using rule 86 (function_call_end -> .)
    COMMA           reduce using rule 86 (function_call_end -> .)
    CLOSE_PAREN     reduce using rule 86 (function_call_end -> .)
    CLOSE_BRACKETS  reduce using rule 86 (function_call_end -> .)
    TO              reduce using rule 86 (function_call_end -> .)
    OPEN_PAREN      reduce using rule 86 (function_call_end -> .)
    CT_INT          reduce using rule 86 (function_call_end -> .)
    CT_FLOAT        reduce using rule 86 (function_call_end -> .)
    CT_CHAR         reduce using rule 86 (function_call_end -> .)
    ID              reduce using rule 86 (function_call_end -> .)
    DO              reduce using rule 86 (function_call_end -> .)

    function_call_end              shift and go to state 255

state 243

    (91) func_call_comp -> expressions g_parameter_quad func_call_comp .

    CLOSE_PAREN     reduce using rule 91 (func_call_comp -> expressions g_parameter_quad func_call_comp .)


state 244

    (92) func_call_comp -> COMMA expressions g_parameter_quad . func_call_comp
    (91) func_call_comp -> . expressions g_parameter_quad func_call_comp
    (92) func_call_comp -> . COMMA expressions g_parameter_quad func_call_comp
    (93) func_call_comp -> . empty
    (95) expressions -> . expressions_comp
    (137) empty -> .
    (96) expressions_comp -> . expression_comp_2
    (97) expressions_comp -> . expression_comp_2 OR expressions_comp
    (98) expression_comp_2 -> . expression_comp_3
    (99) expression_comp_2 -> . expression_comp_3 AND expression_comp_2
    (100) expression_comp_3 -> . exp expressions_op exp g_quad_logic
    (101) expression_comp_3 -> . exp
    (109) exp -> . term g_quad_exp_as_alone
    (110) exp -> . term g_quad_exp_as exp_comp
    (115) term -> . factor g_quad_exp_md_alone
    (116) term -> . factor g_quad_exp_md term_comp
    (122) factor -> . OPEN_PAREN add_fake expressions CLOSE_PAREN rem_fake
    (123) factor -> . variable
    (124) factor -> . func_call
    (125) factor -> . CT_INT add_ct_int
    (126) factor -> . CT_FLOAT add_ct_float
    (127) factor -> . CT_CHAR add_ct_char
    (133) variable -> . ID add_id
    (134) variable -> . ID dim
    (85) func_call -> . ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end

    COMMA           shift and go to state 204
    CLOSE_PAREN     reduce using rule 137 (empty -> .)
    OPEN_PAREN      shift and go to state 122
    CT_INT          shift and go to state 125
    CT_FLOAT        shift and go to state 126
    CT_CHAR         shift and go to state 127
    ID              shift and go to state 128

    expressions                    shift and go to state 203
    func_call_comp                 shift and go to state 256
    empty                          shift and go to state 205
    expressions_comp               shift and go to state 116
    expression_comp_2              shift and go to state 117
    expression_comp_3              shift and go to state 118
    exp                            shift and go to state 119
    term                           shift and go to state 120
    factor                         shift and go to state 121
    variable                       shift and go to state 123
    func_call                      shift and go to state 124

state 245

    (47) ids_matrix -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS .

    ASSIGN          reduce using rule 47 (ids_matrix -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS .)
    COMMA           reduce using rule 47 (ids_matrix -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS .)
    CLOSE_PAREN     reduce using rule 47 (ids_matrix -> ID OPEN_BRACKETS exp CLOSE_BRACKETS OPEN_BRACKETS exp CLOSE_BRACKETS .)


state 246

    (7) funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .

    MAIN            reduce using rule 7 (funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .)
    VOID            reduce using rule 7 (funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .)
    INT             reduce using rule 7 (funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .)
    FLOAT           reduce using rule 7 (funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .)
    CHAR            reduce using rule 7 (funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .)
    OPEN_BRACES     reduce using rule 7 (funcs -> func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .)


state 247

    (12) funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars . count_local_vars block end_funcs funcs
    (10) count_local_vars -> .

    OPEN_BRACES     reduce using rule 10 (count_local_vars -> .)

    count_local_vars               shift and go to state 257

state 248

    (59) read_comp -> COMMA ids g_quad_read read_comp .

    CLOSE_PAREN     reduce using rule 59 (read_comp -> COMMA ids g_quad_read read_comp .)


state 249

    (64) write_comp -> COMMA CT_STRING g_quad_write_str write_comp .

    CLOSE_PAREN     reduce using rule 64 (write_comp -> COMMA CT_STRING g_quad_write_str write_comp .)


state 250

    (65) write_comp -> COMMA expressions g_quad_write write_comp .

    CLOSE_PAREN     reduce using rule 65 (write_comp -> COMMA expressions g_quad_write write_comp .)


state 251

    (70) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .

    READ            reduce using rule 70 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    WRITE           reduce using rule 70 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    IF              reduce using rule 70 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    WHILE           reduce using rule 70 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    FOR             reduce using rule 70 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    RETURN          reduce using rule 70 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    ID              reduce using rule 70 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)
    CLOSE_BRACES    reduce using rule 70 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block end_if .)


state 252

    (71) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE . g_else_quad block end_if
    (75) g_else_quad -> .

    OPEN_BRACES     reduce using rule 75 (g_else_quad -> .)

    g_else_quad                    shift and go to state 258

state 253

    (72) condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block . end_while
    (78) end_while -> .

    READ            reduce using rule 78 (end_while -> .)
    WRITE           reduce using rule 78 (end_while -> .)
    IF              reduce using rule 78 (end_while -> .)
    WHILE           reduce using rule 78 (end_while -> .)
    FOR             reduce using rule 78 (end_while -> .)
    RETURN          reduce using rule 78 (end_while -> .)
    ID              reduce using rule 78 (end_while -> .)
    CLOSE_BRACES    reduce using rule 78 (end_while -> .)

    end_while                      shift and go to state 259

state 254

    (73) condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions . for_counter_end DO block end_for
    (81) for_counter_end -> .

    DO              reduce using rule 81 (for_counter_end -> .)

    for_counter_end                shift and go to state 260

state 255

    (85) func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end .

    SEMICOLON       reduce using rule 85 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end .)
    MULTIPLIES      reduce using rule 85 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end .)
    DIVIDE          reduce using rule 85 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end .)
    PLUS            reduce using rule 85 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end .)
    MINUS           reduce using rule 85 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end .)
    LESS_THAN       reduce using rule 85 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end .)
    LESS_THAN_EQUAL reduce using rule 85 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end .)
    MORE_THAN       reduce using rule 85 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end .)
    MORE_THAN_EQUAL reduce using rule 85 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end .)
    EQUALS          reduce using rule 85 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end .)
    NOT_EQUALS      reduce using rule 85 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end .)
    AND             reduce using rule 85 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end .)
    OR              reduce using rule 85 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end .)
    COMMA           reduce using rule 85 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end .)
    CLOSE_PAREN     reduce using rule 85 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end .)
    CLOSE_BRACKETS  reduce using rule 85 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end .)
    TO              reduce using rule 85 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end .)
    OPEN_PAREN      reduce using rule 85 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end .)
    CT_INT          reduce using rule 85 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end .)
    CT_FLOAT        reduce using rule 85 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end .)
    CT_CHAR         reduce using rule 85 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end .)
    ID              reduce using rule 85 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end .)
    DO              reduce using rule 85 (func_call -> ID verify_function_exists OPEN_PAREN era_activation func_call_comp CLOSE_PAREN g_gosub_quad function_call_end .)


state 256

    (92) func_call_comp -> COMMA expressions g_parameter_quad func_call_comp .

    CLOSE_PAREN     reduce using rule 92 (func_call_comp -> COMMA expressions g_parameter_quad func_call_comp .)


state 257

    (12) funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars . block end_funcs funcs
    (20) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 50

    block                          shift and go to state 261

state 258

    (71) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad . block end_if
    (20) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 50

    block                          shift and go to state 262

state 259

    (72) condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .

    READ            reduce using rule 72 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .)
    WRITE           reduce using rule 72 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .)
    IF              reduce using rule 72 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .)
    WHILE           reduce using rule 72 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .)
    FOR             reduce using rule 72 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .)
    RETURN          reduce using rule 72 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .)
    ID              reduce using rule 72 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .)
    CLOSE_BRACES    reduce using rule 72 (condition -> WHILE while_jump OPEN_PAREN expressions CLOSE_PAREN g_while_quad DO block end_while .)


state 260

    (73) condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end . DO block end_for

    DO              shift and go to state 263


state 261

    (12) funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block . end_funcs funcs
    (9) end_funcs -> .

    VOID            reduce using rule 9 (end_funcs -> .)
    INT             reduce using rule 9 (end_funcs -> .)
    FLOAT           reduce using rule 9 (end_funcs -> .)
    CHAR            reduce using rule 9 (end_funcs -> .)
    MAIN            reduce using rule 9 (end_funcs -> .)
    OPEN_BRACES     reduce using rule 9 (end_funcs -> .)

    end_funcs                      shift and go to state 264

state 262

    (71) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block . end_if
    (69) end_if -> .

    READ            reduce using rule 69 (end_if -> .)
    WRITE           reduce using rule 69 (end_if -> .)
    IF              reduce using rule 69 (end_if -> .)
    WHILE           reduce using rule 69 (end_if -> .)
    FOR             reduce using rule 69 (end_if -> .)
    RETURN          reduce using rule 69 (end_if -> .)
    ID              reduce using rule 69 (end_if -> .)
    CLOSE_BRACES    reduce using rule 69 (end_if -> .)

    end_if                         shift and go to state 265

state 263

    (73) condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO . block end_for
    (20) block -> . OPEN_BRACES statements CLOSE_BRACES

    OPEN_BRACES     shift and go to state 50

    block                          shift and go to state 266

state 264

    (12) funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs . funcs
    (7) funcs -> . func_type MODULE ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs
    (8) funcs -> . empty
    (21) func_type -> . var_type
    (22) func_type -> . VOID
    (137) empty -> .
    (23) var_type -> . INT
    (24) var_type -> . FLOAT
    (25) var_type -> . CHAR

  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for CHAR resolved as shift
    VOID            shift and go to state 14
    MAIN            reduce using rule 137 (empty -> .)
    OPEN_BRACES     reduce using rule 137 (empty -> .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    CHAR            shift and go to state 17

  ! VOID            [ reduce using rule 137 (empty -> .) ]
  ! INT             [ reduce using rule 137 (empty -> .) ]
  ! FLOAT           [ reduce using rule 137 (empty -> .) ]
  ! CHAR            [ reduce using rule 137 (empty -> .) ]

    funcs                          shift and go to state 267
    func_type                      shift and go to state 11
    empty                          shift and go to state 12
    var_type                       shift and go to state 13

state 265

    (71) condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .

    READ            reduce using rule 71 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .)
    WRITE           reduce using rule 71 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .)
    IF              reduce using rule 71 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .)
    WHILE           reduce using rule 71 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .)
    FOR             reduce using rule 71 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .)
    RETURN          reduce using rule 71 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .)
    ID              reduce using rule 71 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .)
    CLOSE_BRACES    reduce using rule 71 (condition -> IF OPEN_PAREN expressions CLOSE_PAREN g_if_quad THEN block ELSE g_else_quad block end_if .)


state 266

    (73) condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block . end_for
    (82) end_for -> .

    READ            reduce using rule 82 (end_for -> .)
    WRITE           reduce using rule 82 (end_for -> .)
    IF              reduce using rule 82 (end_for -> .)
    WHILE           reduce using rule 82 (end_for -> .)
    FOR             reduce using rule 82 (end_for -> .)
    RETURN          reduce using rule 82 (end_for -> .)
    ID              reduce using rule 82 (end_for -> .)
    CLOSE_BRACES    reduce using rule 82 (end_for -> .)

    end_for                        shift and go to state 268

state 267

    (12) funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .

    VOID            reduce using rule 12 (funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .)
    INT             reduce using rule 12 (funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .)
    FLOAT           reduce using rule 12 (funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .)
    CHAR            reduce using rule 12 (funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .)
    MAIN            reduce using rule 12 (funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .)
    OPEN_BRACES     reduce using rule 12 (funcs_comp -> ID add_module OPEN_PAREN funcs_params CLOSE_PAREN add_parameter_amount vars count_local_vars block end_funcs funcs .)


state 268

    (73) condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .

    READ            reduce using rule 73 (condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .)
    WRITE           reduce using rule 73 (condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .)
    IF              reduce using rule 73 (condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .)
    WHILE           reduce using rule 73 (condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .)
    FOR             reduce using rule 73 (condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .)
    RETURN          reduce using rule 73 (condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .)
    ID              reduce using rule 73 (condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .)
    CLOSE_BRACES    reduce using rule 73 (condition -> FOR ids validate_for ASSIGN expressions for_counter_control TO expressions for_counter_end DO block end_for .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for INT in state 38 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 38 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 38 resolved as shift
WARNING: shift/reduce conflict for INT in state 108 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 108 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 108 resolved as shift
WARNING: shift/reduce conflict for VOID in state 229 resolved as shift
WARNING: shift/reduce conflict for INT in state 229 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 229 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 229 resolved as shift
WARNING: shift/reduce conflict for VOID in state 264 resolved as shift
WARNING: shift/reduce conflict for INT in state 264 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 264 resolved as shift
WARNING: shift/reduce conflict for CHAR in state 264 resolved as shift
WARNING: reduce/reduce conflict in state 128 resolved using rule (verify_function_exists -> <empty>)
WARNING: rejected rule (add_id -> <empty>) in state 128
